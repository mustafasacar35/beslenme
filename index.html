<!DOCTYPE html>

<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Beslenme Planlayıcı</title>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script><style>
        :root{--primary-color:#007BFF;--primary-hover:#0056b3;--success-color:#28A745;--success-hover:#218838;--danger-color:#DC3545;--danger-hover:#C82333;--secondary-color:#6C757D;--secondary-hover:#5A6268;--background-color:#F8F9FA;--white:#FFFFFF;--gray-light:#E9ECEF;--gray-border:#DEE2E6;--text-dark:#212529;--text-light:#FFFFFF;--shadow:0 2px 4px rgba(0,0,0,0.1);--shadow-lg:0 4px 8px rgba(0,0,0,0.2);}
body{font-family:'Segoe UI',Arial,sans-serif;background-color:var(--background-color);margin:0;padding:0;overflow:hidden;}
.navbar{background-color:var(--primary-color)!important;padding:0.5rem 1rem;}
.navbar-brand,.nav-link{color:var(--text-light)!important;font-size:0.9rem;}
.nav-link:hover{color:#E7F1FF!important;}
.main-container{display:flex;height:calc(100vh - 56px);overflow:hidden;}
.sidebar{width:250px;height:100%;overflow-y:auto;background-color:var(--white);border-right:1px solid var(--gray-border);transition:width 0.3s;display:flex;flex-direction:column;}
.sidebar-header{padding:10px;border-bottom:1px solid var(--gray-border);}
.sidebar-content{flex:1;overflow-y:auto;padding:10px;}
.resizer {
  width: 8px; /* Biraz daha kalın, tutması kolay */
  background-color: #dee2e6; /* Gri ton, daha görünür */
  cursor: ew-resize; /* Yatay resize simgesi */
  transition: background-color 0.2s; /* Hover efekti için */
}

.resizer:hover {
  background-color: #adb5bd; /* Hover'da koyulaşsın */
}
.main-content{flex:1;height:100%;overflow-y:auto;background-color:var(--background-color);padding:10px;}
.accordion-button{background-color:var(--primary-color);color:var(--text-light);box-shadow:none;font-size:0.9rem;padding:0.5rem;}
.accordion-button.green{background-color:var(--success-color);}
.accordion-button.green:not(.collapsed){background-color:var(--success-hover);}
.accordion-button:not(.collapsed){background-color:var(--primary-hover);}
.accordion-button:hover{background-color:var(--primary-hover);}
.category-item{padding:5px;margin-bottom:3px;border-radius:4px;background-color:var(--white);border:1px solid var(--gray-border);font-size:0.85rem;display:flex;align-items:center;justify-content:space-between;}
.category-item:hover{background-color:var(--gray-light);}
.meal-card{margin-bottom:10px;box-shadow:var(--shadow);background-color:var(--white);cursor:pointer;}
.meal-card .card-header{background-color:var(--primary-color);color:var(--text-light);padding:0.5rem;font-size:0.9rem;display:flex;justify-content:space-between;align-items:center;}
.meal-table th:nth-child(2),.meal-table td:nth-child(2){min-width:120px;text-align:left;}
.macro-display{display:flex;align-items:stretch;margin-top:15px;background-color:var(--white);padding:10px;}
#macroTotals{flex:1;margin-right:20px;}
.macro-charts{display:flex;align-items:center;}
.chart-container{text-align:center;margin-right:20px;}
.chart-container:last-child{margin-right:0;}
.chart-container h4{margin-bottom:10px;font-size:14px;}
.chart-container canvas{display:block;}
.macro-table th{background-color:var(--gray-light);font-size:0.85rem;padding:0.3rem;}
.macro-exceed{background-color:#ffcccc;}
.macro-low{background-color:#cce5ff;}
.btn{font-size:0.85rem;padding:0.3rem 0.6rem;}
.btn-primary{background-color:var(--primary-color);border-color:var(--primary-color);}
.btn-primary:hover{background-color:var(--primary-hover);}
.btn-success{background-color:var(--success-color);border-color:var(--success-color);}
.btn-success:hover{background-color:var(--success-hover);}
.btn-danger{background-color:var(--danger-color);border-color:var(--danger-color);}
.btn-danger:hover{background-color:var(--danger-hover);}
.btn-remove-from-meal {
    background-color: #28a745 !important; /* Yeşil ton */
    border-color: #28a745 !important;
    color: white;
}
.btn-remove-from-meal:hover {
    background-color: #218838 !important; /* Hover’da daha koyu yeşil */
    border-color: #218838 !important;
}
.meal-search-input {
    font-size: 0.9rem;
    padding: 0.4rem 0.8rem;
    border-radius: 6px;
    border: 1px solid var(--gray-border);
    transition: box-shadow 0.2s, border-color 0.2s;
    width: 100%;
    max-width: 250px;
    min-width: 150px;
}

.meal-search-input:focus {
    box-shadow: 0 0 5px rgba(0, 123, 255, 0.3);
    border-color: var(--primary-color);
    outline: none;
}

@media (max-width: 768px) {
    .meal-search-input {
        max-width: 200px;
        min-width: 120px;
    }
}

.search-results {
    box-shadow: var(--shadow-lg); /* Daha belirgin gölge */
    background-color: var(--white);
    border-radius: 6px; /* Yuvarlak köşeler */
    overflow: hidden; /* Köşelerde taşmayı önler */
}

.search-result-item {
    padding: 0.6rem 1rem; /* Daha geniş padding */
    font-size: 0.9rem; /* Okunabilir font */
    color: var(--text-dark); /* Koyu yazı rengi */
    border-bottom: 1px solid var(--gray-light);
    transition: background-color 0.2s ease; /* Yumuşak geçiş */
    display: flex; /* İkon ve metni hizalamak için */
    align-items: center;
    cursor: pointer;
}

.search-result-item:hover {
    background-color: #e9ecef; /* Daha yumuşak hover rengi */
}

.search-result-item:last-child {
    border-bottom: none;
}

.search-result-item::before {
    content: "\1F37D"; /* Unicode: Yemek tabağı emojisi */
    margin-right: 0.5rem; /* İkon ile metin arası boşluk */
    font-size: 1rem;
}

.search-result-empty {
    padding: 0.6rem 1rem;
    font-size: 0.9rem;
    color: var(--text-dark);
    font-style: italic;
}
.search-result-item {
    padding: 0.6rem 1rem;
    font-size: 0.9rem;
    color: var(--text-dark);
    border-bottom: 1px solid var(--gray-light);
    transition: background-color 0.2s ease;
    display: flex;
    align-items: center;
    cursor: pointer;
}

.search-result-item:hover {
    background-color: #e9ecef;
    font-weight: 500; /* Hover'da hafif kalın font */
}

.edit-food-panel {
    position: fixed;
    top: 10%;
    left: 50%;
    transform: translateX(-50%);
    width: 1000px; /* Daha geniş form */
    min-width: 1000px; /* Minimum genişlik */
    background-color: var(--white);
    border: 1px solid var(--gray-border);
    padding: 20px;
    z-index: 1000;
    box-shadow: var(--shadow-lg);
    display: none;
    max-height: 65vh; /* Yükseklik uygun */
    overflow-y: auto;
    overflow-x: hidden; /* Yatay scrollbar'ı engeller */
    border-radius: 10px;
    box-sizing: border-box; /* Padding ve border genişliğe dahil edilir */
}
.edit-food-panel h5 {
    margin: 0 0 15px 0;
    font-size: 1.2rem;
    font-weight: 500;
}
.edit-food-panel .form-control-sm, .edit-food-panel .form-select-sm {
    padding: 0.35rem 0.7rem;
    font-size: 0.9rem;
    border-radius: 5px;
    width: 100%;
    max-width: 100%; /* Sütun sınırını aşmaz */
}
.edit-food-panel .wide-input {
    width: 100%;
    min-width: 350px; /* Daha geniş input'lar */
    max-width: 100%; /* Sütun sınırını aşmaz */
}
.edit-food-panel .form-label {
    font-size: 0.9rem;
    white-space: nowrap;
    color: var(--text-dark);
}
.edit-food-panel .form-check {
    margin-right: 1.5rem; /* Checkbox'lar arasında daha fazla boşluk */
}
.edit-food-panel .form-check-input {
    margin-right: 0.5rem;
}
.edit-food-panel .btn {
    padding: 0.5rem 1rem;
    font-size: 0.9rem;
    border-radius: 5px;
}
.edit-food-panel .row {
    margin-bottom: 0.8rem; /* Satırlar arasında uygun boşluk */
}
.edit-food-panel .d-flex.gap-3 {
    display: flex;
    gap: 1.5rem; /* Checkbox'lar arasında boşluk */
    align-items: center;
}
@media (max-width: 1366px) { /* Daha düşük bir eşik */
    .edit-food-panel {
        width: 90%; /* Küçük ekranlarda esnek genişlik */
        max-height: 75vh;
        padding: 15px;
    }
    .edit-food-panel .col-3 {
        width: 35%; /* Label'lar daha dar */
    }
    .edit-food-panel .col-9 {
        width: 65%; /* Input'lar daha geniş */
    }
    .edit-food-panel .wide-input {
        min-width: 250px; /* Küçük ekranlarda daha dar input'lar */
    }
}
.close-btn {
    position: absolute;
    top: 5px;
    right: 10px;
    font-size: 24px;
    cursor: pointer;
    color: #333;
}

.close-btn:hover {
    color: #000;
}
.meal-table th:first-child, .meal-table td:first-child {
    width: 80px; /* Kural sütunu için sabit genişlik */
    text-align: center;
}
.meal-table th, .meal-table td {
    padding: 8px;
    text-align: center;
}
.meal-table th:nth-child(1), .meal-table td:nth-child(1) { width: 15%; } /* Uygulanan Kural */
.meal-table th:nth-child(2), .meal-table td:nth-child(2) { width: 15%; } /* Çakışan Kurallar */
.btn-secondary{background-color:var(--secondary-color);border-color:var(--secondary-color);}
.btn-secondary:hover{background-color:var(--secondary-hover);}
.btn-group{display:flex;gap:5px;}
.fixed-btn{position:sticky;top:10px;z-index:10;}
.fixed-btn-group{position:fixed;top:8px;left:20px;z-index:1000;background-color:var(--background-color);padding:3px;border-radius:5px;display:flex;flex-wrap:wrap;gap:10px;justify-content:flex-end;box-shadow:var(--shadow);}
.fixed-buttons{position:fixed;bottom:10px;right:10px;z-index:1000;display:flex;gap:3px;background-color:var(--background-color);padding:5px;border-radius:5px;}
.form-control,.form-select{font-size:0.85rem;padding:0.3rem;}
.settings-panel{background-color:var(--background-color);padding:10px;border:1px solid var(--gray-border);margin-bottom:15px;}
.edit-food-panel{position:fixed;top:20%;left:50%;transform:translateX(-50%);width:300px;background-color:var(--white);border:1px solid var(--gray-border);padding:10px;z-index:1000;box-shadow:var(--shadow-lg);display:none;}
.nav-tabs .nav-link{color:var(--text-dark);background-color:var(--gray-light);font-size:0.85rem;padding:0.3rem 0.6rem;}
.nav-tabs .nav-link.active{color:var(--text-light);background-color:var(--primary-color);}
#notification{position:fixed;top:10px;right:10px;z-index:1000;}
.alert-success{background-color:var(--success-color);color:var(--text-light);padding:10px;border-radius:5px;}
.alert-warning{background-color:#FFC107;color:var(--text-dark);padding:10px;border-radius:5px;}
.visually-hidden{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0;}
.meal-checkboxes,.food-checkboxes,.role-checkboxes{display:flex;flex-wrap:wrap;gap:5px;}
.role-checkboxes{font-size:0.8rem;}
.inline-accordion{display:inline-block;width:49%;margin-right:1%;}
.macro-modal{display:none;position:fixed;z-index:1000;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,0.5);justify-content:center;align-items:center;}
.macro-modal-content{background-color:var(--white);padding:20px;border-radius:10px;position:relative;text-align:center;max-width:700px;width:90%;}
.macro-modal-close{position:absolute;top:10px;right:15px;font-size:24px;cursor:pointer;color:#333;}
.macro-modal-content h3{margin-bottom:20px;font-size:18px;}
.macro-modal-body{display:flex;align-items:flex-start;gap:20px;}
.macro-modal-chart{flex:0 0 300px;text-align:center;} /* Sabit genişlik: 300px */
#macroModalChart{width:300px;height:300px;display:block;}
.macro-modal-analysis{flex:1;background-color:#f9f9f9;padding:15px;border-radius:5px;font-size:14px;line-height:1.5;min-height:300px;overflow-y:auto;color:#333;}
.macro-modal-analysis h4{margin:0 0 10px 0;font-size:16px;color:#222;}
.macro-modal-analysis p{margin:5px 0;color:#333;}
.macro-modal-analysis .disclaimer{margin-top:15px;font-size:12px;font-style:italic;color:#666;}
.macro-tooltip{position:absolute;background-color:rgba(0,0,0,0.8);color:var(--text-light);padding:5px 10px;border-radius:5px;font-size:12px;pointer-events:none;z-index:1000;display:none;}
@media (max-width:768px){
    .sidebar{width:0;position:fixed;z-index:1000;height:100%;}
    .sidebar.active{width:200px;}
    .resizer{display:none;}
    .inline-accordion{display:block;width:100%;margin-right:0;}
    .fixed-btn-group{top:60px;right:5px;width:100%;justify-content:center;padding:5px;flex-direction:row;overflow-x:auto;white-space:nowrap;}
    .btn-group{flex-direction:row;}
    .macro-modal-content{max-width:90%;}
    .macro-modal-body{flex-direction:column;gap:10px;}
    .macro-modal-chart,.macro-modal-analysis{flex:none;width:100%;}
    .macro-modal-analysis{max-height:200px;}
    #notification {
    background-color: red !important;
    position: fixed;
    top: 10px;
    right: 10px;
    z-index: 1000;
}
}
        </style>
<style>
.btn-remove-meal {
  background-color: #28a745 !important;
  border-color: #28a745 !important;
  color: white;
}
.btn-remove-meal:hover {
  background-color: #218838 !important;
  border-color: #218838 !important;
}
</style>
<style>
    .meal-table th, .meal-table td {
        padding: 8px;
        text-align: center;
        vertical-align: middle;
    }
    .meal-table th.rule-column, .meal-table td.rule-column {
        width: 80px; /* Kural sütunu dar */
    }
    .meal-table th.conflict-column, .meal-table td.conflict-column {
        width: 80px; /* Çakışma sütunu dar */
    }
    .meal-table th.food-column, .meal-table td.food-column {
        width: auto; /* Yemek sütunu genişleyebilir */
        min-width: 200px; /* Minimum genişlik */
    }
    .meal-table span[title] {
        cursor: pointer; /* Fare üzerine geldiğinde el işareti */
    }
</style>
<script>

document.addEventListener('DOMContentLoaded', () => {
    const dynamicInputs = document.querySelectorAll('.dynamic-input');
    dynamicInputs.forEach(input => {
        input.addEventListener('input', function() {
            const minWidth = 200; // Piksel cinsinden minimum genişlik
            const maxWidth = this.parentElement.offsetWidth; // Sütun genişliği
            const textWidth = this.scrollWidth;
            this.style.width = `${Math.min(Math.max(textWidth, minWidth), maxWidth)}px`;
        });
    });
});
document.querySelectorAll('.dynamic-input').forEach(input => {
    input.addEventListener('input', function() {
        this.style.width = '100%';
        this.style.minWidth = '100%';
    });
});
function editFoodFromElement(el) {
  const name = el.getAttribute("data-name");
  if (name) editFood(name.trim());
}
</script></head>
<body>
<nav class="navbar navbar-expand-lg navbar-dark">
<div class="container-fluid">
<a class="navbar-brand" href="#">Beslenme Planlayıcı</a>
<button aria-controls="navbarNav" aria-expanded="false" aria-label="Menüyü Aç/Kapa" class="navbar-toggler" data-bs-target="#navbarNav" data-bs-toggle="collapse" type="button">
<span class="navbar-toggler-icon"></span>
</button>
<div class="collapse navbar-collapse" id="navbarNav">
<ul class="navbar-nav ms-auto">
<li class="nav-item">
<a class="nav-link" href="#" onclick="toggleSidebar()" title="Menüyü Aç/Kapa"><i class="bi bi-list"></i> Menü</a>
</li>
<li class="nav-item">
<a class="nav-link" href="#" onclick="switchMode('user')" title="Kullanıcı Moduna Geç"><i class="bi bi-person"></i> Kullanıcı</a>
</li>
<li class="nav-item">
<a class="nav-link" href="#" onclick="switchMode('admin')" title="Yönetici Moduna Geç"><i class="bi bi-gear"></i> Yönetici</a>
</li>
<li class="nav-item" id="dietModeSelector">
<label class="visually-hidden" for="dietModeSelect">Diyet Modu Seç</label>
<select class="form-select" id="dietModeSelect" onchange="updateDietMode(this.value)">
<option value="keto">Keto</option>
<option value="lowcarb">Low-Carb</option>
</select>
</li>
</ul>
</div>
</div>
</nav>
<div class="main-container">
<div class="sidebar" id="sidebar">
<div class="sidebar-header">
<h5>Kategoriler</h5>
<div class="mb-2">
<div class="input-group">
<label class="visually-hidden" for="searchFilterType">Arama Filtresi</label>
<select class="form-select" id="searchFilterType" style="width: 30%;">
<option value="name">Yemek Adı</option>
<option value="tags">Etiket</option>
<option value="role">Rol</option>
</select>
<label class="visually-hidden" for="searchFoodInput">Yemek Ara</label>
<input class="form-control" id="searchFoodInput" onkeyup="searchFood(this.value)" placeholder="Yemek Ara..." type="text"/>
</div>
</div>
<button class="btn btn-success w-100 fixed-btn" onclick="addSelectedFoods()" title="Seçilen Yemekleri Öğüne Ekle"><i class="bi bi-plus-circle"></i> Öğüne Ekle</button>
</div>
<div class="sidebar-content" id="sidebar-content">
<div class="mb-2" id="patientPreferences">
<div class="text-success" id="likedFoods"></div>
<div class="text-danger" id="dislikedFoods"></div>
</div>
<div class="accordion mb-2" id="categories"></div>
<button class="btn btn-primary w-100 mt-2" onclick="toggleAddFoodForm()" title="Yeni Yemek Ekle"><i class="bi bi-plus-circle"></i> Yeni Yemek Ekle</button>
<div class="mb-2" id="addFoodForm" style="display: none;">
<form id="addFoodFormInner" onsubmit="addNewFood(event)">
<div class="mb-1">
<label class="form-label" for="foodCategory">Kategori</label>
<select class="form-select" id="foodCategory" required="">
<option value="">Kategori Seçin</option>
</select>
</div>
<div class="mb-1">
<label class="form-label" for="foodName">Yemek Adı</label>
<input autocomplete="off" class="form-control" id="foodName" placeholder="Yemek Adı" required="" type="text"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodCalories">Kalori</label>
<input autocomplete="off" class="form-control" id="foodCalories" min="0" placeholder="Kalori" required="" step="0.1" type="number"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodProtein">Protein (g)</label>
<input autocomplete="off" class="form-control" id="foodProtein" min="0" placeholder="Protein (g)" required="" step="0.1" type="number"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodCarbs">Karb. (g)</label>
<input autocomplete="off" class="form-control" id="foodCarbs" min="0" placeholder="Karbonhidrat (g)" required="" step="0.1" type="number"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodFat">Yağ (g)</label>
<input autocomplete="off" class="form-control" id="foodFat" min="0" placeholder="Yağ (g)" required="" step="0.1" type="number"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodMaxQuantity">Maks. Katsayı</label>
<input autocomplete="off" class="form-control" id="foodMaxQuantity" max="2" min="1" placeholder="Maks. Katsayı" step="0.5" type="number" value="1"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodMinQuantity">Min. Katsayı</label>
<input autocomplete="off" class="form-control" id="foodMinQuantity" max="2" min="0" placeholder="Min. Katsayı" step="0.5" type="number" value="0.5"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodStep">Adım Değeri</label>
<input autocomplete="off" class="form-control" id="foodStep" max="1" min="0.1" placeholder="Adım (örn: 0.5)" step="0.1" type="number" value="0.5"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodTags">Etiketler</label>
<input autocomplete="off" class="form-control" id="foodTags" placeholder="Etiketler (virgülle ayırın)" type="text"/>
</div>
<div class="mb-1">
<label class="form-label" for="editFoodSeason">Mevsim</label>
<select class="form-select" id="editFoodSeason">
<option value="4 mevsim">4 Mevsim</option>
<option value="kış">Kış</option>
<option value="yaz">Yaz</option>
<option value="ilkbahar">İlkbahar</option>
<option value="sonbahar">Sonbahar</option>
</select>
</div>
<div class="mb-1">
<label class="form-label" for="editFoodPortionFixed">Porsiyon Sabit mi?</label>
<input id="editFoodPortionFixed" name="editFoodPortionFixed" type="checkbox"/>
</div>
<div class="mb-1">
<label class="form-label" for="editFoodMultiplier">Çarpan</label>
<input autocomplete="off" class="form-control" id="editFoodMultiplier" min="0.1" placeholder="Çarpan (örn: 1)" step="0.1" type="number" value="1"/>
</div>
<div class="mb-1">
<label class="form-label" for="foodSeason">Mevsim</label>
<select class="form-select" id="foodSeason">
<option value="4 mevsim">4 Mevsim</option>
<option value="kış">Kış</option>
<option value="yaz">Yaz</option>
<option value="ilkbahar">İlkbahar</option>
<option value="sonbahar">Sonbahar</option>
</select>
</div>
<div class="mb-1">
<label class="form-label">Diyet Türü</label>
<div>
<input id="foodKeto" name="foodKeto" type="checkbox"/> <label for="foodKeto">Keto</label>
<input id="foodLowCarb" name="foodLowCarb" type="checkbox"/> <label for="foodLowCarb">Low-Carb</label>
</div>
<div class="mb-1">
<label class="form-label">Dolgu Türü</label>
<div>
<input id="foodFillerLunch" name="foodFillerLunch" type="checkbox"/> <label for="foodFillerLunch">Dolgu Öğlen</label>
<input id="foodFillerDinner" name="foodFillerDinner" type="checkbox"/> <label for="foodFillerDinner">Dolgu Akşam</label>
</div>
</div>
</div>
<button class="btn btn-success w-100" title="Yemeği Ekle" type="submit">Ekle</button>
<button class="btn btn-secondary w-100 mt-1" onclick="toggleAddFoodForm()" title="İptal Et" type="button">İptal</button>
</form>
</div>
<div class="accordion mb-2 mt-2" id="sidebarAccordion">
<!-- Kurallar Accordion -->
<div class="accordion-item">
<h2 class="accordion-header" id="rulesHeading">
<button aria-controls="rulesCollapse" aria-expanded="false" class="accordion-button collapsed fixed-btn" data-bs-target="#rulesCollapse" data-bs-toggle="collapse" type="button">
                                Kurallar
                            </button>
</h2>
<div aria-labelledby="rulesHeading" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion" id="rulesCollapse">
<div class="accordion-body">
<div class="mb-2" id="rulesList"></div>
<!-- Kural Düzenleme Formu -->
<div id="editRuleForm" style="display: none;">
<form onsubmit="saveEditedRule(event)">
<input id="editRuleIndex" type="hidden"/>
<div class="mb-2">
<label class="form-label" for="editRuleType">Kural Türü</label>
<select class="form-select" id="editRuleType" onchange="updateRuleForm(true)">
<option value="frequency">Sıklık</option>
<option value="exclude">Hariç Tut</option>
<option value="include">Ekle</option>
<option value="minCount">Min. Sayı</option>
<option value="maxCount">Maks. Sayı</option>
<option value="pairWith">Birlikte Ekle</option>
<option value="avoidPair">Birlikte Ekleme</option>
<option value="singleItem">Tek Başına</option>
<option value="maxRoleCount">Maks. Rol Sayısı</option>
</select>
</div>
<div id="editRuleFormDetails">
<div class="mb-2">
<label>Kriterler:</label>
<div>
<input id="editRuleNameCheck" type="checkbox"/> <label for="editRuleNameCheck">İsim</label>
<input class="form-control" id="editRuleName" placeholder="örn: Balık" type="text"/>
<input id="editRuleTagsCheck" type="checkbox"/> <label for="editRuleTagsCheck">Tag</label>
<input class="form-control" id="editRuleTags" placeholder="örn: balık, keto" type="text"/>
<input id="editRuleCategoryCheck" type="checkbox"/> <label for="editRuleCategoryCheck">Kategori</label>
<select class="form-select" id="editRuleCategory">
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
<option value="SALATALAR">SALATALAR</option>
<option value="ÇORBALAR">ÇORBALAR</option>
<option value="EKMEKLER">EKMEKLER</option>
<option value="TATLILAR">TATLILAR</option>
<option value="MEYVELER">MEYVELER</option>
<option value="KURUYEMİŞLER">KURUYEMİŞLER</option>
</select>
<input id="editRuleMealTypeCheck" type="checkbox"/> <label for="editRuleMealTypeCheck">Öğün</label>
<select class="form-select" id="editRuleMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
</div>
<div class="mb-2" id="editFrequencyInput" style="display: none;">
<label class="form-label" for="editRuleFrequency">Haftada Kaç Kez</label>
<input class="form-control" id="editRuleFrequency" max="21" min="0" type="number" value="1"/>
</div>
<div class="mb-2" id="editCountInput" style="display: none;">
<label class="form-label" for="editRuleCount">Sayı</label>
<input class="form-control" id="editRuleCount" min="1" type="number" value="1"/>
</div>
<div class="mb-2" id="editPairInput" style="display: none;">
<label class="form-label" for="editRulePair">Eşleşecek Yemek</label>
<input class="form-control" id="editRulePair" placeholder="örn: Salata" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="editRuleScope">Kapsam</label>
<select class="form-select" id="editRuleScope">
<option value="daily">Günlük</option>
<option value="weekly">Haftalık</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="editRuleWeekRange">Hafta Aralığı (örn: 1-2)</label>
<input class="form-control" id="editRuleWeekRange" placeholder="örn: 1-2 veya 3" type="text"/>
</div>
</div>
<button class="btn btn-success w-100" title="Kaydet" type="submit">Kaydet</button>
<button class="btn btn-secondary w-100 mt-1" onclick="cancelEditRule()" title="İptal" type="button">İptal</button>
</form>
</div>
<!-- Yeni Kural Ekleme -->
<div class="mb-2">
<label class="form-label" for="ruleType">Kural Türü</label>
<select class="form-select" id="ruleType" onchange="updateRuleForm()">
<option value="frequency">Sıklık Kuralı</option>
<option value="exclude">Hariç Tut</option>
<option value="pairWith">Birlikte Olsun</option>
<option value="avoidPair">Birlikte Olmasın</option>
<option value="singleItem">Tek Başına</option>
<option value="noDuplicates">Tekrarlama</option>
<option value="dependOn">Bağımlı Olsun</option>
<option value="categoryLock">Kategori Kilidi</option>
<option value="compatibility">Uyumluluk Kuralı</option>
<option value="maxRoleCount">Maks. Rol Sayısı</option> <!-- Yeni eklenen -->
</select>
</div>
<div class="mb-2" id="ruleForm">
<div id="defaultRuleForm">
<div class="mb-2">
<label>Kriterler:</label>
<div>
<input id="ruleNameCheck" type="checkbox"/> <label for="ruleNameCheck">İsim</label>
<input class="form-control" id="ruleName" placeholder="örn: Balık" type="text"/>
<input id="ruleTagsCheck" type="checkbox"/> <label for="ruleTagsCheck">Tag</label>
<input class="form-control" id="ruleTags" placeholder="örn: balık, keto" type="text"/>
<input id="ruleCategoryCheck" type="checkbox"/> <label for="ruleCategoryCheck">Kategori</label>
<select class="form-select" id="ruleCategory">
<option value="KAHVALTI">KAHVALTI</option>
<option value="ÖĞLEN">ÖĞLEN</option>
<option value="AKŞAM">AKŞAM</option>
<option value="SALATALAR">SALATALAR</option>
<option value="ÇORBALAR">ÇORBALAR</option>
<option value="EKMEKLER">EKMEKLER</option>
<option value="TATLILAR">TATLILAR</option>
<option value="MEYVELER">MEYVELER</option>
<option value="KURUYEMİŞLER">KURUYEMİŞLER</option>
</select>
<input id="ruleRoleCheck" type="checkbox"/> <label for="ruleRoleCheck">Rol</label>
<select class="form-select" id="ruleRole">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="drink">İçecek</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
<input id="ruleMealTypeCheck" type="checkbox"/> <label for="ruleMealTypeCheck">Öğün</label>
<select class="form-select" id="ruleMealType" multiple="">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
</div>
<div class="mb-2" id="countInput" style="display: none;">
<label class="form-label" for="ruleCount">Sayı</label>
<input class="form-control" id="ruleCount" min="1" type="number" value="1"/>
</div>
<div class="mb-2">
<label class="form-label" for="ruleScope">Kapsam</label>
<select class="form-select" id="ruleScope">
<option value="daily">Günlük</option>
<option value="weekly">Haftalık</option>
<option value="meal">Öğün</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="ruleWeekRange">Hafta Aralığı (örn: 1-2, boş bırakılırsa her hafta)</label>
<input class="form-control" id="ruleWeekRange" placeholder="örn: 1-2 veya 3" type="text"/>
</div>
<button class="btn btn-success w-100" onclick="handleRuleSave()" title="Kural Ekle">Kural Ekle</button>
<button class="btn btn-secondary w-100 mt-1" onclick="hideAllForms()" title="İptal">İptal</button>
</div>
<!-- Diğer Kural Formları -->
<div id="frequencyRuleForm" style="display: none;">
<h5>Sıklık Kuralı</h5>
<div class="form-group mb-2">
<label>Kriterler:</label>
<div>
<input id="freqNameCheck" type="checkbox"/> İsim: <input class="form-control" disabled="" id="freqName" placeholder="örn: Balık" type="text"/>
<input id="freqTagCheck" type="checkbox"/> Tag: <input class="form-control" disabled="" id="freqTag" placeholder="örn: balık, keto" type="text"/>
<input id="freqRoleCheck" type="checkbox"/> Rol: 
                                                <select class="form-select" disabled="" id="freqRole">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="drink">İçecek</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
<input id="freqCatCheck" type="checkbox"/> Kategori: 
                                                <select class="form-select" disabled="" id="freqCat">
<option value="">Seç</option>
</select>
</div>
</div>
<div class="form-group mb-2">
<label>Sıklık Türü:</label>
<select class="form-select" id="freqType">
<option value="exact">Net Sayı</option>
<option value="min">En Az</option>
<option value="max">En Fazla</option>
</select>
</div>
<div class="form-group mb-2">
<label>Sayı:</label>
<input class="form-control" id="freqCount" min="1" type="number" value="1"/>
</div>
<div class="form-group mb-2">
<label>Kapsam:</label>
<select class="form-select" id="freqScope">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
<option value="week">Hafta</option>
</select>
<select class="form-select" id="freqMeal" style="display: none;">
<option value="breakfast">Sabah</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="form-group mb-2">
<label>Hafta Aralığı (örn: 1-2, boş bırakılırsa her hafta):</label>
<input class="form-control" id="freqWeekRange" placeholder="örn: 1-2 veya 3" type="text"/>
</div>
<button class="btn btn-success" onclick="handleRuleSave()" type="button">Kuralı Kaydet</button>
</div>
<div id="dependOnRuleForm" style="display: none;">
<h5>Bağımlı Olsun Kuralı</h5>
<div class="form-group mb-2">
<label>Bağımlı Yemek:</label>
<input class="form-control" id="dependOnFood" placeholder="örn: Mayonez" type="text"/>
</div>
<div class="form-group mb-2">
<label>Bağımlı Olduğu Yemek:</label>
<input class="form-control" id="dependOnRequiredFood" placeholder="örn: Köfte" type="text"/>
</div>
<div class="form-group mb-2">
<label>Kapsam:</label>
<select class="form-select" id="dependOnScope">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
</select>
</div>
<button class="btn btn-success w-100" onclick="handleRuleSave()" title="Kuralı Kaydet" type="button">Kuralı Kaydet</button>
</div>
<div id="categoryLockRuleForm" style="display: none;">
<h5>Kategori Kilidi Kuralı</h5>
<div class="form-group mb-2">
<label>Kilitlenecek Kategori:</label>
<select class="form-select" id="categoryLockCategory">
<option value="EKMEKLER">EKMEKLER</option>
</select>
</div>
<div class="form-group mb-2">
<label>Kapsam:</label>
<select class="form-select" id="categoryLockScope">
<option value="week">Hafta</option>
</select>
</div>
</div>
<div id="pairRuleForm" style="display: none;">
<h5>Birliktelik Kuralı</h5>
<div class="form-group mb-2">
<label>Birinci Kelime:</label>
<div>
<input id="pair1NameCheck" type="checkbox"/> İsim: <input class="form-control" disabled="" id="pair1Name" placeholder="örn: Balık" type="text"/>
<input id="pair1TagCheck" type="checkbox"/> Tag: <input class="form-control" disabled="" id="pair1Tag" placeholder="örn: balık, keto" type="text"/>
<input id="pair1RoleCheck" type="checkbox"/> Rol: 
                                                <select class="form-select" disabled="" id="pair1Role">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
</select>
<input id="pair1CatCheck" type="checkbox"/> Kategori: 
                                                <select class="form-select" disabled="" id="pair1Cat">
<option value="">Seç</option>
<option value="KAHVALTI">Kahvaltı</option>
<option value="ÖĞLEN">Öğlen</option>
<option value="AKŞAM">Akşam</option>
</select>
</div>
</div>
<div class="form-group mb-2">
<label>İkinci Kelime:</label>
<div>
<input id="pair2NameCheck" type="checkbox"/> İsim: <input class="form-control" disabled="" id="pair2Name" placeholder="örn: Salata" type="text"/>
<input id="pair2TagCheck" type="checkbox"/> Tag: <input class="form-control" disabled="" id="pair2Tag" placeholder="örn: salata, keto" type="text"/>
<input id="pair2RoleCheck" type="checkbox"/> Rol: 
                                                <select class="form-select" disabled="" id="pair2Role">
<option value="">Seç</option>
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
</select>
<input id="pair2CatCheck" type="checkbox"/> Kategori: 
                                                <select class="form-select" disabled="" id="pair2Cat">
<option value="">Seç</option>
<option value="KAHVALTI">Kahvaltı</option>
<option value="ÖĞLEN">Öğlen</option>
<option value="AKŞAM">Akşam</option>
</select>
</div>
</div>
<div class="form-group mb-2">
<label>Birliktelik Türü:</label>
<select class="form-select" id="pairType">
<option value="together">Birlikte Olsun</option>
<option value="apart">Birlikte Olmasın</option>
</select>
</div>
<div class="form-group mb-2">
<label>Bağlaç:</label>
<select class="form-select" id="pairConjunction">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<div class="form-group mb-2">
<label>Yön:</label>
<select class="form-select" id="pairDirection">
<option value="bidirectional">Çift Yönlü</option>
<option value="unidirectional">Tek Yönlü</option>
</select>
</div>
<div class="form-group mb-2">
<label>Kapsam:</label>
<select class="form-select" id="pairScope">
<option value="meal">Öğün</option>
<option value="day">Gün</option>
<option value="week">Hafta</option>
</select>
<select class="form-select" id="pairMeal" style="display: none;">
<option value="breakfast">Sabah</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="form-group mb-2">
<label>Hafta Aralığı (örn: 1-2, boş bırakılırsa her hafta):</label>
<input class="form-control" id="pairWeekRange" placeholder="örn: 1-2 veya 3" type="text"/>
</div>
</div>
<div id="compatibilityRuleForm" style="display: none;">
<h5>Uyumluluk Kuralı</h5>
<div class="form-group mb-2">
<label class="form-label" for="compatKeyword1">Kelime 1</label>
<input class="form-control" id="compatKeyword1" placeholder="örn: balık" type="text"/>
</div>
<div class="form-group mb-2">
<label class="form-label" for="compatKeyword2">Kelime 2 (Virgülle ayırın)</label>
<input class="form-control" id="compatKeyword2" placeholder="örn: süt,yoğurt" type="text"/>
</div>
<div class="form-group mb-2">
<label class="form-label" for="compatDegree">Derece (-5: Çok Uyumsuz, +5: Çok Uyumlu)</label>
<input class="form-control" id="compatDegree" max="5" min="-5" type="number" value="0"/>
</div>
<div class="form-group mb-2">
<label class="form-label" for="compatConjunction">Bağlaç</label>
<select class="form-select" id="compatConjunction">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<button class="btn btn-success w-100" onclick="handleRuleSave()" title="Kuralı Kaydet" type="button">Kuralı Kaydet</button>
</div>
</div>
<!-- Şablon Yönetimi -->
<div class="mb-2">
<label class="form-label" for="templateName">Şablon Adı</label>
<input class="form-control" id="templateName" placeholder="Şablon Adı" type="text"/>
</div>
<button class="btn btn-success w-100 mb-1" onclick="saveRuleTemplate()" title="Şablon Kaydet">Şablon Kaydet</button>
<label class="form-label" for="templateSelect">Şablon Seç</label>
<select class="form-select mb-1" id="templateSelect">
<option value="">Şablon Yükle</option>
</select>
<button class="btn btn-primary w-100 mb-1" onclick="loadRuleTemplate()" title="Şablon Yükle">Şablon Yükle</button>
<button class="btn btn-danger w-100" onclick="deleteRuleTemplate()" title="Şablon Sil">Şablon Sil</button>
</div>
</div>
</div>
<!-- Uyumluluk Kuralları Accordion -->
<div class="accordion-item">
<h2 class="accordion-header" id="compatibilityHeading">
<button aria-controls="compatibilityCollapse" aria-expanded="false" class="accordion-button collapsed" data-bs-target="#compatibilityCollapse" data-bs-toggle="collapse" type="button">
                                Uyumluluk Kuralları
                            </button>
</h2>
<div aria-labelledby="compatibilityHeading" class="accordion-collapse collapse" data-bs-parent="#sidebarAccordion" id="compatibilityCollapse">
<div class="accordion-body" style="max-height: 300px; overflow-y: auto;">
<div class="mb-2" id="compatibilityList"></div>
<div class="mb-2">
<label class="form-label" for="compatKeyword1">Kelime 1</label>
<input class="form-control" id="compatKeyword1" placeholder="örn: balık" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatKeyword2">Kelime 2 (Virgülle ayırın)</label>
<input class="form-control" id="compatKeyword2" placeholder="örn: süt,yoğurt" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatDegree">Derece (-5: Çok Uyumsuz, +5: Çok Uyumlu)</label>
<input class="form-control" id="compatDegree" max="5" min="-5" type="number" value="0"/>
</div>
<div class="mb-2">
<label class="form-label" for="compatConjunction">Bağlaç</label>
<select class="form-select" id="compatConjunction">
<option value="or">Veya</option>
<option value="and">Ve</option>
</select>
</div>
<button class="btn btn-primary w-100" onclick="addCompatibilityRule()" title="Uyumluluk Ekle">Uyumluluk Ekle</button>
<button class="btn btn-primary w-100 mt-2" onclick="importFoodList()" title="Liste Al"><i class="bi bi-upload"></i> Liste Al</button>
<button class="btn btn-success w-100 mt-2" onclick="exportFoodList()" title="Son Listeyi Ver"><i class="bi bi-download"></i> Son Listeyi Ver</button>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="resizer" id="resizer"></div>
<div class="main-content" id="mainContent">
<div class="alert alert-success" id="notification" style="display: none;"></div>
<!-- Tek bir adminPanel div'i -->
<div class="p-3" id="adminPanel" style="display: block;">
<!-- Hasta Seçimi Bölümü -->
<div class="d-flex justify-content-between align-items-center mb-2">
<div class="d-flex align-items-center gap-2 flex-wrap">
<label class="visually-hidden" for="patientSelect">Hasta Seç</label>
<select class="form-select w-auto" id="patientSelect" onchange="handlePatientChange()">
<option value="">Hasta Seç</option>
</select>
<label class="visually-hidden" for="likedFoodsDisplay">Sevdiği Yemekler</label>
<input class="form-control w-auto" id="likedFoodsDisplay" onblur="updatePatientPreferences()" placeholder="Sevdiği" type="text"/>
<label class="visually-hidden" for="dislikedFoodsDisplay">Sevmediği Yemekler</label>
<input class="form-control w-auto" id="dislikedFoodsDisplay" onblur="updatePatientPreferences()" placeholder="Sevmediği" type="text"/>
<button class="btn btn-primary" onclick="addPatient()" title="Hasta Ekle"><i class="bi bi-person-plus"></i></button>
<button class="btn btn-warning" onclick="editPatient()" title="Hasta Düzenle"><i class="bi bi-pencil"></i></button>
<button class="btn btn-danger" onclick="deletePatient()" title="Hasta Sil"><i class="bi bi-trash"></i></button>

<div class="modal fade" id="editPatientModal" tabindex="-1" aria-labelledby="editPatientModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="editPatientModalLabel">Hastayı Düzenle</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="editPatientName" class="form-label">Hasta Adı</label>
                    <input type="text" class="form-control" id="editPatientName">
                </div>
                <div class="mb-3">
                    <label for="editPatientWeight" class="form-label">Kilo (kg)</label>
                    <input type="number" class="form-control" id="editPatientWeight">
                </div>
                <div class="mb-3">
                    <label for="editPatientActivity" class="form-label">Aktivite Seviyesi (1-5)</label>
                    <input type="number" class="form-control" id="editPatientActivity" min="1" max="5">
                </div>
                <div class="mb-3">
                    <label for="editLikedFoods" class="form-label">Sevdiği Yemekler (virgülle ayırın)</label>
                    <input type="text" class="form-control" id="editLikedFoods">
                </div>
                <div class="mb-3">
                    <label for="editDislikedFoods" class="form-label">Sevmediği Yemekler (virgülle ayırın)</label>
                    <input type="text" class="form-control" id="editDislikedFoods">
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Kapat</button>
                <button type="button" class="btn btn-primary" onclick="saveEditedPatient()">Kaydet</button>
            </div>
        </div>
    </div>
</div>

</div>
<!-- GitHub Token Giriş Alanı ve Buton -->
<div class="mb-3">
<label class="form-label" for="githubToken">GitHub Token</label>
<input class="form-control" id="githubToken" placeholder="GitHub Personal Access Token girin" required="" type="password"/>
<button class="btn btn-primary mt-2 w-100" onclick="updateGitHubData()" title="GitHub'a Gönder">
<i class="bi bi-upload"></i> GitHub'a Gönder
                            </button>
</div>
</div>
<div class="d-flex gap-2 mb-2">
<div class="accordion inline-accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="settingsHeading">
<button aria-controls="settingsCollapse" aria-expanded="false" class="accordion-button green collapsed" data-bs-target="#settingsCollapse" data-bs-toggle="collapse" type="button">
                                        Ayarlar
                                    </button>
</h2>
<div aria-labelledby="settingsHeading" class="accordion-collapse collapse" id="settingsCollapse">
<div class="accordion-body">
<div class="settings-panel">
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="minItemsPerMeal">Min. Yemek/Öğün</label>
<input class="form-control" id="minItemsPerMeal" max="10" min="1" type="number" value="2"/>
</div>
<div class="col-6">
<label class="form-label" for="maxItemsPerMeal">Maks. Yemek/Öğün</label>
<input class="form-control" id="maxItemsPerMeal" max="10" min="1" type="number" value="4"/>
</div>
</div>
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="lunchCalorieRatio">Öğle Kalori (%)</label>
<input class="form-control" id="lunchCalorieRatio" max="100" min="0" type="number" value="40"/>
</div>
<div class="col-6">
<label class="form-label" for="dinnerCalorieRatio">Akşam Kalori (%)</label>
<input class="form-control" id="dinnerCalorieRatio" max="100" min="0" type="number" value="50"/>
</div>
</div>
<div class="row mb-2">
<div class="col-6">
<label class="form-label" for="calorieFlexibility">Kalori Esneklik (±%)</label>
<input class="form-control" id="calorieFlexibility" max="20" min="0" type="number" value="10"/>
</div>
<div class="col-6">
<label class="form-label" for="varietyScore">Min. Çeşitlilik Skoru</label>
<input class="form-control" id="varietyScore" max="1" min="0" step="0.1" type="number" value="0.7"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="carbMultiplier">Karb Çarpanı</label>
<input class="form-control" id="carbMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="0.3"/>
</div>
<div class="col-4">
<label class="form-label" for="proteinMultiplier">Prot. Çarpanı</label>
<input class="form-control" id="proteinMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="0.8"/>
</div>
<div class="col-4">
<label class="form-label" for="fatMultiplier">Yağ Çarpanı</label>
<input class="form-control" id="fatMultiplier" min="0" onchange="calculateMacros()" step="0.1" type="number" value="1.2"/>
</div>
</div>
<div class="mb-2">
<label class="form-label">Ekleme Kriteri</label>
<div>
<input checked="" id="useName" type="checkbox"/> <label for="useName">İsim</label>
<input checked="" id="useTags" type="checkbox"/> <label for="useTags">Etiket</label>
</div>
</div>
<div class="mb-2">
<label class="form-label">Öğün Tercihleri</label>
<div class="mb-1">
<strong>Kahvaltı:</strong>
<input checked="" id="prefBreakfastDrink" type="checkbox"/> <label for="prefBreakfastDrink">İçecek</label>
</div>
<div class="mb-1">
<strong>Öğle:</strong>
<input checked="" id="prefLunchEgg" type="checkbox"/> <label for="prefLunchEgg">Yumurta</label>
<input checked="" id="prefLunchSoup" type="checkbox"/> <label for="prefLunchSoup">Çorba</label>
</div>
<div class="mb-1">
<strong>Akşam Ekstraları:</strong>
<div>
<label for="prefDinnerNuts">Kuruyemiş (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerNuts" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerSoup">Çorba (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerSoup" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerDessert">Tatlı (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerDessert" max="100" min="0" type="number" value="50"/>
</div>
<div>
<label for="prefDinnerFruit">Meyve (%):</label>
<input class="form-control w-auto d-inline" id="prefDinnerFruit" max="100" min="0" type="number" value="50"/>
</div>
</div>
</div>
<!-- Kural açıklamasını göstermek için -->
<div id="ruleTextElement"></div>
<!-- Kural ekleme/düzenleme butonu -->
<button id="addRuleButton" onclick="handleRuleSave()">Kural Ekle</button>
<div class="settings-panel">
<h6>Öğün Bazlı Limitler</h6>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="breakfastMin">Kahvaltı Min</label>
<input class="form-control" id="breakfastMin" max="1" min="1" type="number" value="1"/>
</div>
<div class="col-4">
<label class="form-label" for="breakfastMax">Kahvaltı Max</label>
<input class="form-control" id="breakfastMax" max="1" min="1" type="number" value="1"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="lunchMin">Öğle Min</label>
<input class="form-control" id="lunchMin" min="0" type="number" value="2"/>
</div>
<div class="settings-panel">
<h6>Öğün Bazlı Sabit Yemekler</h6>
<div class="mb-2">
<label for="fixedBreakfastMeal">Kahvaltı Sabit Yemek:</label>
<select class="form-select" id="fixedBreakfastMeal">
<option value="">Yok</option>
<option selected="" value="Kurşun Geçirmez Kahve">Kurşun Geçirmez Kahve</option>
</select>
</div>
<div class="mb-2">
<label for="fixedLunchMeal">Öğle Sabit Yemek:</label>
<select class="form-select" id="fixedLunchMeal">
<option value="">Yok</option>
</select>
</div>
<div class="mb-2">
<label for="fixedDinnerMeal">Akşam Sabit Yemek:</label>
<select class="form-select" id="fixedDinnerMeal">
<option value="">Yok</option>
</select>
</div>
</div>
<div class="col-4">
<label class="form-label" for="lunchMax">Öğle Max</label>
<input class="form-control" id="lunchMax" min="0" type="number" value="4"/>
</div>
</div>
<div class="row mb-2">
<div class="col-4">
<label class="form-label" for="dinnerMin">Akşam Min</label>
<input class="form-control" id="dinnerMin" min="0" type="number" value="2"/>
</div>
<div class="col-4">
<label class="form-label" for="dinnerMax">Akşam Max</label>
<input class="form-control" id="dinnerMax" min="0" type="number" value="4"/>
</div>
</div>
</div>
<div class="mb-2">
<label class="form-label" for="settingsTemplate">Ayar Şablonu Adı</label>
<input class="form-control" id="settingsTemplate" placeholder="Şablon Adı" type="text"/>
</div>
<button class="btn btn-success w-100 mb-1" onclick="saveSettingsTemplate(true)" title="Ayarları Varsayılan Kaydet">Varsayılan Kaydet</button>
<button class="btn btn-success w-100 mb-1" onclick="saveSettingsTemplate(false)" title="Ayarları Hasta İçin Kaydet">Hasta İçin Kaydet</button>
<label class="form-label" for="settingsTemplateSelect">Ayar Şablonu Seç</label>
<select class="form-select mb-1" id="settingsTemplateSelect">
<option value="">Ayar Yükle</option>
</select>
<button class="btn btn-primary w-100" onclick="loadSettingsTemplate()" title="Ayarları Yükle">Yükle</button>
<button class="btn btn-primary w-100 mt-2" onclick="applySettings()" title="Ayarları Uygula">Ayarları Uygula</button>
</div>
</div>
</div>
</div>
</div>
<div class="meal-plan-container" id="mealPlanArea"></div>
<div aria-labelledby="autoPlanningHeading" class="accordion-collapse collapse" id="autoPlanningCollapse">
<div class="accordion-body">
<label>Makro Hedeflere Uyun (%): <input id="macroPriority" max="100" min="0" type="range" value="80"/></label><br/>
<label>Şablon Önceliği (%): <input id="templatePriority" max="100" min="0" type="range" value="60"/></label><br/>
<label>Kural Önceliği (%): <input id="rulePriority" max="100" min="0" type="range" value="100"/></label><br/>
<label>Uyumluluk Önceliği (%): <input id="compatibilityPriority" max="100" min="0" type="range" value="70"/></label><br/>
<label>Yönetim Önceliği (%): <input id="managementPriority" max="100" min="0" type="range" value="50"/></label><br/>
<label>Makro Toleransı (±%): <input id="macroTolerance" max="20" min="0" type="range" value="10"/></label><br/>
<label>Katsayıları Optimize Et: <input checked="" id="optimizeCoefficients" type="checkbox"/></label><br/>
<label>Kahvaltı Önceliği: 
                                <select class="form-select w-auto d-inline" id="breakfastPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<label>Öğle Önceliği: 
                                <select class="form-select w-auto d-inline" id="lunchPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<label>Akşam Önceliği: 
                                <select class="form-select w-auto d-inline" id="dinnerPriority">
<option value="high">Yüksek</option>
<option selected="" value="medium">Orta</option>
<option value="low">Düşük</option>
</select>
</label><br/>
<button class="btn btn-primary w-100 mb-1" onclick="generateFastPlan()" title="Hızlı Planla"><i class="bi bi-lightning"></i> Hızlı Planla</button>
<button class="btn btn-success w-100 mb-1" onclick="applyAllRules()" title="Tüm Kuralları Uygula"><i class="bi bi-check2-all"></i> Tüm Kuralları Uygula</button>
</div>
</div>
<div class="accordion inline-accordion">
<div class="accordion-item">
<h2 class="accordion-header" id="templatesHeading">
<button aria-controls="templatesCollapse" aria-expanded="false" class="accordion-button green collapsed" data-bs-target="#templatesCollapse" data-bs-toggle="collapse" type="button">
                                    Öğün Şablonları
                                </button>
</h2>
<div aria-labelledby="templatesHeading" class="accordion-collapse collapse" id="templatesCollapse">
<div class="accordion-body">
<!-- Tek bir yükleme alanı -->
<div class="input-group mb-3">
<input accept=".xlsx,.xls,.txt" id="importFile" onchange="importFromFile(event)" style="display: none;" type="file"/>
<button class="btn btn-success w-100" onclick="document.getElementById('importFile').click()">
<i class="bi bi-upload"></i> Dosyadan Şablon Ekle (Excel/TXT)
    </button>
</div>
<div class="mb-2" id="mealTemplatesList"></div>
<div class="mb-2" id="editTemplateForm" style="display: none;">
<form onsubmit="saveEditedTemplate(event)">
<input id="editTemplateIndex" type="hidden"/>
<div class="mb-2">
<label class="form-label" for="editTemplateName">Şablon Adı</label>
<input class="form-control" id="editTemplateName" type="text">
</input></div>
<div class="mb-2">
<label class="form-label" for="editTemplateMealType">Öğün Türü</label>
<select class="form-select" id="editTemplateMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="editTemplateFrequency">Haftada Kaç Gün</label>
<input class="form-control" id="editTemplateFrequency" max="7" min="1" type="number"/>
</div>
<div class="mb-2" id="editTemplateItems"></div>
<button class="btn btn-success w-100" title="Kaydet" type="submit">Kaydet</button>
<button class="btn btn-secondary w-100 mt-1" onclick="cancelEditTemplate()" title="İptal" type="button">İptal</button>
</form>
</div>
<div class="mb-2">
<label class="form-label" for="templateMealType">Öğün Türü</label>
<select class="form-select" id="templateMealType">
<option value="breakfast">Kahvaltı</option>
<option value="lunch">Öğle</option>
<option value="dinner">Akşam</option>
</select>
</div>
<div class="mb-2">
<label class="form-label" for="templateFrequency">Haftada Kaç Gün</label>
<input class="form-control" id="templateFrequency" max="7" min="1" type="number" value="1"/>
</div>
<div class="mb-2" id="templateItems">
<div class="row mb-1">
<div class="col-4">
<label class="form-label" for="templateItem1Keyword">Etiket</label>
<input class="form-control" id="templateItem1Keyword" placeholder="örn: yumurta, omlet" type="text"/>
</div>
<div class="col-4">
<label class="form-label" for="templateItem1Role">Rol</label>
<select class="form-select" id="templateItem1Role">
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="drink">İçecek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
<div class="col-4">
<label class="form-label" for="templateItem1Quantity">Sayı</label>
<input class="form-control" id="templateItem1Quantity" min="1" type="number" value="1"/>
</div>
</div>
</div>
<html>
<head>
<title>Excel Yükleme</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<style>
.btn-remove-meal {
  background-color: #28a745 !important;
  border-color: #28a745 !important;
  color: white;
}
.btn-remove-meal:hover {
  background-color: #218838 !important;
  border-color: #218838 !important;
}
</style>
</head>
<body>
<!-- Yukarıdaki JS kodunu buraya kaydedin -->
<!-- SheetJS Kütüphanesi -->
<div style="margin-top: 10px;">
<label><strong>Dosyadan Yemekleri Yükle (Excel/TXT):</strong></label><br/>
<input accept=".xlsx,.xls,.txt" onchange="importFromFile(event)" type="file"/>
</div>
<script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
<script>

let currentMacros = {
    calories: 1064, // Varsayılan değer
    carbs: 21,     // Varsayılan keto için
    protein: 56,   // Varsayılan
    fat: 83       // Varsayılan
};
function handleExcelUpload(event) {
    const file = event.target.files[0];
    const reader = new FileReader();

    reader.onload = function(e) {
        const data = new Uint8Array(e.target.result);
        const workbook = XLSX.read(data, {type: 'array'});

        // YASAK KELİMELER (tam temizlik)
        const forbiddenWords = ['pazartesi','salı','çarşamba','perşembe','cuma','cumartesi','pazar',
                                'sabah','malzeme','kart','pdf','burayı','öneri','vermeyin','not:','gün','listesi'];

        let extractedFoods = [];
        let currentCategory = null;

        workbook.SheetNames.forEach(sheetName => {
            if (sheetName.toLowerCase().includes("pdf")) return;

            const sheet = workbook.Sheets[sheetName];
            const excelData = XLSX.utils.sheet_to_json(sheet, {header: 1});
            let aktifOguneGir = false;

            excelData.forEach(row => {
                const raw = (row[0] || "").toString().toLowerCase().trim();

                // Öğle veya Akşam gelmeden hiçbir şey alma
                if (raw.includes("öğle")) {
                    currentCategory = "ÖĞLEN";
                    aktifOguneGir = true;
                    return;
                }
                if (raw.includes("akşam")) {
                    currentCategory = "AKŞAM";
                    aktifOguneGir = true;
                    return;
                }

                if (!aktifOguneGir || !currentCategory) return;

                const name = (row[0] || "").toString().trim();
                const nameLower = name.toLowerCase();

                // Yasak kelime içeriyorsa atla
                if (forbiddenWords.some(w => nameLower.includes(w))) return;

                // Satırda minimum 5 hücre olmalı
                if (!row || row.length < 5) return;

                const cal = parseFloat(row[1]);
                const carbs = parseFloat(row[2]);
                const protein = parseFloat(row[3]);
                const fat = parseFloat(row[4]);

                if (
                    isNaN(cal) || cal === 0 ||
                    isNaN(carbs) || isNaN(protein) || isNaN(fat)
                ) return;

                // Çok kısa isimli ya da sadece sayı/birim içeren adları atla
                if (name.length < 3 || /^[\d\s\-\.]+$/.test(name)) return;

                const foodObject = {
                    name,
                    calories: cal,
                    protein,
                    carbs,
                    fat,
                    category: currentCategory,
                    mealType: currentCategory === "ÖĞLEN" ? ["lunch"] : ["dinner"],
                    tags: determineTags(name),
                    role: determineRole(name),
                    keto: true,
                    lowcarb: true,
                    fillerLunch: false,
                    fillerDinner: false,
                    step: 0.5,
                    maxQuantity: 1,
                    minQuantity: 0.5
                };

                let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
                const catList = storedFoodList[foodObject.category] || [];
                const alreadyExists = catList.some(f => f.name.trim().toLowerCase() === nameLower);

                if (!alreadyExists) {
                    extractedFoods.push(foodObject);
                }
            });
        });

        integrateNewFoods(extractedFoods);
    };

    reader.readAsArrayBuffer(file);
}
</script>
<script>
// Sayfa yüklendiğinde bağlan
document.addEventListener("DOMContentLoaded", () => {
    const ids = ["editCarbs", "editProtein", "editFat"];
    ids.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesInPopup);
        }
    });
});

function updateCaloriesInPopup() {
    const carbs = parseFloat(document.getElementById("editCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}
</script>
<script>
function initializeEditFoodPanel() {
    ["editFoodCarbs", "editFoodProtein", "editFoodFat"].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesLive);
        }
    });
    updateCaloriesLive();
}

function updateCaloriesLive() {
    const carbs = parseFloat(document.getElementById("editFoodCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editFoodProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFoodFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editFoodCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}

document.addEventListener("DOMContentLoaded", () => {
    const panel = document.getElementById("editFoodPanel");
    if (panel) {
        panel.addEventListener("click", () => {
            setTimeout(() => {
                initializeEditFoodPanel();
            }, 50);
        });
    }
});
</script>
<script>
</script>
</body>
</html>
<button class="btn btn-primary w-100 mb-1" onclick="addTemplateItem()" title="Öğe Ekle"><i class="bi bi-plus-circle"></i> Öğe Ekle</button>
<button class="btn btn-success w-100 mb-1" onclick="addMealTemplate()" title="Şablon Ekle">Şablon Ekle</button>
<button class="btn btn-warning w-100" onclick="generateRandomTemplate()" title="Rastgele Şablon Oluştur">Rastgele Şablon</button>
<button class="btn btn-primary w-100 mt-1" onclick="exportTemplatesToTXT()" title="Şablonları TXT Olarak Dışa Aktar"><i class="bi bi-download"></i> Şablonları TXT Dışa Aktar</button>
<input accept=".txt" id="importTemplatesFile" onchange="importTemplatesFromTXT(event)" style="display:none" type="file"/>
<button class="btn btn-primary w-100 mt-1" onclick="document.getElementById('importTemplatesFile').click()" title="Şablonları TXT'dan Yükle"><i class="bi bi-upload"></i> Şablonları TXT'dan Yükle</button>
</div>
</div>
</div>
</div>
</div>
<ul class="nav nav-tabs mb-2" id="weekTabs"></ul>
<ul class="nav nav-tabs mb-2" id="dayTabs"></ul>
<div class="d-flex justify-content-between mb-2">
<div class="btn-group fixed-btn-group">
<input accept=".xlsx" id="importExcelFile" onchange="importFromExcel(event)" style="display:none" type="file"/>
<button class="btn btn-success me-1" onclick="document.getElementById('importExcelFile').click()" title="Excel'den Şablon Ekle">
<i class="bi bi-upload"></i> Excel'den Şablon Ekle
    </button>
<button class="btn btn-primary me-1" onclick="addWeek()" title="Hafta Ekle"><i class="bi bi-plus-circle"></i> Hafta Ekle</button>
<button class="btn btn-danger me-1" onclick="deleteWeek()" title="Hafta Sil"><i class="bi bi-trash"></i> Hafta Sil</button>
<button class="btn btn-secondary" onclick="copyWeek()" title="Hafta Kopyala"><i class="bi bi-files"></i> Hafta Kopyala</button>
<button class="btn btn-primary me-1" id="fastPlanButton" onclick="generateFastPlan()" title="Hızlı Planla"><i class="bi bi-magic"></i> Hızlı Planla</button>
<button class="btn btn-secondary" disabled="" id="undoButton" title="Geri Al"><i class="bi bi-arrow-left"></i> Geri</button>
<button class="btn btn-secondary" disabled="" id="redoButton" title="İleri Al"><i class="bi bi-arrow-right"></i> İleri</button>
<button class="btn btn-primary me-1" id="exportButton" title="Tüm Verileri Dışa Aktar">
<i class="bi bi-download"></i> Tüm Verileri Dışa Aktar
                        </button>
<input accept=".json" id="importFile" onchange="importAllData(event)" style="display:none" type="file"/>
<button class="btn btn-primary me-1" onclick="document.getElementById('importFile').click()" title="Tüm Verileri İçe Aktar"><i class="bi bi-upload"></i> Tüm Verileri İçe Aktar</button>
<button class="btn btn-primary me-1" onclick="exportToTXT()" title="TXT Olarak Dışa Aktar"><i class="bi bi-download"></i> TXT Dışa Aktar</button>
<input accept=".txt" id="importTXTFile" onchange="importFromTXT(event)" style="display:none" type="file"/>
<button class="btn btn-primary me-1" onclick="document.getElementById('importTXTFile').click()" title="TXT'dan Yemek Ekle"><i class="bi bi-upload"></i> TXT'dan Ekle</button>
<button class="btn btn-secondary" onclick="clearCache()" title="Cache Temizle"><i class="bi bi-trash"></i> Cache Temizle</button>
<button class="btn btn-primary" onclick="applyAllRules()" title="Tüm Kuralları Uygula"><i class="bi bi-check-circle"></i> Tüm Kuralları Uygula</button>
</div>
</div>
<div id="meals"></div>
<div class="macro-display">
<table id="macroTotals"></table>
<!-- Grafikler calculateMacros() tarafından buraya eklenecek -->
</div>
<div class="row mb-2">
<div class="col-3">
<label class="form-label" for="bmrDisplay">BMR</label>
<input class="form-control" id="bmrDisplay" readonly="" type="number"/>
</div>
<div class="col-3">
<label class="form-label" for="targetCalories">Kalori</label>
<input class="form-control" id="targetCalories" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetProtein">Protein</label>
<input class="form-control" id="targetProtein" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetCarbs">Karb.</label>
<input class="form-control" id="targetCarbs" readonly="" type="number"/>
</div>
<div class="col-2">
<label class="form-label" for="targetFat">Yağ</label>
<input class="form-control" id="targetFat" readonly="" type="number"/>
</div>
</div>
<table class="table macro-table">
<tbody id="macroTotals"></tbody>
</table>
</div>
<div class="p-3" id="userPanel" style="display: none;">
<h5>Kullanıcı Profili</h5>
<form id="userForm" onsubmit="handleUserFormSubmit(event)">
<div class="mb-2">
<label class="form-label" for="userName">İsim</label>
<input autocomplete="off" class="form-control" id="userName" required="" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="userWeight">Kilo (kg)</label>
<input autocomplete="off" class="form-control" id="userWeight" min="0" required="" step="0.1" type="number"/>
</div>
<div class="mb-2">
<label class="form-label" for="userActivity">Aktivite Seviyesi (1-5)</label>
<input autocomplete="off" class="form-control" id="userActivity" max="5" min="1" required="" step="1" type="number"/>
</div>
<div class="mb-2">
<label class="form-label" for="likedFoodsInput">Sevdiği Yemekler (virgülle ayırın)</label>
<input autocomplete="off" class="form-control" id="likedFoodsInput" type="text"/>
</div>
<div class="mb-2">
<label class="form-label" for="dislikedFoodsInput">Sevmediği Yemekler (virgülle ayırın)</label>
<input autocomplete="off" class="form-control" id="dislikedFoodsInput" type="text"/>
</div>
<button class="btn btn-primary" title="Profil Kaydet" type="submit">Kaydet</button>
</form>
</div>
<div class="mt-2">
<div class="input-group">
<label class="visually-hidden" for="editSearchFilterType">Arama Filtresi</label>
<select class="form-select" id="editSearchFilterType" style="width: 30%;">
<option value="name">Yemek Adı</option>
<option value="tags">Etiket</option>
<option value="role">Rol</option>
</select>
<label class="visually-hidden" for="editSearchFoodInput">Yemek Ara</label>
<input class="form-control" id="editSearchFoodInput" onkeyup="searchEditFood(this.value)" placeholder="Yemek Ara..." type="text"/>
<div class="btn-group">
<button class="btn btn-primary" onclick="addNewCategory()" title="Yeni Kategori Ekle"><i class="bi bi-plus"></i> Yeni</button>
<button class="btn btn-warning" onclick="editSelectedCategory()" title="Seçilen Kategoriyi Düzenle"><i class="bi bi-pencil"></i> Düzenle</button>
<button class="btn btn-danger" onclick="deleteSelectedCategory()" title="Seçilen Kategoriyi Sil"><i class="bi bi-trash"></i> Sil</button>
</div>
</div>
<div class="accordion" id="editCategories"></div>
</div>
</div>
<div class="edit-food-panel" id="editFoodPanel">
<h5>Yemek Düzenle</h5>
<span class="close-btn" onclick="closeEditFoodPanel()">×</span>
<form onsubmit="saveEditedFood(event)">
<input id="editFoodIndex" type="hidden"/>
<input id="editFoodOriginalName" type="hidden"/>
<div class="container-fluid">
<div class="row g-2">
<!-- Sol Sütun -->
<div class="col-6">
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodName">Yemek Adı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodName" placeholder="Yemek adını girin (örn: Kurşun Geçirmez Kahve)" required="" type="text"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodCalories">Kalori:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodCalories" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodCarbs">Karb. (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodCarbs" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodProtein">Protein (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodProtein" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodFat">Yağ (g):</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodFat" min="0" placeholder="0" required="" step="0.1" type="number"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMaxQuantity">Maks. Katsayı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMaxQuantity" max="2" min="1" step="0.5" type="number" value="1"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMinQuantity">Min. Katsayı:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMinQuantity" max="2" min="0" step="0.1" type="number" value="0.5"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodStep">Adım Değeri:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodStep" max="2" min="0" step="0.1" type="number" value="0.5"/>
</div>
</div>
</div>
<!-- Sağ Sütun -->
<div class="col-6">
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodRole">Rol:</label>
<div class="col-9">
<select class="form-select form-select-sm" id="editFoodRole">
<option value="mainDish">Ana Yemek</option>
<option value="sideDish">Yan Yemek</option>
<option value="drink">İçecek</option>
<option value="soup">Çorba</option>
<option value="dessert">Tatlı</option>
<option value="fruit">Meyve</option>
<option value="bread">Ekmek</option>
<option value="snack">Atıştırmalık</option>
<option value="supplement">Ek</option>
</select>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodTags">Etiketler:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodTags" placeholder="Virgülle ayırın (örn: keto, kahve, kurşun geçirmez)" type="text"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodSeason">Mevsim:</label>
<div class="col-9">
<select class="form-select form-select-sm" id="editFoodSeason">
<option value="4 mevsim">4 Mevsim</option>
<option value="kış">Kış</option>
<option value="yaz">Yaz</option>
<option value="ilkbahar">İlkbahar</option>
<option value="sonbahar">Sonbahar</option>
</select>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodPortionFixed">Porsiyon Sabit:</label>
<div class="col-9">
<input class="form-check-input" id="editFoodPortionFixed" name="editFoodPortionFixed" type="checkbox"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMultiplier">Çarpan:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm" id="editFoodMultiplier" min="0.1" placeholder="örn: 1" step="0.1" type="number" value="1"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0" for="editFoodMealType">Öğün Türü:</label>
<div class="col-9">
<input autocomplete="off" class="form-control form-control-sm wide-input" id="editFoodMealType" placeholder="Virgülle ayırın (örn: breakfast, lunch)" type="text"/>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Dolgu Türü:</label>
<div class="col-9 d-flex gap-3">
<div class="form-check">
<input class="form-check-input" id="editFoodFillerLunch" name="editFoodFillerLunch" type="checkbox"/>
<label class="form-check-label" for="editFoodFillerLunch">Öğlen</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editFoodFillerDinner" name="editFoodFillerDinner" type="checkbox"/>
<label class="form-check-label" for="editFoodFillerDinner">Akşam</label>
</div>
</div>
</div>
<div class="row mb-2 align-items-center">
<label class="col-3 form-label mb-0">Diyet Türü:</label>
<div class="col-9 d-flex gap-3">
<div class="form-check">
<input class="form-check-input" id="editFoodKeto" name="editFoodKeto" type="checkbox"/>
<label class="form-check-label" for="editFoodKeto">Keto</label>
</div>
<div class="form-check">
<input class="form-check-input" id="editFoodLowCarb" name="editFoodLowCarb" type="checkbox"/>
<label class="form-check-label" for="editFoodLowCarb">Low-Carb</label>
</div>
</div>
</div>
</div>
</div>
<!-- Kategoriye Taşı ve Butonlar -->
<div class="row mb-2 align-items-center mt-2">
<label class="col-2 form-label mb-0" for="editFoodMoveToCategory">Kategoriye Taşı:</label>
<div class="col-10">
<select class="form-select form-select-sm wide-input" id="editFoodMoveToCategory">
<option value="">Kategori Seç</option>
</select>
</div>
</div>
<div class="row mt-2">
<div class="col-6">
<button class="btn btn-success w-100" type="submit">Kaydet</button>
</div>
<div class="col-6">
<button class="btn btn-secondary w-100" onclick="closeEditFoodPanel()" type="button">İptal</button>
</div>
</div>
</div>
</form>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>

const roleOrder = {
    "Soup": 1,
    "MainDish": 2,
    "SideDish": 3,
    "Bread": 4,
    "Dessert": 5,
    "Fruit": 6,
    "Snack": 7,
    "Drink": 8,
    "Supplement": 9,
    "Bilinmiyor": 10
};

let globalTargetCalories = 0;
let globalTargetProtein = 0;
let globalTargetFat = 0;
let globalTargetCarbs = 0;

document.addEventListener('DOMContentLoaded', () => {
    // Checkbox'lar için başlangıç durumu
    toggleInput('freqNameCheck', 'freqName');
    toggleInput('freqTagCheck', 'freqTag');
    toggleInput('freqRoleCheck', 'freqRole');
    toggleInput('freqCatCheck', 'freqCat');

    // freqScope değiştiğinde freqMeal görünürlüğünü güncelle
    const freqScope = document.getElementById('freqScope');
    const freqMeal = document.getElementById('freqMeal');
    freqScope.addEventListener('change', () => {
        freqMeal.style.display = freqScope.value === 'meal' ? 'inline-block' : 'none';
    });
    freqMeal.style.display = freqScope.value === 'meal' ? 'inline-block' : 'none';
});




        document.addEventListener("DOMContentLoaded", function() {
            if (initialCategories && initialCategories.length > 0) {
        categories = initialCategories;
    }

    document.querySelectorAll("select[id^='editMoveToCategory']").forEach(function(categorySelect) {
        categorySelect.innerHTML = '';
        const defaultOption = document.createElement("option");
defaultOption.value = "";
defaultOption.textContent = "Kategori Seç";
categorySelect.appendChild(defaultOption);
        categories.forEach(function(cat, index) {
            const option = document.createElement("option");
            option.value = cat.name;
            option.textContent = cat.name;
            if (index === 0) option.selected = true;
            categorySelect.appendChild(option);
        });
    });
        
    // BU KODU BURAYA EKLE:
    if (initialCategories && initialCategories.length > 0) {
        categories = initialCategories;
    }
// Tüm kategori dropdownlarını doldur (birden fazla olabilir)
document.querySelectorAll("select[id^='editMoveToCategory']").forEach(categorySelect => {
    categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
    categories.forEach(cat => {
        const option = document.createElement("option");
        option.value = cat.name;
        option.textContent = cat.name;
        categorySelect.appendChild(option);
    });
});

    const categorySelect = document.getElementById("editMoveToCategory");
    if (categorySelect && categories.length > 0) {
        categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
        categories.forEach(cat => {
            const option = document.createElement("option");
            option.value = cat.name;
            option.textContent = cat.name;
            categorySelect.appendChild(option);
        });
    }




    searchEditFood('');
});

let categories = [];
const initialCategories = [
    {
        name: "KAHVALTI",
        items: [
            { name: "Kurşun Geçirmez Kahve", calories: 200, protein: 0, carbs: 0, fat: 22, maxQuantity: 1, minQuantity: 1, tags: ["keto", "içecek"], role: "drink", mealType: "breakfast", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "ÖĞLEN",
        items: [
            { name: "Yumurtalı Ispanak Kavurma", calories: 337, protein: 23, carbs: 3, fat: 26, maxQuantity: 1.5, minQuantity: 0.5, tags: ["keto", "yumurta"], role: "mainDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Keto Tost", calories: 250, protein: 15, carbs: 5, fat: 18, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "ekmek"], role: "mainDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Sabah Yeşillikleri", calories: 50, protein: 2, carbs: 5, fat: 3, maxQuantity: 2, minQuantity: 0.5, tags: ["keto", "salata"], role: "sideDish", mealType: "lunch", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "AKŞAM",
        items: [
            { name: "Köfte", calories: 250, protein: 20, carbs: 0, fat: 18, maxQuantity: 2, minQuantity: 1, tags: ["keto", "et"], role: "mainDish", mealType: "dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Tavuk Çorbası", calories: 114, protein: 10, carbs: 5, fat: 6, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "çorba"], role: "soup", mealType: "dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    },
    {
        name: "DİĞER",
        items: [
            { name: "Zeytinyağı", calories: 120, protein: 0, carbs: 0, fat: 14, maxQuantity: 2, minQuantity: 0.5, tags: ["keto", "yağ"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true },
            { name: "Keten Tohumu", calories: 44, protein: 2, carbs: 0, fat: 4, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "tohum"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true },
            { name: "Kollajen", calories: 40, protein: 10, carbs: 0, fat: 0, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "ek"], role: "supplement", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: true, fillerDinner: true }
        ]
    },
    {
        name: "KURUYEMİŞLER",
        items: [
            { name: "Badem", calories: 160, protein: 6, carbs: 6, fat: 14, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "kuruyemiş"], role: "snack", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false },
            { name: "Badem?", calories: 160, protein: 6, carbs: 6, fat: 14, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "kuruyemiş"], role: "snack", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }

        ]
    },
    {
        name: "TATLILAR",
        items: [
            { name: "Bitter Çikolata", calories: 150, protein: 2, carbs: 8, fat: 12, maxQuantity: 1, minQuantity: 0.5, tags: ["keto", "tatlı"], role: "dessert", mealType: "lunch,dinner", keto: true, lowcarb: true, fillerLunch: false, fillerDinner: false }
        ]
    }
];
categories = initialCategories;
        let weeks = [];
        let selectedWeek = 1;
        let selectedDay = "monday";
        let currentPatient = null;
        let dietMode = "keto";
        let rules = [];
        rules.push({ type: 'maxRoleCount', mealType: 'lunch', role: 'mainDish', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'dinner', role: 'mainDish', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'lunch', role: 'soup', count: 1 });
rules.push({ type: 'maxRoleCount', mealType: 'dinner', role: 'soup', count: 1 });

        let compatibilityTable = [];

        const days = ["monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"];
        const roles = [
            { role: "mainDish", active: true },
            { role: "sideDish", active: true },
            { role: "drink", active: true },
            { role: "soup", active: false },
            { role: "dessert", active: false },
            { role: "fruit", active: false },
            { role: "bread", active: false },
            { role: "snack", active: false },
            { role: "supplement", active: false }
        ];

        function initializeWeeks() {
            if (weeks.length === 0) {
                weeks.push({
                    days: {
                        monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                        sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
                    }
                });
            }
        }
// Şablonlar ve benzersizlik kontrolü
let mealTemplates = [];
let lunchCounter = 1;
let dinnerCounter = 1;
const existingMeals = new Set();





function addToCategoriesIfNew(foodName, line, mealType) {
    let found = false;
    for (const category of categories) {
        if (category.items.some(item => item.name === foodName)) {
            found = true;
            break;
        }
    }
    if (!found) {
        const macroMatch = line.match(/(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)\s+(\d+\.?\d*)/);
        const newFood = {
            name: foodName,
            calories: macroMatch ? parseFloat(macroMatch[1]) : 0,
            protein: macroMatch ? parseFloat(macroMatch[3]) : 0,
            carbs: macroMatch ? parseFloat(macroMatch[2]) : 0,
            fat: macroMatch ? parseFloat(macroMatch[4]) : 0,
            maxQuantity: 2,
            minQuantity: 0.5,
            tags: ["keto"], // Varsayılan, özelleştirilebilir
            role: inferRole(foodName),
            mealType: [mealType],
            keto: true,
            lowcarb: true,
            fillerLunch: false,
            fillerDinner: false,
            step: 0.5,
            category: "Yeni Yemekler"
        };
        const newCategory = categories.find(cat => cat.name === "Yeni Yemekler") || { name: "Yeni Yemekler", items: [] };
        newCategory.items.push(newFood);
        if (!categories.some(cat => cat.name === "Yeni Yemekler")) categories.push(newCategory);
        console.log(`Yeni yemek eklendi: ${foodName}`, newFood);
    }
}


       

function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('active');
        }

        function switchMode(mode) {
    document.getElementById('adminPanel').style.display = mode === 'admin' ? 'block' : 'none';
    document.getElementById('userPanel').style.display = mode === 'user' ? 'block' : 'none';
}

function updateDietMode(mode) {
    dietMode = mode;
    const carbMultiplier = mode === 'keto' ? 0.3 : 0.6;
    const proteinMultiplier = 0.8;
    const fatMultiplier = mode === 'keto' ? 1.2 : 1.0;
    document.getElementById('carbMultiplier').value = carbMultiplier;
    document.getElementById('proteinMultiplier').value = proteinMultiplier;
    document.getElementById('fatMultiplier').value = fatMultiplier;
    loadCategories();
    renderMeals();
    calculateMacros();
    showNotification(`Diyet modu ${mode} olarak güncellendi!`);
}

function loadCategories() {
    console.log("Kategoriler yükleniyor...");
    console.log("categories dizisi:", JSON.stringify(categories, null, 2)); // categories dizisini logla

    // 1. Kategori seçim dropdown’unu güncelle
    const categorySelect = document.getElementById('foodCategory');
    if (categorySelect) {
        categorySelect.innerHTML = '<option value="">Kategori Seçin</option>' + 
            categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
    } else {
        console.error("foodCategory elemanı bulunamadı!");
    }

    // 2. Sidebar’daki akordiyon menüyü güncelle (filtresiz)
    const sidebarCategories = document.getElementById('categories');
    if (sidebarCategories) {
        sidebarCategories.innerHTML = categories.map((category, index) => `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                        ${category.name} (${category.items.length})
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                    <div class="accordion-body">
                        ${category.items.map(item => `
                            <div class="category-item d-flex justify-content-between align-items-center">
                                <div class="d-flex align-items-center">
                                    <button class="btn btn-danger btn-sm me-1" onclick="deleteFood('${item.name}', '${category.name}')" title="Sil"><i class="bi bi-trash"></i></button>
                                    <button class="btn btn-warning btn-sm me-2" onclick="editFood('${item.name}')" title="Düzenle"><i class="bi bi-pencil"></i></button>
                                    <span>${item.name} (${item.calories} kcal)</span>
                                </div>
                                <div class="food-checkboxes">
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="breakfast" title="Sabah"> S
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="lunch" title="Öğle"> Ö
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="dinner" title="Akşam"> A
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `).join('');
        console.log("Sidebar güncellendi:", sidebarCategories.innerHTML); // Kontrol için
    } else {
        console.error("Sidebar'daki 'categories' elemanı bulunamadı!");
    }

    // 3. Sağ paneli güncelle
    searchEditFood('');
    // searchFood('') çağrısını kaldırdık, sadece kullanıcı arama yaptığında çalışsın
}

document.addEventListener('DOMContentLoaded', function() {
    fetch('https://raw.githubusercontent.com/mustafasacar35/beslenme/refs/heads/main/sistem_JSON.json')
        .then(response => response.json())
        .then(data => {
            window.categories = data.categories || [];
            window.patients = data.patients || {};
            window.settingsTemplates = data.settingsTemplates || {};
            window.mealTemplates = data.mealTemplates || [];
            window.rules = data.rules || [];
            window.compatibilityTable = data.compatibilityTable || [];

            // localStorage'a GitHub verilerini yaz
            Object.entries(window.patients).forEach(([key, value]) => {
                localStorage.setItem(key, JSON.stringify(value));
            });

            categories = window.categories;
            loadCategories();
            testUpdateSidebar();
            rules = window.rules;
            mealTemplates = window.mealTemplates;
            compatibilityTable = window.compatibilityTable;

            console.log("Yüklenen Kategoriler:", window.categories);
            console.log("Yüklenen Hastalar:", window.patients);
            console.log("Yüklenen Kurallar:", window.rules);

            testUpdateSidebar();
            loadPatientSelect(); // testLoadPatientSelect yerine
            loadSettingsTemplates();
            loadMealTemplates();
            loadRules();
            loadCompatibilityRules();
            renderMeals();
            calculateMacros();

            showNotification("GitHub'dan veriler başarıyla yüklendi!", "success");
        })
        .catch(error => {
            console.error("Veriler yüklenirken hata oluştu:", error);
            showNotification("GitHub'dan veriler yüklenemedi!", "warning");
        });
});

    function testUpdateSidebar() {
        const sidebarContent = document.getElementById('categories');
        if (!sidebarContent) {
            console.error("categories elementi bulunamadı!");
            return;
        }
        sidebarContent.innerHTML = '';
        window.categories.forEach((category, index) => {
            const itemCount = category.items.length;
            const accordionItem = `
                <div class="accordion-item">
                    <h2 class="accordion-header" id="heading${index}">
                        <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                            ${category.name} (${itemCount})
                        </button>
                    </h2>
                    <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                        <div class="accordion-body">
                            ${category.items.map(food => `
                                <div class="category-item">
                                    <span>${food.name} (${food.calories} kcal)</span>
                                    <div class="food-checkboxes">
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="breakfast" title="Sabah"> S
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="lunch" title="Öğle"> Ö
                                        <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="dinner" title="Akşam"> A
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            sidebarContent.innerHTML += accordionItem;
        });
        console.log("Test Sidebar güncellendi!");
    }

    function testLoadPatientSelect() {
        const patientSelect = document.getElementById('patientSelect');
        if (!patientSelect) {
            console.error("patientSelect elementi bulunamadı! DOM'da 'patientSelect' ID'sine sahip bir eleman yok.");
            return;
        }
        console.log("patientSelect elementi bulundu:", patientSelect);

        // `window.patients` verisini kontrol et
        console.log("Yüklenmeye çalışılan hastalar (ham veri):", window.patients);

        if (!window.patients || Object.keys(window.patients).length === 0) {
            console.warn("window.patients boş veya tanımsız!");
            patientSelect.innerHTML = '<option value="">Hasta Yok</option>';
            return;
        }

        // Objedeki hastaları bir diziye çevir
        const patientArray = Object.values(window.patients);
        console.log("Hastalar diziye çevrildi:", patientArray);

        patientSelect.innerHTML = '<option value="">Hasta Seç</option>';
        patientArray.forEach((patient, index) => {
            const option = document.createElement('option');
            option.value = patient.name || `Hasta-${index}`;
            option.textContent = patient.name || `Hasta-${index}`;
            patientSelect.appendChild(option);
            console.log("Eklenen hasta:", patient.name || `Hasta-${index}`);
        });
        console.log("Test Hasta Seçimi güncellendi! Toplam hasta sayısı:", patientArray.length);
    }



    function searchFood(query) {
    const filterType = document.getElementById('searchFilterType').value;
    const sidebarContent = document.getElementById('categories');
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    const likedFoods = patientData.likedFoods || [];
    const dislikedFoods = patientData.dislikedFoods || [];

    sidebarContent.innerHTML = categories.map((category, index) => {
        let filteredItems = category.items.filter(item => {
            const matchesDiet = dietMode === 'keto' ? item.keto : item.lowcarb;
            const notDisliked = !dislikedFoods.some(df => item.name.toLowerCase().includes(df.toLowerCase()) || item.tags.some(t => t.toLowerCase().includes(df.toLowerCase())));
            if (filterType === 'name') return matchesDiet && notDisliked && item.name.toLowerCase().includes(query.toLowerCase());
            if (filterType === 'tags') return matchesDiet && notDisliked && item.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));
            if (filterType === 'role') return matchesDiet && notDisliked && item.role.toLowerCase().includes(query.toLowerCase());
            return matchesDiet && notDisliked;
        });

        filteredItems.sort((a, b) => {
            const aLiked = likedFoods.some(lf => a.name.toLowerCase().includes(lf.toLowerCase()) || a.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
            const bLiked = likedFoods.some(lf => b.name.toLowerCase().includes(lf.toLowerCase()) || b.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
            return bLiked - aLiked;
        });

        return `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                        ${category.name} (${filteredItems.length})
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                    <div class="accordion-body">
                        ${filteredItems.map(item => `
                            <div class="category-item">
                                <span>${item.name} (${item.calories} kcal)</span>
                                <div class="food-checkboxes">
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="breakfast" title="Sabah"> S
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="lunch" title="Öğle"> Ö
                                    <input type="checkbox" class="meal-checkbox" data-name="${item.name}" data-meal="dinner" title="Akşam"> A
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;
    }).join('');
}

        function addNewCategory() {
    const categoryName = prompt("Yeni kategori adını girin:");
    if (categoryName && !categories.some(cat => cat.name === categoryName)) {
        categories.push({ name: categoryName, items: [] });
        loadCategories();
        showNotification("Yeni kategori eklendi!");
    } else if (categories.some(cat => cat.name === categoryName)) {
        showNotification("Bu kategori zaten var!", "warning");
    }
}

function editSelectedCategory() {
    const selectedCheckbox = document.querySelector('.category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    const oldName = categories[index].name;
    const newName = prompt("Yeni kategori adını girin:", oldName);
    if (newName && newName !== oldName && !categories.some(cat => cat.name === newName)) {
        categories[index].name = newName;
        loadCategories();
        showNotification("Kategori güncellendi!");
    } else if (categories.some(cat => cat.name === newName)) {
        showNotification("Bu kategori zaten var!", "warning");
    }
}

function deleteSelectedCategory() {
    const selectedCheckbox = document.querySelector('.category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    if (confirm(`${categories[index].name} kategorisini silmek istediğinize emin misiniz?`)) {
        categories.splice(index, 1);
        loadCategories();
        showNotification("Kategori silindi!");
    }
}

        function addSelectedFoods() {
    const checkboxes = document.querySelectorAll('.meal-checkbox:checked');
    if (checkboxes.length === 0) {
        showNotification("Lütfen en az bir öğün seçin!", "warning");
        return;
    }
    checkboxes.forEach(checkbox => {
        const foodName = checkbox.getAttribute('data-name');
        const mealType = checkbox.getAttribute('data-meal');
        weeks[selectedWeek - 1].days[selectedDay].meals[mealType].push({ name: foodName, quantity: 1 });
        checkbox.checked = false;
    });
    renderMeals();
    calculateMacros();
    toggleSidebar();
    showNotification("Yemekler eklendi!");
}

        function toggleAddFoodForm() {
            const form = document.getElementById('addFoodForm');
            form.style.display = form.style.display === 'none' ? 'block' : 'none';
        }

        function addNewFood(event) {
    event.preventDefault();
    const categoryName = document.getElementById('foodCategory').value;
    const name = document.getElementById('foodName').value;
    const calories = parseFloat(document.getElementById('foodCalories').value);
    const protein = parseFloat(document.getElementById('foodProtein').value);
    const carbs = parseFloat(document.getElementById('foodCarbs').value);
    const fat = parseFloat(document.getElementById('foodFat').value);
    const maxQuantity = parseFloat(document.getElementById('foodMaxQuantity').value);
    const minQuantity = parseFloat(document.getElementById('foodMinQuantity').value);
    const tags = document.getElementById('foodTags').value.split(',').map(t => t.trim()).filter(t => t);
    const keto = document.getElementById('foodKeto').checked;
    const lowcarb = document.getElementById('foodLowCarb').checked;
    const fillerLunch = document.getElementById('foodFillerLunch').checked;
    const fillerDinner = document.getElementById('foodFillerDinner').checked;
    const step = parseFloat(document.getElementById('foodStep').value) || 0.5;

    const category = categories.find(cat => cat.name === categoryName);
    if (category) {
        category.items.push({
            name,
            calories,
            protein,
            carbs,
            fat,
            maxQuantity,
            minQuantity,
            tags,
            role: "mainDish",
            mealType: "breakfast,lunch,dinner", // String olarak bırakılmış, orijinal kodunuzda böyle
            keto,
            lowcarb,
            fillerLunch,
            fillerDinner,
            step
        });
    } else {
        // Eğer kategori yoksa, yeni bir kategori oluştur
        categories.push({
            name: categoryName,
            items: [{
                name,
                calories,
                protein,
                carbs,
                fat,
                maxQuantity,
                minQuantity,
                tags,
                role: "mainDish",
                mealType: "breakfast,lunch,dinner",
                keto,
                lowcarb,
                fillerLunch,
                fillerDinner,
                step
            }]
        });
    }

    const form = document.getElementById('addFoodFormInner');
    if (form) {
        form.reset(); // Formu sıfırla
        document.getElementById('foodMaxQuantity').value = 1; // Varsayılan değeri geri yükle
    } else {
        console.error("addFoodFormInner bulunamadı!");
    }

    toggleAddFoodForm(); // Formu gizle
    loadCategories();    // Soldaki paneli güncelle
    searchEditFood('');  // Sağdaki paneli güncelle
    showNotification(`${name} yemeği eklendi!`);
    updateGitHubData();  // GitHub'a verileri gönder
}

        function renderWeekTabs() {
            const weekTabs = document.getElementById('weekTabs');
            weekTabs.innerHTML = weeks.map((_, index) => `
                <li class="nav-item">
                    <a class="nav-link ${selectedWeek === index + 1 ? 'active' : ''}" href="#" onclick="selectWeek(${index + 1})">Hafta ${index + 1}</a>
                </li>
            `).join('');
        }

        function renderDayTabs() {
            const dayTabs = document.getElementById('dayTabs');
            dayTabs.innerHTML = days.map(day => `
                <li class="nav-item">
                    <a class="nav-link ${selectedDay === day ? 'active' : ''}" href="#" onclick="selectDay('${day}')">${day.charAt(0).toUpperCase() + day.slice(1)}</a>
                </li>
            `).join('');
        }

        function selectWeek(week) {
            selectedWeek = week;
            renderWeekTabs();
            renderMeals();
            calculateMacros();
        }

        function selectDay(day) {
            selectedDay = day;
            renderDayTabs();
            renderMeals();
            calculateMacros();
        }

        function addWeek() {
    if (typeof saveState === 'function') {
        saveState(); // İşlemden önce durumu kaydet
    }
    weeks.push({
        days: {
            monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
            sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
        }
    });
    selectedWeek = weeks.length;
    renderWeekTabs();
    renderMeals();
    calculateMacros(); // Grafikleri güncelle
    if (typeof showNotification === 'function') {
        showNotification("Yeni hafta eklendi!", "success");
    }
}

function deleteWeek() {
    if (weeks.length > 1) {
        if (typeof saveState === 'function') {
            saveState(); // İşlemden önce durumu kaydet
        }
        weeks.splice(selectedWeek - 1, 1);
        selectedWeek = Math.min(selectedWeek, weeks.length);
        renderWeekTabs();
        renderMeals();
        calculateMacros();
        if (typeof showNotification === 'function') {
            showNotification("Hafta silindi!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("En az bir hafta kalmalı!", "warning");
        }
    }
}

function copyWeek() {
    if (typeof saveState === 'function') {
        saveState(); // İşlemden önce durumu kaydet
    }
    const newWeek = JSON.parse(JSON.stringify(weeks[selectedWeek - 1]));
    weeks.push(newWeek);
    selectedWeek = weeks.length;
    renderWeekTabs();
    renderMeals();
    calculateMacros();
    if (typeof showNotification === 'function') {
        showNotification("Hafta kopyalandı!", "success");
    }
}

function getActiveRoles(meal) {
    const mealItems = meal.map(item => findFood(item.name)?.role);
    return roles.map(role => ({
        ...role,
        active: mealItems.includes(role.role)
    }));
}

function toggleRole(mealType, roleIndex) {
    if (!weeks || !Array.isArray(weeks) || selectedWeek < 1 || !weeks[selectedWeek - 1] || !weeks[selectedWeek - 1].days[selectedDay]) {
        console.warn(`toggleRole: Hafta ${selectedWeek} veya gün ${selectedDay} tanımsız!`);
        return;
    }

    const meal = weeks[selectedWeek - 1].days[selectedDay].meals[mealType];
    if (!meal || !Array.isArray(meal)) {
        console.warn(`toggleRole: ${mealType} öğünü tanımsız veya dizi değil!`);
        return;
    }

    const activeRoles = getActiveRoles(meal);
    if (roleIndex < 0 || roleIndex >= activeRoles.length) {
        console.warn(`toggleRole: Geçersiz roleIndex: ${roleIndex}`);
        return;
    }

    const role = activeRoles[roleIndex].role;
    const isActive = activeRoles.some((r) => r.role === role && r.active);

    if (typeof saveState === 'function') {
        saveState(); // İşlemden önce durumu kaydet
    }

    if (!isActive) {
        const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || "{}") : {};
        const likedFoods = patientData.likedFoods || [];
        const dislikedFoods = patientData.dislikedFoods || [];

        const availableFoods = categories
            .flatMap((cat) => cat.items)
            .filter((food) => 
                food.role === role &&
                isMealTypeCompatible(food, mealType) &&
                (dietMode === "keto" ? food.keto : food.lowcarb) &&
                !dislikedFoods.some((df) => food.name.toLowerCase().includes(df.toLowerCase()) || (food.tags && food.tags.some((t) => t.toLowerCase().includes(df.toLowerCase())))) &&
                !checkKeywordConflict(food.name, meal) // Etiket çakışma kontrolü
            );

        if (availableFoods.length === 0) {
            console.warn(`toggleRole: ${mealType} için ${role} rolünde uygun yemek bulunamadı!`);
            if (typeof showNotification === 'function') {
                showNotification(`${mealType} için ${role} rolünde yemek eklenemedi: Uygun seçenek yok.`, "warning");
            }
            return;
        }

        const preferredFoods = availableFoods.filter((food) =>
            likedFoods.some((lf) => food.name.toLowerCase().includes(lf.toLowerCase()) || (food.tags && food.tags.some((t) => t.toLowerCase().includes(lf.toLowerCase()))))
        );

        const selectedFood = preferredFoods.length > 0 ? preferredFoods[Math.floor(Math.random() * preferredFoods.length)] : availableFoods[Math.floor(Math.random() * availableFoods.length)];
        
        meal.push({ name: selectedFood.name, quantity: 1 });
        console.log(`toggleRole: ${mealType} öğününe ${selectedFood.name} (${role}) eklendi.`);
        if (typeof showNotification === 'function') {
            showNotification(`${selectedFood.name} ${mealType} öğününe eklendi!`, "success");
        }
    } else {
        const index = meal.findIndex((item) => {
            const food = findFood(item.name);
            return food && food.role === role;
        });

        if (index !== -1) {
            const removedFood = meal[index].name;
            meal.splice(index, 1);
            console.log(`toggleRole: ${mealType} öğününden ${removedFood} (${role}) kaldırıldı.`);
            if (typeof showNotification === 'function') {
                showNotification(`${removedFood} ${mealType} öğününden kaldırıldı!`, "success");
            }
        }
    }

    renderMeals();
    calculateMacros();
}

function renderMeals() {
    console.log("renderMeals çalışıyor...");
    const mealsDiv = document.getElementById('meals');
    if (!mealsDiv) {
        console.error("meals elementi bulunamadı!");
        return;
    }

    const weekIndex = selectedWeek ? Math.max(0, Math.min(selectedWeek - 1, weeks.length - 1)) : 0;
    const day = selectedDay || "monday";

    if (!weeks || !Array.isArray(weeks) || !weeks[weekIndex] || !weeks[weekIndex].days || !weeks[weekIndex].days[day]) {
        console.warn(`Hafta ${weekIndex + 1} veya gün ${day} tanımsız!`, weeks);
        return;
    }

    const dayMeals = weeks[weekIndex].days[day].meals;
    if (!dayMeals || typeof dayMeals !== 'object' || 
        !Array.isArray(dayMeals.breakfast) || 
        !Array.isArray(dayMeals.lunch) || 
        !Array.isArray(dayMeals.dinner)) {
        console.warn(`Gün ${day} için meals yapısı eksik!`, dayMeals);
        return;
    }

    const calculateCalories = (items) => items.reduce((total, item) => {
        const food = findFood(item.name);
        return food ? total + food.calories * (item.quantity || 1) : total;
    }, 0);

    const breakfastCalories = calculateCalories(dayMeals.breakfast);
    const lunchCalories = calculateCalories(dayMeals.lunch);
    const dinnerCalories = calculateCalories(dayMeals.dinner);

    const targetCalories = parseFloat(document.getElementById('targetCalories')?.value) || 2000;
    const lunchRatio = parseFloat(document.getElementById('lunchCalorieRatio')?.value) || 40;
    const dinnerRatio = parseFloat(document.getElementById('dinnerCalorieRatio')?.value) || 30;

    const sortMealsByRole = (meals) => {
        return meals.slice().sort((a, b) => {
            const foodA = findFood(a.name) || { role: "Bilinmiyor" };
            const foodB = findFood(b.name) || { role: "Bilinmiyor" };
            const roleA = foodA.role || "Bilinmiyor";
            const roleB = foodB.role || "Bilinmiyor";
            console.log(`sortMealsByRole: ${a.name} (role: ${roleA}), ${b.name} (role: ${roleB})`);
            const roleOrder = {
                "Soup": 1,
                "MainDish": 2,
                "SideDish": 3,
                "Bread": 4,
                "Dessert": 5,
                "Fruit": 6,
                "Snack": 7,
                "Drink": 8,
                "Supplement": 9,
                "Bilinmiyor": 10
            };
            return (roleOrder[roleA] || 10) - (roleOrder[roleB] || 10);
        });
    };

    const sortedBreakfast = sortMealsByRole(dayMeals.breakfast);
    const sortedLunch = sortMealsByRole(dayMeals.lunch);
    const sortedDinner = sortMealsByRole(dayMeals.dinner);

    const requiredFunctions = { findFood, getActiveRoles, renderMealItem, toggleRole };
    for (const [name, fn] of Object.entries(requiredFunctions)) {
        if (typeof fn !== 'function') {
            console.warn(`${name} fonksiyonu tanımlı değil, bazı özellikler çalışmayabilir.`);
        }
    }

    mealsDiv.innerHTML = `
        <div class="card meal-card">
            <div class="card-header">
                <span>Kahvaltı (${breakfastCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * (1 - lunchRatio / 100 - dinnerRatio / 100)).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="breakfast"
                               aria-label="Kahvaltı için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.breakfast).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('breakfast', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedBreakfast.map((item, index) => renderMealItem(item, 'breakfast', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card meal-card">
            <div class="card-header">
                <span>Öğle (${lunchCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * lunchRatio / 100).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="lunch"
                               aria-label="Öğle için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                    ${typeof addCurrentMealToTemplates === 'function' ? `
                        <button class="btn btn-sm btn-success template-add-btn ms-2" 
                                onclick="addCurrentMealToTemplates('lunch')">Öğün Kayıt</button>
                    ` : ''}
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.lunch).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('lunch', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedLunch.map((item, index) => renderMealItem(item, 'lunch', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
        <div class="card meal-card">
            <div class="card-header">
                <span>Akşam (${dinnerCalories.toFixed(0)} kcal / Hedef: ${(targetCalories * dinnerRatio / 100).toFixed(0)})</span>
                <div class="d-flex align-items-center ms-2">
                    <div class="position-relative">
                        <input type="text" class="form-control form-control-sm meal-search-input" 
                               placeholder="Yemek ara..." 
                               data-meal-type="dinner"
                               aria-label="Akşam için yemek ara">
                        <div class="search-results" 
                             style="display: none; position: absolute; top: 100%; left: 0; 
                                    width: 100%; max-height: 200px; overflow-y: auto; 
                                    background: var(--white); border: 1px solid var(--gray-border); 
                                    z-index: 1000; border-radius: 4px;">
                        </div>
                    </div>
                    ${typeof addCurrentMealToTemplates === 'function' ? `
                        <button class="btn btn-sm btn-success template-add-btn ms-2" 
                                onclick="addCurrentMealToTemplates('dinner')">Öğün Kayıt</button>
                    ` : ''}
                </div>
                <div class="role-checkboxes">
                    ${getActiveRoles ? getActiveRoles(dayMeals.dinner).map((r, i) => `
                        <span><input type="checkbox" ${r.active ? 'checked' : ''} onchange="toggleRole('dinner', ${i})"> ${r.role}</span>
                    `).join('') : 'Rol bilgileri yüklenemedi'}
                </div>
            </div>
            <div class="card-body">
                <table class="table meal-table">
                    <thead>
                        <tr>
                            <th class="rule-column">Kural</th>
                            <th class="conflict-column">Çakışma</th>
                            <th class="food-column">Yemek</th>
                            <th>Kategori/Rol</th>
                            <th>Miktar</th>
                            <th>Kalori</th>
                            <th>Karb.</th>
                            <th>Protein</th>
                            <th>Yağ</th>
                            <th>İşlem</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedDinner.map((item, index) => renderMealItem(item, 'dinner', index)).join('')}
                    </tbody>
                </table>
            </div>
        </div>
    `;

    document.querySelectorAll('.meal-search-input').forEach(input => {
        input.addEventListener('input', handleMealSearch);
        input.addEventListener('focus', () => {
            if (input.value.trim()) {
                showSearchResults(input);
            }
        });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                const resultsDiv = input.nextElementSibling;
                resultsDiv.style.display = 'none';
            }, 200);
        });
    });
}

// Debounce yardımcı fonksiyonu
function debounce(func, wait) {
    let timeout;
    return function (...args) {
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(this, args), wait);
    };
}

// handleMealSearch güncellenmiş hali
function handleMealSearch(event) {
    const input = event.target;
    const query = input.value.trim().toLowerCase();
    const mealType = input.dataset.mealType;
    const resultsDiv = input.nextElementSibling;

    if (!query) {
        resultsDiv.style.display = 'none';
        resultsDiv.innerHTML = '';
        return;
    }

    showSearchResults(input);
}

// Arama input'larına debounce ekle
document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.meal-search-input').forEach(input => {
        input.addEventListener('input', debounce(handleMealSearch, 300)); // 300ms gecikme
        input.addEventListener('focus', () => {
            if (input.value.trim()) {
                showSearchResults(input);
            }
        });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                const resultsDiv = input.nextElementSibling;
                resultsDiv.style.display = 'none';
            }, 200);
        });
    });
});

function showSearchResults(input) {
    const query = input.value.trim().toLowerCase();
    const mealType = input.dataset.mealType;
    const resultsDiv = input.nextElementSibling;

    // Sorguyu kelimelere ayır (boşluklara göre)
    const queryWords = query.split(/\s+/).filter(word => word.length > 0);

    // Yemekleri filtrele
    const filteredFoods = [];
    categories.forEach(category => {
        category.items.forEach(food => {
            // Yemek ismini normalleştir
            const normalizedFoodName = food.name
                .toLowerCase()
                .replace(/[\d.]+/g, '') // Sayıları çıkar (örn. "1", "0.5")
                .replace(/\b(dilim|kase|bardak|porsiyon|adet|kaşık|fincan|tabak)\b/g, '') // Ölçü birimlerini çıkar
                .replace(/\s+/g, ' ') // Fazla boşlukları temizle
                .trim();

            // Sorgudaki her kelimenin yemek isminde olup olmadığını kontrol et
            const matches = queryWords.every(queryWord => 
                normalizedFoodName.includes(queryWord)
            );

            if (matches) {
                // Eşleşme puanını hesapla (daha fazla kelime eşleşmesi = daha yüksek puan)
                const matchScore = queryWords.reduce((score, word) => 
                    score + (normalizedFoodName.includes(word) ? 1 : 0), 0);
                filteredFoods.push({ ...food, category: category.name, matchScore });
            }
        });
    });

    // Sonuçları eşleşme puanına göre sırala (daha yüksek puan üstte)
    filteredFoods.sort((a, b) => b.matchScore - a.matchScore);

    // Sonuçları render et
    if (filteredFoods.length === 0) {
        resultsDiv.innerHTML = `
            <div class="search-result-empty">
                "${query}" ile eşleşen yemek bulunamadı.
            </div>
        `;
    } else {
        resultsDiv.innerHTML = filteredFoods.map(food => `
            <div class="search-result-item" 
                 onclick="addFoodToMeal('${mealType}', '${food.name}', '${food.category}')">
                ${food.name} (${food.calories} kcal)
            </div>
        `).join('');
    }

    resultsDiv.style.display = 'block';
}

function addFoodToMeal(mealType, foodName, categoryName) {
    if (typeof saveState === 'function') {
        saveState(); // Save state before modifying
    }

    const category = categories.find(cat => cat.name === categoryName);
    const food = category?.items.find(item => item.name === foodName);
    if (!food) {
        if (typeof showNotification === 'function') {
            showNotification(`Yemek bulunamadı: ${foodName}`, 'warning');
        }
        return;
    }

    const weekIndex = selectedWeek ? selectedWeek - 1 : 0;
    const day = selectedDay || "monday";
    const dayMeals = weeks[weekIndex].days[day].meals;

    // Check if food already exists in the meal
    const existingFood = dayMeals[mealType].find(item => item.name === foodName);
    if (existingFood) {
        if (typeof showNotification === 'function') {
            showNotification(`${foodName} zaten bu öğünde mevcut!`, 'warning');
        }
        return;
    }

    // Add food to meal
    dayMeals[mealType].push({
        name: food.name,
        calories: food.calories || 0,
        carbs: food.carbs || 0,
        protein: food.protein || 0,
        fat: food.fat || 0,
        quantity: 1,
        role: food.role || 'maindish'
    });

    // Update UI
    renderMeals();
    if (typeof calculateMacros === 'function') {
        calculateMacros();
    }
    if (typeof showNotification === 'function') {
        showNotification(`${foodName} ${mealType} öğününe eklendi!`, 'success');
    }

    // Clear search input and hide results
    const input = document.querySelector(`.meal-search-input[data-meal-type="${mealType}"]`);
    if (input) {
        input.value = '';
        input.nextElementSibling.style.display = 'none';
    }
}


function renderMealItem(item, mealType, index) {
    const food = findFood(item.name);
    if (!food) {
        console.warn(`Yemek bulunamadı: ${item.name}`);
        return '';
    }

    let quantity = item.quantity || 1;
    const week = selectedWeek - 1;
    const day = selectedDay;

    // Yemek adını güncelleyen fonksiyon
    const updateName = (name, quantity) => {
        let updatedName = name;
        const units = ["gram", "adet", "kase", "porsiyon", "dilim", "kaşık", "tatlı kaşığı", "yemek kaşığı", "yaprak", "kare"];
        for (const unit of units) {
            const regex = new RegExp(`(\\d+(?:\\.\\d+)?)\\s*${unit}`, "g");
            updatedName = updatedName.replace(regex, (match, number) => {
                const baseValue = parseFloat(number);
                let updatedValue = baseValue * quantity;
                updatedValue = roundQuantity(updatedValue, true); // Artırma için yuvarla
                return formatQuantityWithText(`${updatedValue} ${unit}`);
            });
        }

        // Özel kaşık dönüşümleri
        if (quantity === 0.5 && updatedName.includes("yemek kaşığı")) {
            updatedName = updatedName.replace(/\byemek kaşığı\b/, "tatlı kaşığı");
        }
        if (updatedName.includes("yarım yemek kaşığı")) {
            updatedName = updatedName.replace(/\byarım yemek kaşığı\b/, "1 tatlı kaşığı");
        }
        if (updatedName.includes("2 tatlı kaşığı")) {
            updatedName = updatedName.replace(/\b2 tatlı kaşığı\b/, "1 yemek kaşığı");
        }
        if (updatedName.includes("0.25 yemek kaşığı")) {
            updatedName = updatedName.replace(/\b0\.25 yemek kaşığı\b/, "çeyrek yemek kaşığı");
        }

        return updatedName;
    };

    let updatedName = updateName(food.name, quantity);
    const category = categories.find(cat => cat.items.some(i => i.name === item.name))?.name || 'Bilinmiyor';
    const role = food.role || 'Bilinmiyor';

    // Kuralı bul
    const { appliedRule, conflictingRules } = findAppliedRule(food, mealType);

    // Kural açıklamasını oluştur
    const getRuleDescription = (rule) => {
        if (!rule) return '-';
        switch (rule.type) {
            case 'frequency':
                const freqText = rule.frequencyType === 'max' ? 'en fazla' : 
                                rule.frequencyType === 'min' ? 'en az' : '';
                return `(${rule.id}) Rol: ${rule.role || 'herhangi'} her ${rule.mealType || 'öğünde'} ${freqText} ${rule.frequency} kez`;
            case 'dependOn':
                return `(${rule.id}) ${rule.food} yalnızca ${rule.requiredFood} ile eklensin`;
            case 'compatibility':
                return `(${rule.id}) ${rule.keyword1} ile ${rule.keyword2.join(', ')} (${rule.degree > 0 ? 'uyumlu' : 'uyumsuz'})`;
            default:
                return `(${rule.id}) ${rule.type}`;
        }
    };

    const ruleText = appliedRule 
        ? `<span title="${getRuleDescription(appliedRule)}">${appliedRule.id} / ${appliedRule.type}</span>` 
        : '-';
    const conflictingText = conflictingRules.length > 0 
        ? conflictingRules.map(r => `<span title="${getRuleDescription(r)}">${r.id} / ${r.type}</span>`).join(', ') 
        : '-';

    return `
    <tr class="meal-item" data-name="${item.name}" data-meal="${mealType}" data-day="${day}" data-week="${week}">
        <td class="rule-column">${ruleText}</td>
        <td class="conflict-column">${conflictingText}</td>
        <td class="food-column">
            ${updatedName}
            <br><small style="color:gray;">Artış düzeyi: ${food.step || 0.5}</small>
        </td>
        <td>${category} / ${role}</td>
        <td>
            <input type="number" 
                   value="${quantity}" 
                   min="${food.minQuantity || 0.1}" 
                   max="${food.maxQuantity || 10}" 
                   step="${food.step || 0.5}" 
                   onchange="updateMealQuantityFromDOM(this)">
        </td>
        <td>${((food.carbs * 4 + food.protein * 4 + food.fat * 9) * quantity).toFixed(1)}</td>
        <td>${(food.carbs * quantity).toFixed(1)}</td>
        <td>${(food.protein * quantity).toFixed(1)}</td>
        <td>${(food.fat * quantity).toFixed(1)}</td>
        <td>
            <button class="btn btn-warning btn-sm" onclick="editMealItemFromDOM(this)" title="Düzenle">
                <i class="bi bi-pencil"></i>
            </button>
            <button class="btn btn-remove-from-meal btn-sm" onclick="deleteMealItemFromDOM(this)" title="Öğünden Sil">
                <i class="bi bi-trash"></i>
            </button>
            <button class="btn btn-danger btn-sm" onclick="deleteFoodFromSystem('${item.name}')" title="Sistemden Sil">
                <i class="bi bi-trash-fill"></i>
            </button>
            <button class="btn btn-primary btn-sm" onclick="replaceWithAlternative('${item.name}', '${mealType}')" title="Alternatif ile Değiştir">
                <i class="bi bi-arrow-repeat"></i>
            </button>
        </td>
    </tr>
    `;
}


// Önceki alternatifleri takip etmek için global bir değişken (isteğe bağlı)
let lastUsedAlternatives = {};

function replaceWithAlternative(foodName, mealType) {
    // Değişiklikten önceki durumu kaydet
    saveState();

    // Mevcut yemeği bul
    const currentFood = findFood(foodName);
    if (!currentFood) {
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }

    // Makro fark aralığını kademeli olarak genişlet
    const tolerances = [0.1, 0.2, 0.3, 0.4, 0.5]; // %10, %20, %30, %40, %50
    let alternatives = [];

    for (const tolerance of tolerances) {
        categories.forEach(category => {
            if (category.name === currentFood.category) {
                category.items.forEach(item => {
                    if (item.name !== foodName && // Kendisi hariç
                        item.role === currentFood.role) { // Aynı rol
                        const proteinDiff = Math.abs(item.protein - currentFood.protein);
                        const fatDiff = Math.abs(item.fat - currentFood.fat);
                        const maxProteinDiff = currentFood.protein * tolerance;
                        const maxFatDiff = currentFood.fat * tolerance;

                        if (proteinDiff <= maxProteinDiff && fatDiff <= maxFatDiff) {
                            alternatives.push(item);
                        }
                    }
                });
            }
        });

        // Bu toleransta alternatif varsa döngüyü kır
        if (alternatives.length > 0) {
            break;
        }
    }

    if (alternatives.length === 0) {
        showNotification("Hiçbir makro aralığında uygun alternatif bulunamadı!", "warning");
        return;
    }

    // Önceki kullanılan alternatifi kontrol et
    const key = `${foodName}-${mealType}`;
    const lastAlternative = lastUsedAlternatives[key];

    // Önceki alternatif hariç birini seç
    let newFood;
    if (alternatives.length === 1) {
        newFood = alternatives[0]; // Tek alternatif varsa onu kullan
    } else {
        const availableAlternatives = lastAlternative
            ? alternatives.filter(alt => alt.name !== lastAlternative.name)
            : alternatives;
        if (availableAlternatives.length === 0) {
            newFood = alternatives[0]; // Tüm alternatifler kullanıldıysa rastgele birini seç
        } else {
            newFood = availableAlternatives[Math.floor(Math.random() * availableAlternatives.length)];
        }
    }

    // Yeni alternatifi kaydet
    lastUsedAlternatives[key] = newFood;

    // Öğünde yemeği değiştir
    const weekIndex = selectedWeek - 1;
    const dayMeals = weeks[weekIndex].days[selectedDay].meals[mealType];
    const foodIndex = dayMeals.findIndex(meal => meal.name === foodName);
    if (foodIndex !== -1) {
        dayMeals[foodIndex] = {
            name: newFood.name,
            quantity: dayMeals[foodIndex].quantity || 1, // Mevcut miktarı koru
        };
    }
    // Arayüzü güncelle
    renderMeals();
    calculateMacros();
    showNotification(`${foodName}, ${newFood.name} ile değiştirildi!`, "success");
}

function findAppliedRule(meal, mealType) {
    if (!rules || !Array.isArray(rules) || rules.length === 0) {
        console.log("Kural dizisi boş veya tanımlı değil:", rules);
        return { appliedRule: null, conflictingRules: [] };
    }

    const mealNameLower = meal.name.toLowerCase();
    const mealTags = (meal.tags || []).map(tag => tag.toLowerCase());
    const mealCategory = (meal.category || '').toLowerCase();
    const mealRole = (meal.role || '').toLowerCase();

    // Mevcut öğün verilerini al
    const currentDayMeals = weeks[selectedWeek - 1].days[selectedDay].meals;
    const currentMealItems = currentDayMeals[mealType].map(item => item.name.toLowerCase());

    // Kural türlerine göre hiyerarşi
    const typeHierarchy = {
        'dependOn': 1,      // Highest priority
        'compatibility': 2,
        'frequency': 3      // Lowest priority
    };

    let matchedRules = [];

    for (const rule of rules) {
        console.log(`Kural ${rule.id} kontrol ediliyor:`, rule);

        // dependOn kuralı
        if (rule.type === 'dependOn') {
            const ruleFoodLower = rule.food?.toLowerCase() || '';
            const requiredFoodLower = rule.requiredFood?.toLowerCase() || '';
            if (ruleFoodLower === mealNameLower && 
                currentMealItems.some(item => item.includes(requiredFoodLower))) {
                console.log(`Kural ${rule.id} (dependOn) eşleşti: ${meal.name} -> ${rule.requiredFood} (${mealType})`);
                matchedRules.push(rule);
            }
        }

        // frequency kuralı
        if (rule.type === 'frequency') {
            const matchesName = rule.nameCheck && rule.names?.length > 0 && 
                rule.names.some(name => mealNameLower.includes(name.toLowerCase()));
            const matchesTags = rule.tagsCheck && rule.tags?.length > 0 && 
                mealTags.some(tag => rule.tags.map(t => t.toLowerCase()).includes(tag));
            const matchesRole = rule.roleCheck && rule.role && 
                mealRole === rule.role.toLowerCase();
            const matchesCategory = rule.catCheck && rule.category && 
                mealCategory === rule.category.toLowerCase();
            const matchesMealType = rule.mealTypeCheck && rule.mealType && 
                mealType === rule.mealType;

            const matchesConditions = matchesName || matchesTags || matchesRole || matchesCategory;
            if (matchesConditions && (!rule.mealTypeCheck || matchesMealType)) {
                console.log(`Kural ${rule.id} (frequency) eşleşti: ${meal.name} (${mealType})`);
                matchedRules.push(rule);
            }
        }

        // compatibility kuralı
        if (rule.type === 'compatibility') {
            const keyword1Lower = rule.keyword1?.toLowerCase() || '';
            const keyword2List = (rule.keyword2 || []).map(kw => kw.toLowerCase());
            if (mealNameLower.includes(keyword1Lower)) {
                if (rule.conjunction === 'and') {
                    const anyKeyword2Match = currentMealItems.some(item => 
                        keyword2List.some(kw => item.includes(kw)));
                    if (anyKeyword2Match) {
                        console.log(`Kural ${rule.id} (compatibility - and) eşleşti: ${meal.name} (${mealType})`);
                        matchedRules.push(rule);
                    }
                } else if (rule.conjunction === 'or') {
                    const anyKeyword2Match = keyword2List.some(kw => mealNameLower.includes(kw));
                    if (anyKeyword2Match) {
                        console.log(`Kural ${rule.id} (compatibility - or) eşleşti: ${meal.name} (${mealType})`);
                        matchedRules.push(rule);
                    }
                }
            }
        }
    }

    if (matchedRules.length === 0) {
        console.log(`Hiçbir kural eşleşmedi: ${meal.name} (${mealType})`);
        return { appliedRule: null, conflictingRules: [] };
    }

    // Sort rules by hierarchy and then priority
    matchedRules.sort((a, b) => {
        const hierarchyA = typeHierarchy[a.type] || 999;
        const hierarchyB = typeHierarchy[b.type] || 999;
        if (hierarchyA !== hierarchyB) {
            return hierarchyA - hierarchyB;  // Lower hierarchy value wins
        }
        return (a.priority || 999) - (b.priority || 999);  // Lower priority value wins
    });

    // Select the most important rule and list conflicts
    const appliedRule = matchedRules[0];
    const conflictingRules = matchedRules.slice(1);

    console.log(`Uygulanan kural: ${appliedRule?.id}, Çakışan kurallar: ${conflictingRules.map(r => r.id).join(', ')}`);
    return { appliedRule, conflictingRules };
}


function deleteFoodFromSystem(foodName) {
  console.log("deleteFoodFromSystem başladı, silinecek yemek:", foodName);
  if (!confirm(`"${foodName}" yemeğini sistemden silmek istiyor musunuz?`)) return;

  // İşlemden önce mevcut durumu kaydet (undo için)
  if (typeof saveState === 'function') {
    saveState();
  }

  // 1. LocalStorage'daki tüm kategorilerden kaldır
  let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
  console.log("Mevcut food_list:", storedFoodList);
  for (const cat in storedFoodList) {
    storedFoodList[cat] = storedFoodList[cat].filter(f => f.name !== foodName);
  }
  localStorage.setItem("food_list", JSON.stringify(storedFoodList));
  console.log("Güncellenmiş food_list:", storedFoodList);

  // 2. Global categories dizisinden kaldır (opsiyonel, varsa çalışır)
  if (typeof categories !== 'undefined' && Array.isArray(categories)) {
    console.log("Mevcut categories:", categories);
    categories.forEach(category => {
      if (category.items && Array.isArray(category.items)) {
        category.items = category.items.filter(item => item.name !== foodName);
      }
    });
    console.log("Güncellenmiş categories:", categories);
  } else {
    console.log("categories tanımlı değil, bu adım atlanıyor.");
  }

  // 3. Sağ paneldeki öğünlerden kaldır (weeks veya allData kontrolü)
  let dataSource = typeof weeks !== 'undefined' ? weeks : (typeof allData !== 'undefined' ? allData : null);
  console.log("Kullanılan veri kaynağı:", dataSource);
  if (dataSource && Array.isArray(dataSource)) {
    for (const week of dataSource) {
      if (week.days && typeof week.days === 'object') {
        for (const day in week.days) {
          if (week.days[day].meals && typeof week.days[day].meals === 'object') {
            for (const mealType in week.days[day].meals) {
              if (Array.isArray(week.days[day].meals[mealType])) {
                week.days[day].meals[mealType] = week.days[day].meals[mealType].filter(m => m.name !== foodName);
              }
            }
          }
        }
      }
    }
    console.log("Güncellenmiş veri kaynağı:", dataSource);
  } else {
    console.log("Veri kaynağı (weeks veya allData) tanımlı değil, öğünler güncellenemedi.");
  }

  // 4. Görünümü yeniden çiz (fonksiyonlar varsa çalışır)
  if (typeof loadCategories === 'function') {
    console.log("loadCategories çağrılıyor...");
    loadCategories();
  } else {
    console.log("loadCategories fonksiyonu tanımlı değil.");
  }

  if (typeof renderMeals === 'function') {
    console.log("renderMeals çağrılıyor...");
    renderMeals();
  } else {
    console.log("renderMeals fonksiyonu tanımlı değil.");
  }

  if (typeof searchEditFood === 'function') {
    console.log("searchEditFood çağrılıyor...");
    searchEditFood('');
  } else {
    console.log("searchEditFood fonksiyonu tanımlı değil.");
  }

  // 5. Grafikleri güncelle
  if (typeof calculateMacros === 'function') {
    console.log("calculateMacros çağrılıyor...");
    calculateMacros();
  } else {
    console.log("calculateMacros fonksiyonu tanımlı değil.");
  }

  // 6. Bildirim göster (durumu tekrar kaydetmeye gerek yok, applyState zaten bunu yapacak)
  if (typeof showNotification === 'function') {
    showNotification(`"${foodName}" sistemden tamamen silindi.`, "success");
  }
  console.log("deleteFoodFromSystem tamamlandı.");
}

function updateMealQuantityFromDOM(input) {
    if (typeof saveState === 'function') {
        saveState();
    }

    const itemRow = input.closest('.meal-item');
    const foodName = itemRow.getAttribute('data-name');
    const mealType = itemRow.getAttribute('data-meal');
    const day = itemRow.getAttribute('data-day');
    const week = itemRow.getAttribute('data-week');

    let newQuantity = parseFloat(input.value);
    const food = findFood(foodName);

    if (!food) {
        console.warn("Yemek bulunamadı:", foodName);
        return;
    }

    // Sınırları kontrol et
    const minQuantity = food.minQuantity || 0.1;
    const maxQuantity = food.maxQuantity || 10;
    const currentQuantity = parseFloat(input.getAttribute('value')) || minQuantity;

    // Yuvarlama: Sadece artırırken uygula
    const isIncreasing = newQuantity > currentQuantity;
    newQuantity = roundQuantity(newQuantity, isIncreasing);

    // Sınırlara uydur
    if (newQuantity < minQuantity) {
        newQuantity = minQuantity;
    } else if (newQuantity > maxQuantity) {
        newQuantity = maxQuantity;
    }

    const mealList = weeks[week].days[day].meals[mealType];
    const item = mealList.find(f => f.name === foodName);

    if (item) {
        item.quantity = newQuantity;
        input.value = newQuantity; // Input’u senkronize et
        renderMeals();
        if (typeof calculateMacros === 'function') {
            calculateMacros();
        }
        if (typeof showNotification === 'function') {
            const unit = ['dilim', 'kase', 'bardak', 'yemek', 'porsiyon', 'adet', 'tatlı kaşığı', 'çorba kaşığı', 'tabak', 'fincan', 'yaprak', 'yemek kaşığı', 'gram', 'kare']
                .find(u => foodName.toLowerCase().includes(u)) || 'porsiyon';
            showNotification(`Miktar güncellendi: ${formatQuantityWithText(`${newQuantity} ${unit}`)}`, 'success');
        }
    } else {
        console.warn("Yemek bulunamadı:", foodName);
    }
}

function roundQuantity(quantity, isIncreasing = false) {
    // 0.5 ve 0.25 için özel durum
    if (quantity === 0.5 || quantity === 0.25) return quantity;
    
    // Sadece artırırken yuvarla
    if (isIncreasing && quantity % 1 !== 0) {
        return Math.ceil(quantity);
    }
    
    // Azaltırken veya tam sayıysa direkt dön
    return quantity;
}
function editMealItemFromDOM(button) {
    const item = button.closest('.meal-item');
    const foodName = item.getAttribute('data-name');
    editFood(foodName); // mevcut editFood() fonksiyonunu çağırabiliriz
}


function deleteMealItemFromDOM(button) {
    updateCaloriesInPopup();
    saveState(); // Silmeden önce durumu kaydet
    const item = button.closest('.meal-item');
    const foodName = item.getAttribute('data-name');
    const mealType = item.getAttribute('data-meal');
    const day = item.getAttribute('data-day'); // düzeltildi
    const week = parseInt(item.getAttribute('data-week'));

    const mealList = weeks[week].days[day].meals[mealType];
    const index = mealList.findIndex(m => m.name === foodName);
    if (index !== -1) {
        mealList.splice(index, 1);
        renderMeals();
        calculateMacros();
        showNotification("Yemek silindi!");
    }
}




// Yemeği bulma fonksiyonu
function findFood(name) {
    const normalizedName = name.toLowerCase().trim();
    for (const category of categories) {
        for (const item of category.items) {
            const itemName = item.name.toLowerCase().trim();
            if (itemName === normalizedName) {
                item.category = category.name; // Kategori bilgisini ekle
                return item;
            }
        }
    }
    // Esnek eşleşme: Eğer tam eşleşme bulunamazsa, isim içinde geçen bir eşleşme ara
    for (const category of categories) {
        for (const item of category.items) {
            const itemName = item.name.toLowerCase().trim();
            if (itemName.includes(normalizedName) || normalizedName.includes(itemName)) {
                item.category = category.name; // Kategori bilgisini ekle
                console.log(`Esnek eşleşme bulundu: ${item.name} (${category.name})`);
                return item;
            }
        }
    }
    return null;
}

function updateMealQuantity(mealType, index, value) {
    saveState(); // Değişiklikten önce durumu kaydet
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType][index].quantity = parseFloat(value);
    renderMeals();
    calculateMacros();
}

function deleteMealItem(mealType, index) {
    saveState(); // Silmeden önce durumu kaydet
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType].splice(index, 1);
    renderMeals();
    calculateMacros();
    showNotification("Yemek silindi!");
}

function editMealItem(mealType, index) {
    const foodItem = weeks[selectedWeek - 1].days[selectedDay].meals[mealType][index];
    const food = findFood(foodItem.name);
    if (!food) return;

    const panel = document.getElementById('editFoodPanel');
    document.getElementById('editFoodIndex').value = `${mealType}_${index}`;
    document.getElementById('editFoodOriginalName').value = foodItem.name;
    document.getElementById('editFoodName').value = foodItem.name;
    document.getElementById('editFoodCalories').value = food.calories;
    document.getElementById('editFoodProtein').value = food.protein;
    document.getElementById('editFoodCarbs').value = food.carbs;
    document.getElementById('editFoodFat').value = food.fat;
    document.getElementById('editFoodMaxQuantity').value = food.maxQuantity;
    document.getElementById('editFoodMinQuantity').value = food.minQuantity || 0.5;
    document.getElementById('editFoodRole').value = food.role;
    document.getElementById('editFoodTags').value = food.tags.join(', ');
    document.getElementById('editFoodMealType').value = food.mealType;
    document.getElementById('editFoodKeto').checked = food.keto;
    document.getElementById('editFoodLowCarb').checked = food.lowcarb;
    panel.style.display = 'block';
}

// Yemek düzenleme ve kaydetme fonksiyonu
function saveEditedFood(event) {
    event.preventDefault();
    saveState();

    const originalName = document.getElementById('editFoodOriginalName').value;
    const updatedFood = {
        name: document.getElementById('editFoodName').value.trim() || originalName,
        calories: parseFloat(document.getElementById('editFoodCalories').value) || 0,
        protein: parseFloat(document.getElementById('editFoodProtein').value) || 0,
        carbs: parseFloat(document.getElementById('editFoodCarbs').value) || 0,
        fat: parseFloat(document.getElementById('editFoodFat').value) || 0,
        maxQuantity: parseFloat(document.getElementById('editFoodMaxQuantity').value) || 1,
        minQuantity: parseFloat(document.getElementById('editFoodMinQuantity').value) || 0.5,
        step: parseFloat(document.getElementById('editFoodStep').value) || 0.5,
        role: document.getElementById('editFoodRole').value || 'mainDish',
        tags: document.getElementById('editFoodTags').value.split(',').map(t => t.trim()).filter(t => t) || [],
        mealType: document.getElementById('editFoodMealType').value.split(',').map(t => t.trim()).filter(t => t) || [],
        keto: document.getElementById('editFoodKeto').checked,
        lowcarb: document.getElementById('editFoodLowCarb').checked,
        fillerLunch: document.getElementById('editFoodFillerLunch').checked,
        fillerDinner: document.getElementById('editFoodFillerDinner').checked,
        season: document.getElementById('editFoodSeason').value || '4 mevsim',
        portionFixed: document.getElementById('editFoodPortionFixed').checked,
        multiplier: parseFloat(document.getElementById('editFoodMultiplier').value) || 1
    };

    const food = findFood(originalName);
    if (!food || !food.category) {
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }

    // Mevcut yemeği güncelle
    Object.assign(food, updatedFood);

    // Kategoriye taşıma işlemi
    const newCategory = document.getElementById('editFoodMoveToCategory').value;
    if (newCategory && newCategory !== food.category) {
        const oldCategory = categories.find(cat => cat.name === food.category);
        if (oldCategory) {
            oldCategory.items = oldCategory.items.filter(item => item.name !== originalName);
            const targetCategory = categories.find(cat => cat.name === newCategory);
            if (targetCategory) {
                targetCategory.items.push(food);
                food.category = newCategory;
            }
        }
    }

    // Öğün verisindeki katsayıları kontrol et ve yeni maxQuantity’ye uydur
    weeks.forEach((week, wIndex) => {
        Object.values(week.days).forEach(day => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                if (day.meals[mealType]) {
                    day.meals[mealType].forEach(item => {
                        if (item.name === updatedFood.name && item.quantity > updatedFood.maxQuantity) {
                            item.quantity = updatedFood.maxQuantity;
                        }
                    });
                }
            });
        });
    });

    closeEditFoodPanel();
    loadCategories();
    renderMeals();
    calculateMacros();
    showNotification(`"${updatedFood.name}" yemeği güncellendi!`, "success");
}
        function calculateWeeklyAverages() {
    const week = weeks[selectedWeek - 1];
    const weeklyTotals = {
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0
    };
    let dayCount = 0;

    // Haftanın tüm günlerini dolaş
    Object.values(week.days).forEach(day => {
        const dayMeals = day.meals;
        Object.values(dayMeals).forEach(meal => {
            meal.forEach(item => {
                const food = findFood(item.name);
                if (food) {
                    const quantity = item.quantity || 1;
                    weeklyTotals.calories += food.calories * quantity;
                    weeklyTotals.protein += food.protein * quantity;
                    weeklyTotals.carbs += food.carbs * quantity;
                    weeklyTotals.fat += food.fat * quantity;
                }
            });
        });
        dayCount++;
    });

    // Ortalamaları hesapla (7 güne böl), string yerine sayı döndür
    return {
        calories: dayCount > 0 ? weeklyTotals.calories / 7 : 0,
        protein: dayCount > 0 ? weeklyTotals.protein / 7 : 0,
        carbs: dayCount > 0 ? weeklyTotals.carbs / 7 : 0,
        fat: dayCount > 0 ? weeklyTotals.fat / 7 : 0
    };
}
function generateAnalysisText(type, day, actualValues, targetValues, weeklyData = null) {
    const isKeto = true; // Varsayılan olarak ketojenik beslenme (kullanıcı ayarı eklenebilir)
    const dietType = isKeto ? "ketojenik" : "low-carb";
    const carbLimit = isKeto ? 30 : 70; // Ketojenik için 30g, low-carb için 70g sınır

    // Değer farklarını hesapla
    const diffs = {
        calories: actualValues.calories - targetValues.calories,
        fat: actualValues.fat - targetValues.fat,
        protein: actualValues.protein - targetValues.protein,
        carbs: actualValues.carbs - targetValues.carbs
    };

    // Günlük veya haftalık metni oluştur
    let title, status, highlights, evaluation, suggestions;

    if (type === "daily") {
        title = `<h4>Günlük Makro Analizi (${day})</h4>`;
        status = `
            <p>Kalori: ${actualValues.calories.toFixed(0)} kcal (Hedef: ${targetValues.calories.toFixed(0)} kcal, ${diffs.calories > 0 ? '+' : ''}${diffs.calories.toFixed(0)} kcal ${diffs.calories >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Yağ: ${actualValues.fat.toFixed(0)} g (Hedef: ${targetValues.fat.toFixed(0)} g, ${diffs.fat > 0 ? '+' : ''}${diffs.fat.toFixed(0)} g ${diffs.fat >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Protein: ${actualValues.protein.toFixed(0)} g (Hedef: ${targetValues.protein.toFixed(0)} g, ${diffs.protein > 0 ? '+' : ''}${diffs.protein.toFixed(0)} g ${diffs.protein >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Karbonhidrat: ${actualValues.carbs.toFixed(0)} g (Hedef: ${targetValues.carbs.toFixed(0)} g, ${diffs.carbs > 0 ? '+' : ''}${diffs.carbs.toFixed(0)} g ${diffs.carbs >= 0 ? 'üstünde' : 'altında'})</p>
        `;

        // Değerlendirme
        evaluation = "<p><strong>Değerlendirme:</strong><br>";
        if (isKeto) {
            evaluation += `Harika bir iş çıkarıyorsun! Karbonhidrat alımını ${actualValues.carbs.toFixed(0)} g’da tutarak ketozis sürecini desteklemeye devam ediyorsun, bu ${dietType} beslenme için mükemmel bir seviye. `;
            if (diffs.protein > 0) {
                evaluation += `Protein hedefini ${diffs.protein.toFixed(0)} g aşmışsın, bu da kaslarını desteklemek için harika. `;
            } else {
                evaluation += `Protein alımın hedefin ${Math.abs(diffs.protein).toFixed(0)} g altında, kas kütleni desteklemek için biraz artırabilirsin. `;
            }
            if (diffs.calories < 0 || diffs.fat < 0) {
                evaluation += `Ancak kalori ve yağ alımın hedefin altında kalmış, bu da gün içinde enerjini düşürebilir.`;
            } else {
                evaluation += `Kalori ve yağ alımın dengeli, ketozis sürecin harika bir şekilde destekleniyor!`;
            }
        } else {
            evaluation += `Çok iyi gidiyorsun! Karbonhidrat alımını ${actualValues.carbs.toFixed(0)} g’da tutarak ${dietType} beslenmenin sınırları içinde kalmayı başarmışsın, bu koruma modun için harika bir denge. `;
            if (diffs.fat > 0 && diffs.protein > 0) {
                evaluation += `Yağ ve protein hedeflerini aşmışsın, bu da enerji seviyeni desteklemek için olumlu. `;
            }
            if (diffs.calories < 0) {
                evaluation += `Kalori hedefin ${Math.abs(diffs.calories).toFixed(0)} kcal altında, bu uzun vadede enerjini etkileyebilir.`;
            } else {
                evaluation += `Kalori alımın dengeli, harika bir denge yakalamışsın!`;
            }
        }
        evaluation += "</p>";

        // Öneriler
        suggestions = "<p><strong>Öneriler:</strong><br>";
        if (diffs.calories < 0) {
            suggestions += `- Kalori açığını kapatmak için ${isKeto ? 'sağlıklı yağ kaynaklarına yönelebilirsin. Örneğin, öğünlerine biraz daha avokado, zeytinyağı veya hindistancevizi yağı eklemek hem kalorini artırır hem de ketozis sürecini destekler.' : 'karbonhidratı artırmadan sağlıklı yağlar ve protein kaynakları ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı yoğurt eklemek harika bir seçenek.'} `;
        }
        if (diffs.fat < 0) {
            suggestions += `- Yağ alımın ${dietType} beslenme için biraz düşük kalmış. Öğünlerine daha fazla sağlıklı yağ ekleyerek ${isKeto ? 'ketozis sürecini destekleyebilirsin' : 'enerji seviyeni destekleyebilirsin'}. Örneğin, salatalarına zeytinyağı veya yemeklerine avokado eklemeyi deneyebilirsin. `;
        }
        if (diffs.protein < 0) {
            suggestions += `- Protein alımın kas kütleni desteklemek için biraz düşük kalmış. Öğünlerine daha fazla protein eklemek için haşlanmış yumurta, ızgara tavuk veya tam yağlı yoğurt gibi seçenekler deneyebilirsin. `;
        }
        if (diffs.carbs > (isKeto ? 30 : 70)) {
            suggestions += `- Karbonhidrat alımın ${dietType} için biraz yüksek kalmış. Bir sonraki öğünde karbonhidratı daha düşük tutarak ${isKeto ? 'ketozis sürecini destekleyebilirsin' : 'dengenizi sağlayabilirsin'}. Örneğin, karbonhidrat yerine daha fazla yeşil sebze (ıspanak, brokoli) tercih edebilirsin. `;
        }
        suggestions += `Hedefine çok yakınsın, böyle devam et!</p>`;
    } else {
        // Haftalık analiz
        title = `<h4>Haftalık Makro Trend Analizi</h4>`;
        status = `
            <p>Ortalama Kalori: ${actualValues.calories.toFixed(0)} kcal (Hedef: ${targetValues.calories.toFixed(0)} kcal, ${diffs.calories > 0 ? '+' : ''}${diffs.calories.toFixed(0)} kcal ${diffs.calories >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Yağ: ${actualValues.fat.toFixed(0)} g (Hedef: ${targetValues.fat.toFixed(0)} g, ${diffs.fat > 0 ? '+' : ''}${diffs.fat.toFixed(0)} g ${diffs.fat >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Protein: ${actualValues.protein.toFixed(0)} g (Hedef: ${targetValues.protein.toFixed(0)} g, ${diffs.protein > 0 ? '+' : ''}${diffs.protein.toFixed(0)} g ${diffs.protein >= 0 ? 'üstünde' : 'altında'})</p>
            <p>Ortalama Karbonhidrat: ${actualValues.carbs.toFixed(0)} g (Hedef: ${targetValues.carbs.toFixed(0)} g, ${diffs.carbs > 0 ? '+' : ''}${diffs.carbs.toFixed(0)} g ${diffs.carbs >= 0 ? 'üstünde' : 'altında'})</p>
        `;

        // Öne çıkanlar (haftalık verilerden analiz)
        highlights = "<p><strong>Öne Çıkanlar:</strong><br>";
        let maxCarbDay = { day: '', value: 0 };
        let minCalorieDay = { day: '', value: Infinity };
        let maxProteinDay = { day: '', value: 0 };

        const days = ['Pazartesi', 'Salı', 'Çarşamba', 'Perşembe', 'Cuma', 'Cumartesi', 'Pazar'];
        days.forEach((day, index) => {
            const dayData = weeklyData[index];
            if (dayData) {
                if (dayData.carbs > maxCarbDay.value) maxCarbDay = { day, value: dayData.carbs };
                if (dayData.calories < minCalorieDay.value) minCalorieDay = { day, value: dayData.calories };
                if (dayData.protein > maxProteinDay.value) maxProteinDay = { day, value: dayData.protein };
            }
        });

        if (maxCarbDay.value > carbLimit) {
            highlights += `- ${maxCarbDay.day} günü karbonhidrat ${maxCarbDay.value.toFixed(0)} g’a çıkmış, bu ${dietType} sınırını biraz aşmış olabilir.<br>`;
        }
        if (minCalorieDay.value < targetValues.calories) {
            highlights += `- ${minCalorieDay.day} günü kalori hedefin oldukça altında kalmış (${minCalorieDay.value.toFixed(0)} kcal, ${(minCalorieDay.value - targetValues.calories).toFixed(0)} kcal).<br>`;
        }
        if (maxProteinDay.value > targetValues.protein) {
            highlights += `- Protein alımın haftanın her günü hedefin üstünde, özellikle ${maxProteinDay.day} günü %${((maxProteinDay.value / targetValues.protein) * 100).toFixed(0)}’ye ulaşmış (${maxProteinDay.value.toFixed(0)} g).`;
        }
        highlights += "</p>";

        // Değerlendirme
        evaluation = "<p><strong>Değerlendirme:</strong><br>";
        if (isKeto) {
            evaluation += `Ketozis sürecini desteklemek için karbonhidratı ${actualValues.carbs.toFixed(0)} g’ın altında tutmayı başarmışsın, bu harika bir başarı! `;
            if (diffs.calories < 0 || diffs.fat < 0) {
                evaluation += `Yağ ve kalori alımın ise haftalık ortalamada hedefin biraz altında kalmış, bu da bazı günlerde enerjini etkilemiş olabilir. `;
            }
            if (diffs.protein > 0) {
                evaluation += `Protein alımın kas kütleni desteklemek için mükemmel bir seviyede.`;
            }
        } else {
            evaluation += `Low-carb beslenmende harika bir denge yakalamışsın! Karbonhidratı genelde ${carbLimit} g’ın altında tutmayı başarmışsın, ancak ${maxCarbDay.day} günü hafif bir aşım olmuş, bu dikkat gerektirebilir. `;
            if (diffs.calories < 0) {
                evaluation += `Kalori alımın haftalık ortalamada hedefin ${Math.abs(diffs.calories).toFixed(0)} kcal altında, bu da bazı günlerde enerjini etkilemiş olabilir. `;
            }
            if (diffs.fat > 0 && diffs.protein > 0) {
                evaluation += `Yağ ve protein alımın ise hedefin üstünde, bu da enerji seviyeni desteklemek için olumlu.`;
            }
        }
        evaluation += "</p>";

        // Öneriler
        suggestions = "<p><strong>Öneriler:</strong><br>";
        if (maxCarbDay.value > carbLimit) {
            suggestions += `- ${maxCarbDay.day} gibi karbonhidratın yükseldiği günleri dengelemek için düşük glisemik indeksli seçeneklere odaklanabilirsin. Örneğin, karbonhidratı artırmak yerine daha fazla yeşil sebze (ıspanak, kabak) tercih edebilirsin. `;
        }
        if (diffs.calories < 0) {
            suggestions += `- Kalori açığını kapatmak için ${isKeto ? 'sağlıklı yağlar ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı peynir eklemek hem kalorini artırır hem de ketozis sürecini destekler.' : 'karbonhidratı artırmadan sağlıklı yağlar ve protein kaynakları ekleyebilirsin. Örneğin, bir öğüne somon veya tam yağlı peynir eklemek hem kalorini artırır hem de low-carb sınırlarını korur.'} `;
        }
        suggestions += `Harika bir hafta geçirmişsin, bu dengeyi koruyarak devam et!</p>`;
    }

    // Sorumluluk reddi
    const disclaimer = `
        <p class="disclaimer"><strong>Sorumluluk Reddi:</strong><br>
        Bu analiz ve öneriler, genel bilgilendirme ve motivasyon amaçlı hazırlanmıştır. Beslenme planınızı oluştururken veya değişiklik yaparken, özellikle bir sağlık sorununuz varsa, öncelikle doktorunuza veya bir diyetisyene danışmanız önemlidir. Her bireyin sağlık durumu, metabolizması ve ihtiyaçları farklıdır; bu nedenle, önerilerimiz sizin için uygun olmayabilir. Sağlıklı bir yaşam tarzı için profesyonel bir uzmandan destek almayı unutmayın.</p>
    `;

    return `${title}${status}${type === "weekly" ? highlights : ""}${evaluation}${suggestions}${disclaimer}`;
}

function calculateMacros() {
    console.log("Makrolar hesaplanıyor...");
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    const weight = patientData.weight || 70;
    const activityLevel = patientData.activity || 3;
    const bmr = 10 * weight + 6.25 * 175 - 5 * 30 + 5;
    const activityMultiplier = [0.8, 0.9, 1.0, 1.1, 1.2][activityLevel - 1];
    const tdee = bmr * activityMultiplier;

    const carbMultiplier = parseFloat(document.getElementById('carbMultiplier').value) || 0.5;
    const proteinMultiplier = parseFloat(document.getElementById('proteinMultiplier').value) || 2;
    const fatMultiplier = parseFloat(document.getElementById('fatMultiplier').value) || 0.8;

    const targetCarbs = weight * carbMultiplier * activityMultiplier;
    const targetProtein = weight * proteinMultiplier * activityMultiplier;
    const targetFat = weight * fatMultiplier * activityMultiplier;
    const targetCalories = targetCarbs * 4 + targetProtein * 4 + targetFat * 9;

    globalTargetCalories = targetCalories;
    globalTargetProtein = targetProtein;
    globalTargetCarbs = targetCarbs;
    globalTargetFat = targetFat;

    console.log(`Makro Hedefleri Güncellendi - Hasta: ${currentPatient || 'Varsayılan'}, Kalori: ${targetCalories.toFixed(0)}, Protein: ${targetProtein.toFixed(0)}, Karb: ${targetCarbs.toFixed(0)}, Yağ: ${targetFat.toFixed(0)}`);

    document.getElementById('bmrDisplay').value = bmr.toFixed(0);
    document.getElementById('targetCalories').value = targetCalories.toFixed(0);
    document.getElementById('targetProtein').value = targetProtein.toFixed(0);
    document.getElementById('targetCarbs').value = targetCarbs.toFixed(0);
    document.getElementById('targetFat').value = targetFat.toFixed(0);

    const weekIndex = selectedWeek ? Math.max(0, selectedWeek - 1) : 0;
    const day = selectedDay || "monday";

    if (!weeks[weekIndex] || !weeks[weekIndex].days[day]) {
        console.warn(`calculateMacros: Hafta ${weekIndex + 1} veya gün ${day} tanımsız!`, weeks);
        return;
    }

    const dayMeals = weeks[weekIndex].days[day].meals;
    const totals = {
        calories: 0,
        protein: 0,
        carbs: 0,
        fat: 0
    };

    Object.values(dayMeals).forEach(meal => {
        meal.forEach(item => {
            const food = findFood(item.name);
            if (food) {
                const quantity = item.quantity || 1;
                totals.calories += food.calories * quantity;
                totals.protein += food.protein * quantity;
                totals.carbs += food.carbs * quantity;
                totals.fat += food.fat * quantity;
            }
        });
    });

    const proteinSapma = Math.abs(totals.protein - targetProtein) / targetProtein;
    const fatSapma = Math.abs(totals.fat - targetFat) / targetFat;
    let proteinStatus = proteinSapma <= 0.05 ? "±%5 içinde" : proteinSapma <= 0.10 ? "±%10 içinde" : `${(proteinSapma * 100).toFixed(1)}% saptı`;
    let fatStatus = fatSapma <= 0.05 ? "±%5 içinde" : fatSapma <= 0.10 ? "±%10 içinde" : `${(fatSapma * 100).toFixed(1)}% saptı`;
    let oneriler = [];

    if (proteinSapma > 0.05) {
        if (totals.protein < targetProtein) {
            oneriler.push("Protein eksik, öğleye hindi füme gibi yüksek proteinli bir yemek ekle.");
        } else {
            oneriler.push("Protein fazla, öğlede yüksek proteinli bir yemeğin katsayısını azalt veya sebze ekle.");
        }
    }
    if (fatSapma > 0.05) {
        if (totals.fat < targetFat) {
            oneriler.push("Yağ eksik, akşama zeytinyağı gibi yüksek yağlı bir yemek ekle.");
        } else {
            oneriler.push("Yağ fazla, akşamda yüksek yağlı bir yemeğin katsayısını azalt veya sebze ekle.");
        }
    }

    if (typeof showNotification === 'function') {
        showNotification(
            `Protein: ${totals.protein.toFixed(0)}/${targetProtein.toFixed(0)} (${proteinStatus})\n` +
            `Yağ: ${totals.fat.toFixed(0)}/${targetFat.toFixed(0)} (${fatStatus})\n` +
            (oneriler.length > 0 ? `Öneriler: ${oneriler.join(" ")}` : ""),
            proteinSapma > 0.10 || fatSapma > 0.10 ? "warning" : "success",
            5000
        );
    }

    const flexibility = parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1;
    const macroTotals = document.getElementById('macroTotals');
    const weeklyAverages = calculateWeeklyAverages();

    macroTotals.innerHTML = `
        <tr>
            <th>Makro</th>
            <th>Hedef</th>
            <th>Günlük (${day})</th>
            <th>Fark</th>
            <th>Haftalık Ortalama (Fark)</th>
        </tr>
        <tr class="${totals.calories > targetCalories * (1 + flexibility) ? 'macro-exceed' : totals.calories < targetCalories * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Kalori</td>
            <td>${targetCalories.toFixed(0)}</td>
            <td>${totals.calories.toFixed(0)}</td>
            <td>${(totals.calories - targetCalories).toFixed(0)}</td>
            <td>${weeklyAverages.calories.toFixed(0)} (${(weeklyAverages.calories - targetCalories).toFixed(0)})</td>
        </tr>
        <tr class="${totals.protein > targetProtein * (1 + flexibility) ? 'macro-exceed' : totals.protein < targetProtein * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Protein</td>
            <td>${targetProtein.toFixed(0)}</td>
            <td>${totals.protein.toFixed(0)}</td>
            <td>${(totals.protein - targetProtein).toFixed(0)}</td>
            <td>${weeklyAverages.protein.toFixed(0)} (${(weeklyAverages.protein - targetProtein).toFixed(0)})</td>
        </tr>
        <tr class="${totals.carbs > targetCarbs * (1 + flexibility) ? 'macro-exceed' : totals.carbs < targetCarbs * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Karb.</td>
            <td>${targetCarbs.toFixed(0)}</td>
            <td>${totals.carbs.toFixed(0)}</td>
            <td>${(totals.carbs - targetCarbs).toFixed(0)}</td>
            <td>${weeklyAverages.carbs.toFixed(0)} (${(weeklyAverages.carbs - targetCarbs).toFixed(0)})</td>
        </tr>
        <tr class="${totals.fat > targetFat * (1 + flexibility) ? 'macro-exceed' : totals.fat < targetFat * (1 - flexibility) ? 'macro-low' : ''}">
            <td>Yağ</td>
            <td>${targetFat.toFixed(0)}</td>
            <td>${totals.fat.toFixed(0)}</td>
            <td>${(totals.fat - targetFat).toFixed(0)}</td>
            <td>${weeklyAverages.fat.toFixed(0)} (${(weeklyAverages.fat - targetFat).toFixed(0)})</td>
        </tr>
    `;

    const macroDisplay = document.querySelector('.macro-display');
    if (macroDisplay) {
        const existingCharts = macroDisplay.querySelector('.macro-charts');
        if (existingCharts) {
            existingCharts.remove();
        }

        const chartsDiv = document.createElement('div');
        chartsDiv.className = 'macro-charts';
        chartsDiv.innerHTML = `
            <div class="chart-container">
                <h4>Günlük (${day})</h4>
                <canvas id="dailyMacroChart" width="150" height="150"></canvas>
            </div>
            <div class="chart-container">
                <h4>Haftalık Ortalama</h4>
                <canvas id="weeklyMacroChart" width="150" height="150"></canvas>
            </div>
        `;
        macroDisplay.appendChild(chartsDiv);
    }

    const targetValues = {
        calories: targetCalories,
        carbs: targetCarbs,
        protein: targetProtein,
        fat: targetFat
    };

    drawMacroChart('dailyMacroChart', {
        calories: totals.calories / targetCalories,
        carbs: totals.carbs / targetCarbs,
        protein: totals.protein / targetProtein,
        fat: totals.fat / targetFat
    }, totals, targetValues, `Günlük (${day})`);

    drawMacroChart('weeklyMacroChart', {
        calories: weeklyAverages.calories / targetCalories,
        carbs: weeklyAverages.carbs / targetCarbs,
        protein: weeklyAverages.protein / targetProtein,
        fat: weeklyAverages.fat / targetFat
    }, weeklyAverages, targetValues, 'Haftalık Ortalama');
}

function drawMacroChart(canvasId, data, actualValues = null, targetValues = null, title = '', type = 'daily', weeklyData = null) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) {
        console.error(`Canvas with ID ${canvasId} not found!`);
        return;
    }
    const ctx = canvas.getContext('2d');

    console.log(`Canvas ${canvasId} dimensions: ${canvas.width}x${canvas.height}`);

    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const maxRadius = canvas.width >= 300 ? 120 : canvas.width * 0.4;
    const ringWidth = canvas.width >= 300 ? 24 : canvas.width * 0.08;
    const gap = canvas.width >= 300 ? 2 : 1;

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const rings = [
        { name: 'Kalori', value: data.calories, actual: actualValues?.calories || 0, target: targetValues?.calories || 0, radius: maxRadius, color: 'rgba(40, 167, 69, 0.8)', excessColor: 'rgba(20, 120, 40, 0.8)' },
        { name: 'Yağ', value: data.fat, actual: actualValues?.fat || 0, target: targetValues?.fat || 0, radius: maxRadius - ringWidth - gap, color: 'rgba(255, 193, 7, 0.8)', excessColor: 'rgba(200, 150, 0, 0.8)' },
        { name: 'Protein', value: data.protein, actual: actualValues?.protein || 0, target: targetValues?.protein || 0, radius: maxRadius - 2 * (ringWidth + gap), color: 'rgba(0, 123, 255, 0.8)', excessColor: 'rgba(0, 80, 200, 0.8)' },
        { name: 'Karb.', value: data.carbs, actual: actualValues?.carbs || 0, target: targetValues?.carbs || 0, radius: maxRadius - 3 * (ringWidth + gap), color: 'rgba(220, 53, 69, 0.8)', excessColor: 'rgba(180, 30, 40, 0.8)' }
    ];

    function drawRing(context, value, radius, color, excessColor, centerX, centerY, ringWidth) {
        const startAngle = -Math.PI / 2;
        const maxAngle = 2 * Math.PI;
        let fillAngle = maxAngle * Math.min(value, 1);
        context.beginPath();
        context.arc(centerX, centerY, radius, startAngle, startAngle + fillAngle);
        context.lineWidth = ringWidth;
        context.strokeStyle = color;
        context.stroke();
        if (value > 1) {
            const excessAngle = maxAngle * (value - 1);
            context.beginPath();
            context.arc(centerX, centerY, radius, startAngle, startAngle + excessAngle);
            context.lineWidth = ringWidth;
            context.strokeStyle = excessColor;
            context.stroke();
        }
    }

    rings.forEach(ring => drawRing(ctx, ring.value, ring.radius, ring.color, ring.excessColor, centerX, centerY, ringWidth));

    if (!actualValues || !targetValues) {
        return;
    }

    let tooltip = document.getElementById(`${canvasId}-tooltip`);
    if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.id = `${canvasId}-tooltip`;
        tooltip.className = 'macro-tooltip';
        document.body.appendChild(tooltip);
    }

    const addTooltipListeners = (targetCanvas, targetRings, targetCenterX, targetCenterY, targetRingWidth) => {
        targetCanvas.addEventListener('mousemove', (e) => {
            const rect = targetCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const dx = x - targetCenterX;
            const dy = y - targetCenterY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            let activeRing = null;
            for (const ring of targetRings) {
                const outerRadius = ring.radius + targetRingWidth / 2;
                const innerRadius = ring.radius - targetRingWidth / 2;
                if (distance >= innerRadius && distance <= outerRadius) {
                    activeRing = ring;
                    break;
                }
            }

            if (activeRing && activeRing.actual !== undefined && activeRing.target !== undefined) {
                const difference = activeRing.actual - activeRing.target;
                tooltip.innerHTML = `${activeRing.name}: ${activeRing.actual.toFixed(0)} / ${activeRing.target.toFixed(0)} (Fark: ${difference.toFixed(0)})`;
                tooltip.style.display = 'block';
                tooltip.style.left = `${e.clientX + 10}px`;
                tooltip.style.top = `${e.clientY + 10}px`;
            } else {
                tooltip.style.display = 'none';
            }
        });

        targetCanvas.addEventListener('mouseout', () => {
            tooltip.style.display = 'none';
        });
    };

    addTooltipListeners(canvas, rings, centerX, centerY, ringWidth);

    canvas.addEventListener('click', () => {
        const modal = document.getElementById('macroModal');
        const modalTitle = document.getElementById('macroModalTitle');
        const modalChart = document.getElementById('macroModalChart');
        const modalAnalysis = document.getElementById('macroModalAnalysis');
        if (!modal || !modalTitle || !modalChart || !modalAnalysis) {
            console.error('Modal elements not found:', { modal, modalTitle, modalChart, modalAnalysis });
            return;
        }

        // Popup canvas’inin boyutlarını açıkça ayarla (kare olacak şekilde)
        modalChart.width = 300;
        modalChart.height = 300;
        const modalCtx = modalChart.getContext('2d');
        console.log(`Popup canvas dimensions: ${modalChart.width}x${modalChart.height}`);

        modalTitle.textContent = title || 'Makro Grafiği';

        modalCtx.clearRect(0, 0, modalChart.width, modalChart.height);
        const modalCenterX = modalChart.width / 2;
        const modalCenterY = modalChart.height / 2;
        const modalMaxRadius = Math.min(modalChart.width, modalChart.height) * 0.4;
        const modalRingWidth = modalMaxRadius * 0.2;
        const modalGap = 2;

        const modalRings = [
            { name: 'Kalori', value: data.calories, actual: actualValues?.calories || 0, target: targetValues?.calories || 0, radius: modalMaxRadius, color: 'rgba(40, 167, 69, 0.8)', excessColor: 'rgba(20, 120, 40, 0.8)' },
            { name: 'Yağ', value: data.fat, actual: actualValues?.fat || 0, target: targetValues?.fat || 0, radius: modalMaxRadius - modalRingWidth - modalGap, color: 'rgba(255, 193, 7, 0.8)', excessColor: 'rgba(200, 150, 0, 0.8)' },
            { name: 'Protein', value: data.protein, actual: actualValues?.protein || 0, target: targetValues?.protein || 0, radius: modalMaxRadius - 2 * (modalRingWidth + modalGap), color: 'rgba(0, 123, 255, 0.8)', excessColor: 'rgba(0, 80, 200, 0.8)' },
            { name: 'Karb.', value: data.carbs, actual: actualValues?.carbs || 0, target: targetValues?.carbs || 0, radius: modalMaxRadius - 3 * (modalRingWidth + modalGap), color: 'rgba(220, 53, 69, 0.8)', excessColor: 'rgba(180, 30, 40, 0.8)' }
        ];

        modalRings.forEach(ring => {
            console.log('Drawing popup ring:', ring);
            drawRing(modalCtx, ring.value, ring.radius, ring.color, ring.excessColor, modalCenterX, modalCenterY, modalRingWidth);
        });

        addTooltipListeners(modalChart, modalRings, modalCenterX, modalCenterY, modalRingWidth);

        let day = null;
        try {
            day = title.includes('Günlük') && title.match(/\(([^)]+)\)/) ? title.match(/\(([^)]+)\)/)[1] : null;
        } catch (error) {
            console.error('Error extracting day from title:', title, error);
            day = 'Bilinmeyen Gün';
        }

        const analysisText = generateAnalysisText(type, day, actualValues, targetValues, weeklyData);
        console.log('Generated Analysis Text:', analysisText);
        modalAnalysis.innerHTML = analysisText || '<p>Analiz metni oluşturulamadı.</p>';

        modal.style.display = 'flex';

        const closeBtn = document.querySelector('.macro-modal-close');
        if (closeBtn) {
            closeBtn.onclick = () => {
                modal.style.display = 'none';
            };
        }

        window.onclick = (event) => {
            if (event.target === modal) {
                modal.style.display = 'none';
            }
        };
    });
}
function showNotification(message, type = 'success', duration = 5000) {
    console.log(`Bildirim: ${message} (${type})`);
    const notification = document.getElementById('notification');
    notification.className = `alert alert-${type}`;
    notification.innerHTML = message.replace(/\n/g, '<br>');
    notification.style.display = 'block';
    setTimeout(() => { notification.style.display = 'none'; }, duration);
}

function handlePatientChange() {
    currentPatient = document.getElementById('patientSelect').value;
    console.log("Hasta seçildi:", currentPatient);
    loadPatientData();
    loadCategories();
    calculateMacros();
    generateAutoPlan();
    renderMeals();
    // Hasta değiştiğinde sidebar'ı sevmediği yemeklere göre filtrele
    searchFood('');
}

        function loadPatientData() {
            if (!currentPatient) return;
            const patientData = JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}');
            document.getElementById('likedFoodsDisplay').value = patientData.likedFoods ? patientData.likedFoods.join(', ') : '';
            document.getElementById('dislikedFoodsDisplay').value = patientData.dislikedFoods ? patientData.dislikedFoods.join(', ') : '';
            document.getElementById('likedFoods').innerHTML = patientData.likedFoods ? `Sevdiği: ${patientData.likedFoods.join(', ')}` : '';
            document.getElementById('dislikedFoods').innerHTML = patientData.dislikedFoods ? `Sevmediği: ${patientData.dislikedFoods.join(', ')}` : '';
        }

        function updatePatientPreferences() {
            if (!currentPatient) return;
            const likedFoods = document.getElementById('likedFoodsDisplay').value.split(',').map(f => f.trim()).filter(f => f);
            const dislikedFoods = document.getElementById('dislikedFoodsDisplay').value.split(',').map(f => f.trim()).filter(f => f);
            const patientData = JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}');
            patientData.likedFoods = likedFoods;
            patientData.dislikedFoods = dislikedFoods;
            localStorage.setItem(`patient_${currentPatient}`, JSON.stringify(patientData));
            loadPatientData();
            loadCategories();
            showNotification("Hasta tercihleri güncellendi!");
        }

        function addPatient() {
    const name = prompt("Hasta adı girin:");
    if (!name) return;
    currentPatient = name;
    const patientData = { name, likedFoods: [], dislikedFoods: [], weight: 70, activity: 3 };
    localStorage.setItem(`patient_${name}`, JSON.stringify(patientData));
    // window.patients'a da ekle
    if (!window.patients) window.patients = {};
    window.patients[`patient_${name}`] = patientData;
    loadPatientSelect();
    document.getElementById('patientSelect').value = name;
    handlePatientChange();
    showNotification("Yeni hasta eklendi!");
}

function editPatient() {
    if (!currentPatient) {
        showNotification("Önce bir hasta seçin!", 'warning');
        return;
    }
    const patientData = JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}');
    if (!patientData.name) {
        showNotification("Hasta verisi bulunamadı!", 'warning');
        return;
    }

    // Modal input alanlarını doldur
    document.getElementById("editPatientName").value = patientData.name || '';
    document.getElementById("editPatientWeight").value = patientData.weight || 70;
    document.getElementById("editPatientActivity").value = patientData.activity || 3;
    document.getElementById("editLikedFoods").value = patientData.likedFoods ? patientData.likedFoods.join(', ') : '';
    document.getElementById("editDislikedFoods").value = patientData.dislikedFoods ? patientData.dislikedFoods.join(', ') : '';

    // Modal penceresini aç (Bootstrap kullanıldığını varsayıyorum)
    const modal = new bootstrap.Modal(document.getElementById("editPatientModal"));
    modal.show();
}
function saveEditedPatient() {
    const name = document.getElementById("editPatientName").value.trim();
    const weight = document.getElementById("editPatientWeight").value;
    const activity = document.getElementById("editPatientActivity").value;
    const likedFoodsInput = document.getElementById("editLikedFoods").value;
    const dislikedFoodsInput = document.getElementById("editDislikedFoods").value;

    // Virgülle ayrılmış string’leri diziye çevir
    const likedFoods = likedFoodsInput.split(',').map(f => f.trim()).filter(f => f);
    const dislikedFoods = dislikedFoodsInput.split(',').map(f => f.trim()).filter(f => f);

    // Hasta verisini oluştur
    const patientData = {
        name,
        weight: parseFloat(weight) || 70,
        activity: parseInt(activity) || 3,
        likedFoods,
        dislikedFoods
    };

    // localStorage’a kaydet
    localStorage.setItem(`patient_${name}`, JSON.stringify(patientData));

    // Eğer isim değiştiyse eski kaydı sil
    if (name !== currentPatient) {
        localStorage.removeItem(`patient_${currentPatient}`);
    }
    currentPatient = name;

    // Hasta listesini ve UI’yi güncelle
    loadPatientSelect();
    document.getElementById('patientSelect').value = name;
    handlePatientChange();

    // Modal’ı kapat
    bootstrap.Modal.getInstance(document.getElementById("editPatientModal")).hide();

    showNotification("Hasta bilgileri güncellendi!", "success");
}
        function deletePatient() {
            if (!currentPatient) {
                showNotification("Önce bir hasta seçin!", 'warning');
                return;
            }
            if (confirm(`${currentPatient} adlı hastayı silmek istiyor musunuz?`)) {
                localStorage.removeItem(`patient_${currentPatient}`);
                currentPatient = null;
                loadPatientSelect();
                document.getElementById('patientSelect').value = '';
                handlePatientChange();
                showNotification("Hasta silindi!");
            }
        }

        function loadPatientSelect() {
    const patientSelect = document.getElementById('patientSelect');
    if (!patientSelect) {
        console.error("patientSelect elementi bulunamadı! DOM'da 'patientSelect' ID'sine sahip bir eleman yok.");
        return;
    }

    // localStorage'dan hastaları al
    const localPatients = Object.keys(localStorage)
        .filter(key => key.startsWith('patient_'))
        .map(key => JSON.parse(localStorage.getItem(key)));

    // window.patients ile senkronize et
    if (!window.patients) window.patients = {};
    localPatients.forEach(patient => {
        window.patients[`patient_${patient.name}`] = patient;
    });

    const patients = Object.values(window.patients);
    console.log("Yüklenen hastalar:", patients);

    if (patients.length === 0) {
        patientSelect.innerHTML = '<option value="">Hasta Yok</option>';
    } else {
        patientSelect.innerHTML = '<option value="">Hasta Seç</option>' + 
            patients.map(p => `<option value="${p.name}">${p.name}</option>`).join('');
    }
}

async function testGitHubToken(token) {
    const testUrl = "https://api.github.com/user";
    try {
        const response = await fetch(testUrl, {
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });
        if (response.ok) {
            const data = await response.json();
            console.log("Token geçerli, kullanıcı:", data.login);
            return true;
        } else {
            const errorData = await response.json();
            console.error("Token testi başarısız:", errorData.message);
            return false;
        }
    } catch (error) {
        console.error("Hata:", error);
        return false;
    }
}

        document.getElementById('exportButton').addEventListener('click', exportAllData);


        async function exportAllData() {
    const token = document.getElementById('githubToken')?.value || "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";
    const repoOwner = "mustafasacar35";
    const repoName = "beslenme";
    const filePath = "sistem_JSON.json";
    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}`;




    const data = {
        categories,
        weeks,
        rules,
        mealTemplates,
        compatibilityTable,
        patients: Object.keys(localStorage).filter(key => key.startsWith('patient_'))
            .reduce((obj, key) => {
                obj[key] = JSON.parse(localStorage.getItem(key));
                return obj;
            }, {})
    };

    // window.patients'ı da güncelle
    window.patients = data.patients;

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));

    try {
        const response = await fetch(apiUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });
        const fileData = await response.json();
        const sha = fileData.sha;

        const updateResponse = await fetch(apiUrl, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                message: "Veriler güncellendi",
                content: content,
                sha: sha,
                branch: "main"
            })
        });

        if (updateResponse.ok) {
            showNotification("Veriler GitHub'a başarıyla yüklendi!", "success");
            console.log("GitHub güncelleme başarılı!");
        } else {
            const errorData = await updateResponse.json();
            showNotification("GitHub'a yükleme başarısız: " + errorData.message, "warning");
            console.error("GitHub güncelleme hatası:", errorData);
        }
    } catch (error) {
        showNotification("Bir hata oluştu: " + error.message, "warning");
        console.error("Hata:", error);
    }
}

        function importAllData(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);

            // Kategorileri yükle
            categories.length = 0;
            categories.push(...data.categories);

            // Haftaları yükle
            weeks.length = 0;
            weeks.push(...data.weeks);

            // Kuralları yükle ve eksik alanları tamamla
            rules.length = 0;
            rules.push(...data.rules.map(rule => {
                if (rule.type === 'frequency') {
                    rule.criteria = rule.criteria || {}; // criteria yoksa boş nesne
                } else if (rule.type === 'pairWith' || rule.type === 'avoidPair') {
                    rule.criteria1 = rule.criteria1 || {}; // criteria1 yoksa boş nesne
                    rule.criteria2 = rule.criteria2 || {}; // criteria2 yoksa boş nesne
                }
                return rule;
            }));
            console.log('Yüklenen kurallar:', rules);
            // Diğer verileri yükle
            mealTemplates.length = 0;
            mealTemplates.push(...data.mealTemplates);
            compatibilityTable.length = 0;
            compatibilityTable.push(...data.compatibilityTable);
            Object.entries(data.patients).forEach(([key, value]) => localStorage.setItem(key, JSON.stringify(value)));

            // Arayüzü güncelle
            loadCategories();
            renderWeekTabs();
            renderDayTabs();
            renderMeals();
            loadPatientSelect();
            loadRules();
            loadMealTemplates();
            loadCompatibilityRules();
            calculateMacros();
            showNotification("Veriler içe aktarıldı!");
        } catch (error) {
            console.error('Dosya yüklenirken hata:', error);
            showNotification('Geçersiz dosya formatı!', 'danger');
        }
    };
    reader.readAsText(file);
}

        function exportToTXT() {
            let txtContent = "";
            weeks.forEach((week, wIndex) => {
                txtContent += `Hafta ${wIndex + 1}\n`;
                Object.entries(week.days).forEach(([day, dayData]) => {
                    txtContent += `  ${day.charAt(0).toUpperCase() + day.slice(1)}:\n`;
                    Object.entries(dayData.meals).forEach(([mealType, items]) => {
                        txtContent += `    ${mealType.charAt(0).toUpperCase() + mealType.slice(1)}:\n`;
                        items.forEach(item => {
                            const food = findFood(item.name);
                            txtContent += `      - ${item.name} (${item.quantity || 1}x): ${food.calories * (item.quantity || 1)} kcal, ${food.protein * (item.quantity || 1)}g protein, ${food.carbs * (item.quantity || 1)}g karb, ${food.fat * (item.quantity || 1)}g yağ\n`;
                        });
                    });
                });
                txtContent += "\n";
            });
            const blob = new Blob([txtContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'nutrition_plan.txt';
            a.click();
            URL.revokeObjectURL(url);
            showNotification("TXT olarak dışa aktarıldı!");
        }
function exportTemplatesToTXT() {
    let txtContent = "Öğün Şablonları\n\n";
    mealTemplates.forEach((template, index) => {
        txtContent += `Şablon ${index + 1}: ${template.mealType} (Haftada ${template.frequency} Gün)\n`;
        template.items.forEach(item => {
            txtContent += `  - ${item.keyword} (${item.role}, ${item.quantity}x)\n`;
        });
        txtContent += "\n";
    });
    const blob = new Blob([txtContent], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'meal_templates.txt';
    a.click();
    URL.revokeObjectURL(url);
    showNotification("Şablonlar TXT olarak dışa aktarıldı!");
}
function importTemplatesFromTXT(event) {
    const file = event.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = function(e) {
        const lines = e.target.result.split('\n');
        let newTemplates = [];
        let currentTemplate = null;

        lines.forEach(line => {
            line = line.trim();
            if (!line) return;

            // Şablon başlığını algıla
            if (line.startsWith('Şablon')) {
                if (currentTemplate) newTemplates.push(currentTemplate);
                const match = line.match(/Şablon \d+: (\w+) \(Haftada (\d+) Gün\)/);
                if (match) {
                    currentTemplate = {
                        mealType: match[1],
                        frequency: parseInt(match[2]),
                        items: []
                    };
                }
            }
            // Öğeleri algıla
            else if (line.startsWith('-') && currentTemplate) {
                const itemMatch = line.match(/- (.+) \((\w+), (\d+)x\)/);
                if (itemMatch) {
                    currentTemplate.items.push({
                        keyword: itemMatch[1],
                        role: itemMatch[2],
                        quantity: parseInt(itemMatch[3])
                    });
                }
            }
        });
        if (currentTemplate) newTemplates.push(currentTemplate);

        // Mevcut şablonlarla çakışmaları kontrol et
        let addedCount = 0;
        newTemplates.forEach(newTemplate => {
            const isDuplicate = mealTemplates.some(existing => 
                existing.mealType === newTemplate.mealType &&
                existing.frequency === newTemplate.frequency &&
                existing.items.length === newTemplate.items.length &&
                existing.items.every((item, i) => 
                    item.keyword === newTemplate.items[i].keyword &&
                    item.role === newTemplate.items[i].role &&
                    item.quantity === newTemplate.items[i].quantity
                )
            );
            if (!isDuplicate) {
                mealTemplates.push(newTemplate);
                addedCount++;
            }
        });

        loadMealTemplates();
        showNotification(`${addedCount} yeni şablon eklendi! (Tekrarlananlar eklenmedi)`);
    };
    reader.readAsText(file);
}

function importFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileExtension = file.name.split('.').pop().toLowerCase();
    console.log("Yüklenen dosya:", file.name, "Uzantı:", fileExtension);

    const reader = new FileReader();
    reader.onload = function(e) {
        const data = e.target.result;
        console.log("Dosya içeriği:", data);

        let currentMealType = null;
        let currentItems = [];
        let mealIndex = { lunch: 1, dinner: 1 };
        const existingKeys = new Set();
        const newFoods = [];

        const filterPatterns = [
            /^\*/i,
            /^-/,
            /^\d+\.\s*hafta/i,
            /gün/i,
            /^\s*$/ // Boş satırları filtrele
        ];

        if (fileExtension === 'xlsx' || fileExtension === 'xls') {
            const workbook = XLSX.read(data, { type: "binary" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            const rows = XLSX.utils.sheet_to_json(sheet, { header: 1 });

            rows.forEach((row) => {
                const line = row[0] ? row[0].toString().trim() : "";
                if (!line || filterPatterns.some(p => p.test(line.toLowerCase()))) return;

                if (line.match(/lunch\s*\(1x\)/i) || /öğle/i.test(line)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "lunch";
                    currentItems = [];
                    const mealContent = line.replace(/lunch\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("Öğle öğünü tespit edildi:", currentItems);
                    return;
                }

                if (line.match(/dinner\s*\(1x\)/i) || /akşam/i.test(line)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "dinner";
                    currentItems = [];
                    const mealContent = line.replace(/dinner\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("Akşam öğünü tespit edildi:", currentItems);
                    return;
                }

                if (currentMealType && row.length >= 5 && line.length > 2) {
                    const name = line;
                    const calories = parseFloat(row[1]) || 0;
                    const carbs = parseFloat(row[2]) || 0;
                    const protein = parseFloat(row[3]) || 0;
                    const fat = parseFloat(row[4]) || 0;
                    if (calories > 0 || carbs > 0 || protein > 0 || fat > 0) {
                        currentItems.push({ name, calories, carbs, protein, fat });
                    }
                }
            });
        } else if (fileExtension === 'txt') {
            const lines = data.split('\n');
            lines.forEach((line) => {
                const trimmedLine = line.trim();
                if (!trimmedLine || filterPatterns.some(p => p.test(trimmedLine.toLowerCase()))) return;

                if (trimmedLine.match(/lunch\s*\(1x\)/i) || /öğle/i.test(trimmedLine)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "lunch";
                    currentItems = [];
                    const mealContent = trimmedLine.replace(/lunch\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("TXT: Öğle öğünü tespit edildi:", currentItems);
                    return;
                }

                if (trimmedLine.match(/dinner\s*\(1x\)/i) || /akşam/i.test(trimmedLine)) {
                    if (currentItems.length > 0 && currentMealType) saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
                    currentMealType = "dinner";
                    currentItems = [];
                    const mealContent = trimmedLine.replace(/dinner\s*\(1x\):/i, "").trim();
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)/);
                        const name = nameMatch ? `${nameMatch[1].trim()} (${nameMatch[2].trim()})` : item.trim();
                        currentItems.push({ name, calories: 0, carbs: 0, protein: 0, fat: 0 });
                    });
                    console.log("TXT: Akşam öğünü tespit edildi:", currentItems);
                    return;
                }
            });
        } else {
            showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
            return;
        }

        if (currentItems.length > 0 && currentMealType) {
            saveImportedTemplate(currentMealType, currentItems, existingKeys, mealIndex, newFoods);
        }

        let newCategory = categories.find(cat => cat.name === "Yeni Eklenenler");
        if (!newCategory) {
            newCategory = { name: "Yeni Eklenenler", items: [] };
            categories.push(newCategory);
        }
        newFoods.forEach(food => {
            if (!newCategory.items.some(item => item.name.toLowerCase() === food.name.toLowerCase())) {
                newCategory.items.push(food);
            }
        });

        console.log("Son mealTemplates:", mealTemplates);
        console.log("Son newFoods:", newFoods);

        loadMealTemplates();
        loadCategories();
        showNotification(`Dosyadan ${mealIndex.lunch + mealIndex.dinner - 2} şablon ve ${newFoods.length} yeni yemek eklendi!`, "success");
    };

    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        reader.readAsBinaryString(file);
    } else if (fileExtension === 'txt') {
        reader.readAsText(file);
    } else {
        showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
    }
}


        function importFromTXT(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const lines = e.target.result.split('\n');
                let currentCategory = null;
                lines.forEach(line => {
                    line = line.trim();
                    if (!line || line.startsWith('-')) return;
                    if (line.match(/^[A-ZÇĞİÖŞÜ]+$/)) {
                        currentCategory = line;
                        if (!categories.some(cat => cat.name === currentCategory)) {
                            categories.push({ name: currentCategory, items: [] });
                        }
                    } else if (line.includes(':')) {
                        const [name, details] = line.split(':');
                        const [calories, protein, carbs, fat] = details.match(/[\d.]+/g).map(Number);
                        const category = categories.find(cat => cat.name === currentCategory);
                        if (category) {
                            category.items.push({
                                name: name.trim(),
                                calories,
                                protein,
                                carbs,
                                fat,
                                maxQuantity: 1,
                                tags: [],
                                role: "mainDish",
                                mealType: "breakfast,lunch,dinner",
                                keto: dietMode === 'keto',
                                lowcarb: true
                            });
                        }
                    }
                });
                loadCategories();
                showNotification("TXT'dan yemekler eklendi!");
            };
            reader.readAsText(file);
        }

        function clearCache() {
            localStorage.clear();
            currentPatient = null;
            weeks.length = 0;
            initializeWeeks();
            loadPatientSelect();
            loadCategories();
            renderWeekTabs();
            renderDayTabs();
            renderMeals();
            calculateMacros();
            showNotification("Cache temizlendi!");
        }

        // addRule fonksiyonu
// addRule fonksiyonu
function addRule() {
    console.log("addRule fonksiyonu çağrıldı!");

    const frequencyForm = document.getElementById('frequencyRuleForm');
    const dependOnForm = document.getElementById('dependOnRuleForm');
    const compatibilityForm = document.getElementById('compatibilityRuleForm'); // Yeni eklenen form
    let activeForm = null;
    let ruleType = null;

    if (frequencyForm && frequencyForm.style.display !== 'none') {
        activeForm = frequencyForm;
        ruleType = 'frequency';
    } else if (dependOnForm && dependOnForm.style.display !== 'none') {
        activeForm = dependOnForm;
        ruleType = 'dependOn';
    } else if (compatibilityForm && compatibilityForm.style.display !== 'none') {
        activeForm = compatibilityForm;
        ruleType = 'compatibility';
    } else {
        console.warn("Hiçbir kural formu aktif değil!");
        return;
    }

    const editIndex = activeForm.dataset.editIndex;
    const isEditing = editIndex !== undefined && editIndex !== '' && rules[editIndex];

    let rule = { type: ruleType };

    if (isEditing) {
        rule.id = rules[editIndex].id;
        if (!rule.id) {
            console.warn(`Düzenlenen kuralda ID eksik, index: ${editIndex}`, rules[editIndex]);
            rule.id = Math.max(...rules.map(r => r.id || 0)) + 1;
        }
    } else {
        const maxId = rules.length > 0 ? Math.max(...rules.map(r => r.id || 0)) : 0;
        rule.id = maxId + 1;
    }

    if (ruleType === 'frequency' && activeForm === frequencyForm) {
        rule.frequency = parseInt(document.getElementById('freqCount')?.value) || 1;
        rule.scope = document.getElementById('freqScope')?.value || 'meal';
        rule.frequencyType = document.getElementById('freqType')?.value || 'exact';
        rule.weekRange = document.getElementById('freqWeekRange')?.value.trim() || 'all';

        if (!['meal', 'day', 'week'].includes(rule.scope)) {
            console.warn(`Geçersiz scope değeri: ${rule.scope}. Varsayılan olarak 'meal' kullanılıyor.`);
            rule.scope = 'meal';
        }

        if (!['exact', 'min', 'max'].includes(rule.frequencyType)) {
            console.warn(`Geçersiz frequencyType değeri: ${rule.frequencyType}. Varsayılan olarak 'exact' kullanılıyor.`);
            rule.frequencyType = 'exact';
        }

        rule.nameCheck = document.getElementById('freqNameCheck')?.checked || false;
        const nameInput = document.getElementById('freqName')?.value.trim();
        if (rule.nameCheck && nameInput) {
            if (nameInput.includes(',,')) {
                rule.nameOperator = 'AND';
                rule.names = nameInput.split(',,').map(n => n.trim()).filter(n => n);
            } else if (nameInput.includes(';;')) {
                rule.nameOperator = 'OR';
                rule.names = nameInput.split(';;').map(n => n.trim()).filter(n => n);
            } else {
                rule.nameOperator = 'OR';
                rule.names = [nameInput];
            }
            delete rule.name;
        } else {
            rule.names = [];
        }

        rule.tagsCheck = document.getElementById('freqTagCheck')?.checked || false;
        const tagInput = document.getElementById('freqTag')?.value.trim();
        if (rule.tagsCheck && tagInput) {
            if (tagInput.includes(',,')) {
                rule.tagOperator = 'AND';
                rule.tags = tagInput.split(',,').map(t => t.trim()).filter(t => t);
            } else if (tagInput.includes(';;')) {
                rule.tagOperator = 'OR';
                rule.tags = tagInput.split(';;').map(t => t.trim()).filter(t => t);
            } else {
                rule.tagOperator = 'AND';
                rule.tags = tagInput.split(',').map(t => t.trim()).filter(t => t);
            }
        } else {
            rule.tags = [];
        }

        rule.roleCheck = document.getElementById('freqRoleCheck')?.checked || false;
        rule.role = rule.roleCheck ? document.getElementById('freqRole')?.value : '';

        rule.catCheck = document.getElementById('freqCatCheck')?.checked || false;
        rule.category = rule.catCheck ? document.getElementById('freqCat')?.value : '';

        rule.mealTypeCheck = rule.scope === 'meal';
        rule.mealType = rule.mealTypeCheck ? document.getElementById('freqMeal')?.value : '';

        console.log("Oluşturulan/Güncellenen kural (frequency):", JSON.stringify(rule, null, 2));
        if (!rule.nameCheck && !rule.tagsCheck && !rule.roleCheck && !rule.catCheck) {
            showNotification("Hata: Frequency kuralı için isim, etiket, rol veya kategoriden en az biri belirtilmeli!", "error");
            console.log("Hata: Hiçbir kriter seçilmedi.");
            return;
        }
    } else if (ruleType === 'dependOn' && activeForm === dependOnForm) {
        rule.food = document.getElementById('dependOnFood')?.value.trim();
        rule.requiredFood = document.getElementById('dependOnRequiredFood')?.value.trim();
        rule.scope = document.getElementById('dependOnScope')?.value || 'meal';

        if (!['meal', 'day'].includes(rule.scope)) {
            console.warn(`Geçersiz scope değeri: ${rule.scope}. Varsayılan olarak 'meal' kullanılıyor.`);
            rule.scope = 'meal';
        }

        if (!rule.food || !rule.requiredFood) {
            showNotification("Hata: DependOn kuralı için hem yemek hem de gerekli yemek belirtilmeli!", "error");
            console.log("Hata: Eksik yemek bilgisi.");
            return;
        }

        console.log("Oluşturulan/Güncellenen kural (dependOn):", JSON.stringify(rule, null, 2));
    } else if (ruleType === 'compatibility' && activeForm === compatibilityForm) {
        rule.keyword1 = document.getElementById('compatKeyword1')?.value.trim();
        const keyword2Input = document.getElementById('compatKeyword2')?.value.trim();
        rule.keyword2 = keyword2Input ? keyword2Input.split(',').map(k => k.trim()).filter(k => k) : [];
        rule.degree = parseInt(document.getElementById('compatDegree')?.value) || 0;
        rule.conjunction = document.getElementById('compatConjunction')?.value || 'and';

        if (!rule.keyword1 || rule.keyword2.length === 0) {
            showNotification("Hata: Compatibility kuralı için hem keyword1 hem de keyword2 belirtilmeli!", "error");
            console.log("Hata: Eksik uyumluluk bilgisi.");
            return;
        }

        console.log("Oluşturulan/Güncellenen kural (compatibility):", JSON.stringify(rule, null, 2));
    } else {
        console.warn(`Desteklenmeyen kural tipi: ${ruleType}`);
        return;
    }

    if (isEditing) {
        rules[editIndex] = rule;
        showNotification(`Kural (${rule.id}) güncellendi!`, "success");
    } else {
        rules.push(rule);
        showNotification(`Kural (${rule.id}) eklendi!`, "success");
    }

    loadRules();
    activeForm.style.display = 'none';
    delete activeForm.dataset.editIndex;
}



function loadRules() {
    const rulesList = document.getElementById('rulesList');
    if (!rulesList) {
        console.warn("rulesList elementi bulunamadı.");
        return;
    }

    rulesList.innerHTML = rules.map((rule, index) => {
        let description = '';

        switch (rule.type) {
            case 'frequency':
                const criteriaText = [];
                if (rule.nameCheck && rule.names?.length) {
                    const connector = rule.nameOperator === 'OR' ? 'veya' : 've';
                    criteriaText.push(`İsim: ${rule.names.join(` ${connector} `)}`);
                } else if (rule.nameCheck && rule.name) {
                    criteriaText.push(`İsim: ${rule.name}`);
                }
                if (rule.tagsCheck && rule.tags?.length) {
                    const connector = rule.tagOperator === 'OR' ? 'veya' : 've';
                    criteriaText.push(`Etiket: ${rule.tags.join(` ${connector} `)}`);
                }
                if (rule.roleCheck && rule.role) criteriaText.push(`Rol: ${rule.role}`);
                if (rule.catCheck && rule.category) criteriaText.push(`Kategori: ${rule.category}`);
                const criteriaDisplay = criteriaText.length ? criteriaText.join(', ') : 'Herhangi bir yemek';
                const scopeText = rule.scope === 'meal' ? `her ${rule.mealType || 'öğünde'}` :
                                 rule.scope === 'day' ? 'günde' :
                                 'haftada';
                const frequencyText = rule.frequencyType === 'min' ? 'en az' :
                                     rule.frequencyType === 'max' ? 'en fazla' :
                                     '';
                description = `(${rule.id}) ${criteriaDisplay} ${scopeText} ${frequencyText} ${rule.frequency || 1} kez`.trim();
                break;
            case 'pairWith':
            case 'avoidPair':
                const pairText = rule.type === 'pairWith' ? 'birlikte olsun' : 'birlikte olmasın';
                const scopePairText = rule.scope === 'meal' ? `her ${rule.meal || 'öğünde'}` :
                                     rule.scope === 'day' ? 'günde' :
                                     'haftada';
                description = `(${rule.id}) ${rule.pair1Name || 'Belirsiz'} ile ${rule.pair2Name || 'Belirsiz'} ${scopePairText} ${pairText}`;
                break;
            case 'dependOn':
                const dependScopeText = rule.scope === 'meal' ? 'her öğünde' : 'her gün';
                description = `(${rule.id}) ${rule.food || 'Belirsiz'} yalnızca ${rule.requiredFood || 'Belirsiz'} ile ${dependScopeText} eklensin`;
                break;
            case 'categoryLock':
                const lockScopeText = rule.scope === 'week' ? 'hafta boyunca' : 'her zaman';
                description = `(${rule.id}) ${rule.category || 'Belirsiz'} kategorisinde ${lockScopeText} sadece ${rule.item || 'Belirsiz'} kullanılsın`;
                break;
            case 'compatibility':
                const compatText = rule.degree > 0 ? 'Uyumlu' : 'Uyumsuz';
                description = `(${rule.id}) ${rule.keyword1 || 'Belirsiz'} ile ${rule.keyword2?.join(', ') || 'Belirsiz'} (${compatText}, ${rule.conjunction === 'or' ? 'veya' : 've'})`;
                break;
            default:
                description = `(${rule.id}) Bilinmeyen kural tipi: ${rule.type}`;
                console.warn(`Bilinmeyen kural tipi: ${JSON.stringify(rule)}`);
        }

        if (rule.weekRange && rule.weekRange !== 'all') {
            description += ` [Hafta ${rule.weekRange}]`;
        }

        return `
            <div class="mb-1 d-flex justify-content-between align-items-center">
                <span>${description}</span>
                <div>
                    <button class="btn btn-warning btn-sm me-1" onclick="editRule(${index})" title="Düzenle"><i class="bi bi-pencil"></i></button>
                    <button class="btn btn-danger btn-sm" onclick="deleteRule(${index})" title="Sil"><i class="bi bi-trash"></i></button>
                </div>
            </div>
        `;
    }).join('');
}

// editRule fonksiyonu
function editRule(index) {
    const rule = rules[index];
    if (!rule) {
        console.warn(`Düzenlenecek kural bulunamadı, index: ${index}`);
        return;
    }

    if (rule.type === 'frequency') {
        const form = document.getElementById('frequencyRuleForm');
        form.style.display = 'block';
        document.getElementById('freqCount').value = rule.frequency || 1;
        document.getElementById('freqScope').value = rule.scope || 'meal';
        document.getElementById('freqType').value = rule.frequencyType || 'exact';
        document.getElementById('freqWeekRange').value = rule.weekRange === 'all' ? '' : rule.weekRange;
        document.getElementById('freqNameCheck').checked = rule.nameCheck || false;
        document.getElementById('freqName').value = rule.name || '';
        document.getElementById('freqName').disabled = !rule.nameCheck;
        document.getElementById('freqTagCheck').checked = rule.tagsCheck || false;
        document.getElementById('freqTag').value = rule.tags?.join(', ') || '';
        document.getElementById('freqTag').disabled = !rule.tagsCheck;
        document.getElementById('freqRoleCheck').checked = rule.roleCheck || false;
        document.getElementById('freqRole').value = rule.role || '';
        document.getElementById('freqRole').disabled = !rule.roleCheck;
        document.getElementById('freqCatCheck').checked = rule.catCheck || false;
        document.getElementById('freqCat').value = rule.category || '';
        document.getElementById('freqCat').disabled = !rule.catCheck;
        document.getElementById('freqMeal').style.display = rule.scope === 'meal' ? 'inline-block' : 'none';
        document.getElementById('freqMeal').value = rule.mealType || 'breakfast';
        form.dataset.editIndex = index;
    } else if (rule.type === 'dependOn') {
        const form = document.getElementById('dependOnRuleForm');
        form.style.display = 'block';
        document.getElementById('dependOnFood').value = rule.food || '';
        document.getElementById('dependOnRequiredFood').value = rule.requiredFood || '';
        document.getElementById('dependOnScope').value = rule.scope || 'meal';
        form.dataset.editIndex = index;
    }

    // Checkbox olay dinleyicileri (frequency için)
    toggleInput('freqNameCheck', 'freqName');
    toggleInput('freqTagCheck', 'freqTag');
    toggleInput('freqRoleCheck', 'freqRole');
    toggleInput('freqCatCheck', 'freqCat');
}

function toggleInput(checkboxId, inputId) {
    const checkbox = document.getElementById(checkboxId);
    const input = document.getElementById(inputId);
    if (checkbox && input) {
        input.disabled = !checkbox.checked;
        checkbox.addEventListener('change', () => {
            input.disabled = !checkbox.checked;
        });
    }
}

// saveEditedRule fonksiyonu
function saveEditedRule(event) {
    event.preventDefault();

    const indexField = document.getElementById('editRuleIndex');
    const isEditMode = indexField.value !== '';
    const index = parseInt(indexField.value);

    const rule = {
        type: 'frequency',
        frequency: parseInt(document.getElementById('freqCount').value) || 1,
        scope: document.getElementById('freqScope').value,
        weekRange: document.getElementById('freqWeekRange').value
    };

    rule.nameCheck = document.getElementById('freqNameCheck').checked;
    rule.name = rule.nameCheck ? document.getElementById('freqName').value.trim() : '';
    rule.tagsCheck = document.getElementById('freqTagCheck').checked;
    rule.tags = rule.tagsCheck ? document.getElementById('freqTag').value.split(',').map(t => t.trim()).filter(t => t) : [];
    rule.roleCheck = document.getElementById('freqRoleCheck').checked;
    rule.role = rule.roleCheck ? document.getElementById('freqRole').value : '';
    rule.catCheck = document.getElementById('freqCatCheck').checked;
    rule.category = rule.catCheck ? document.getElementById('freqCat').value : '';
    rule.mealTypeCheck = rule.scope === 'meal';
    rule.mealType = rule.mealTypeCheck ? document.getElementById('freqMeal').value : '';

    if (isEditMode) {
        rules[index] = rule;
        showNotification("Kural güncellendi!", "success");
        console.log("Güncellenen kural:", JSON.stringify(rule, null, 2));
    } else {
        rules.push(rule);
        showNotification("Yeni kural eklendi!", "success");
        console.log("Eklenen kural:", JSON.stringify(rule, null, 2));
    }

    loadRules();
    cancelEditRule();
}

// handleRuleSave fonksiyonu
function handleRuleSave() {
    const indexValue = document.getElementById('editRuleIndex').value;
    const ruleType = document.getElementById('ruleType').value;

    if (indexValue !== '') {
        // Düzenleme modu
        saveEditedRule(new Event('submit'));
    } else {
        // Yeni kural ekleme modu
        let newRule = { type: ruleType };
        const maxId = rules.length > 0 ? Math.max(...rules.map(r => r.id || 0)) : 0;
        newRule.id = maxId + 1;

        if (ruleType === 'frequency') {
            const freqCount = parseInt(document.getElementById('freqCount').value) || 1;
            const freqType = document.getElementById('freqType').value || 'exact';
            const freqScope = document.getElementById('freqScope').value || 'week';
            const freqWeekRange = document.getElementById('freqWeekRange').value.trim() || 'all';
            newRule = { ...newRule, frequency: freqCount, frequencyType: freqType, scope: freqScope, weekRange: freqWeekRange };
            newRule.nameCheck = document.getElementById('freqNameCheck').checked;
            const nameInput = document.getElementById('freqName').value.trim();
            if (newRule.nameCheck && nameInput) {
                if (nameInput.includes(',,')) {
                    newRule.nameOperator = 'AND';
                    newRule.names = nameInput.split(',,').map(n => n.trim()).filter(n => n);
                } else if (nameInput.includes(';;')) {
                    newRule.nameOperator = 'OR';
                    newRule.names = nameInput.split(';;').map(n => n.trim()).filter(n => n);
                } else {
                    newRule.nameOperator = 'OR';
                    newRule.names = [nameInput];
                }
            } else {
                newRule.names = [];
            }
            newRule.tagsCheck = document.getElementById('freqTagCheck').checked;
            const tagInput = document.getElementById('freqTag').value.trim();
            if (newRule.tagsCheck && tagInput) {
                if (tagInput.includes(',,')) {
                    newRule.tagOperator = 'AND';
                    newRule.tags = tagInput.split(',,').map(t => t.trim()).filter(t => t);
                } else if (tagInput.includes(';;')) {
                    newRule.tagOperator = 'OR';
                    newRule.tags = tagInput.split(';;').map(t => t.trim()).filter(t => t);
                } else {
                    newRule.tagOperator = 'AND';
                    newRule.tags = tagInput.split(',').map(t => t.trim()).filter(t => t);
                }
            } else {
                newRule.tags = [];
            }
            newRule.roleCheck = document.getElementById('freqRoleCheck').checked;
            newRule.role = newRule.roleCheck ? document.getElementById('freqRole').value : '';
            newRule.catCheck = document.getElementById('freqCatCheck').checked;
            newRule.category = newRule.catCheck ? document.getElementById('freqCat').value : '';
            newRule.mealTypeCheck = freqScope === 'meal';
            newRule.mealType = newRule.mealTypeCheck ? document.getElementById('freqMeal').value : '';
            if (!newRule.nameCheck && !newRule.tagsCheck && !newRule.roleCheck && !newRule.catCheck) {
                showNotification("Hata: Frequency kuralı için isim, etiket, rol veya kategoriden en az biri belirtilmeli!", "error");
                return;
            }
        } else if (ruleType === 'dependOn') {
            const dependOnFood = document.getElementById('dependOnFood').value.trim();
            const dependOnRequiredFood = document.getElementById('dependOnRequiredFood').value.trim();
            const dependOnScope = document.getElementById('dependOnScope').value || 'meal';
            if (!dependOnFood || !dependOnRequiredFood) {
                showNotification("Bağımlı yemek ve gerekli yemek boş olamaz!", "warning");
                return;
            }
            newRule = { ...newRule, food: dependOnFood, requiredFood: dependOnRequiredFood, scope: dependOnScope };
        } else if (ruleType === 'categoryLock') {
            const category = document.getElementById('categoryLockCategory').value;
            const scope = document.getElementById('categoryLockScope').value;
            newRule = { ...newRule, category, scope };
        } else if (ruleType === 'pairWith' || ruleType === 'avoidPair') {
            const pair1Name = document.getElementById('pair1Name').value.trim();
            const pair2Name = document.getElementById('pair2Name').value.trim();
            const pairScope = document.getElementById('pairScope').value;
            const pairConjunction = document.getElementById('pairConjunction').value;
            const pairDirection = document.getElementById('pairDirection').value;
            const pairMealType = document.getElementById('pairScope').value === 'meal' ? document.getElementById('pairMeal').value : '';
            const pairWeekRange = document.getElementById('pairWeekRange').value.trim();
            if (!pair1Name || !pair2Name) {
                showNotification("Birinci ve ikinci kelime boş olamaz!", "warning");
                return;
            }
            newRule = {
                ...newRule,
                name1Check: document.getElementById('pair1NameCheck').checked,
                name1: document.getElementById('pair1NameCheck').checked ? pair1Name : '',
                tag1Check: document.getElementById('pair1TagCheck').checked,
                tag1: document.getElementById('pair1TagCheck').checked ? document.getElementById('pair1Tag').value.trim() : '',
                role1Check: document.getElementById('pair1RoleCheck').checked,
                role1: document.getElementById('pair1RoleCheck').checked ? document.getElementById('pair1Role').value : '',
                cat1Check: document.getElementById('pair1CatCheck').checked,
                cat1: document.getElementById('pair1CatCheck').checked ? document.getElementById('pair1Cat').value : '',
                name2Check: document.getElementById('pair2NameCheck').checked,
                name2: document.getElementById('pair2NameCheck').checked ? pair2Name : '',
                tag2Check: document.getElementById('pair2TagCheck').checked,
                tag2: document.getElementById('pair2TagCheck').checked ? document.getElementById('pair2Tag').value.trim() : '',
                role2Check: document.getElementById('pair2RoleCheck').checked,
                role2: document.getElementById('pair2RoleCheck').checked ? document.getElementById('pair2Role').value : '',
                cat2Check: document.getElementById('pair2CatCheck').checked,
                cat2: document.getElementById('pair2CatCheck').checked ? document.getElementById('pair2Cat').value : '',
                conjunction: pairConjunction,
                direction: pairDirection,
                scope: pairScope,
                mealType: pairMealType,
                weekRange: pairWeekRange
            };
        } else if (ruleType === 'compatibility') {
            const keyword1 = document.getElementById('compatKeyword1').value.trim();
            const keyword2Input = document.getElementById('compatKeyword2').value.trim();
            const keyword2 = keyword2Input ? keyword2Input.split(',').map(k => k.trim()).filter(k => k) : [];
            const degree = parseInt(document.getElementById('compatDegree').value) || 0;
            const conjunction = document.getElementById('compatConjunction').value;
            if (!keyword1) {
                showNotification("Kelime 1 boş olamaz!", "warning");
                return;
            }
            newRule = { ...newRule, keyword1, keyword2, degree, conjunction };
        } else if (ruleType === 'maxRoleCount') {
            const roleCheck = document.getElementById('ruleRoleCheck') ? document.getElementById('ruleRoleCheck').checked : true;
            const role = roleCheck && document.getElementById('ruleRole') ? document.getElementById('ruleRole').value : 'mainDish';
            const count = parseInt(document.getElementById('ruleCount').value) || 1;
            const scope = document.getElementById('ruleScope').value || 'meal';
            const mealTypeCheck = document.getElementById('ruleMealTypeCheck').checked;
            const mealType = mealTypeCheck ? [document.getElementById('ruleMealType').value] : ['lunch', 'dinner'];
            const weekRange = document.getElementById('ruleWeekRange').value.trim() || 'all';
            if (count < 0) {
                showNotification("Sayı 0 veya pozitif olmalı!", "warning");
                return;
            }
            newRule = {
                ...newRule,
                roleCheck,
                role,
                count,
                scope,
                mealType,
                weekRange
            };
        } else {
            const nameCheck = document.getElementById('ruleNameCheck').checked;
            const name = nameCheck ? document.getElementById('ruleName').value.trim() : '';
            const tagsCheck = document.getElementById('ruleTagsCheck').checked;
            const tags = tagsCheck ? document.getElementById('ruleTags').value.split(',').map(t => t.trim()).filter(t => t) : [];
            const categoryCheck = document.getElementById('ruleCategoryCheck').checked;
            const category = categoryCheck ? document.getElementById('ruleCategory').value : '';
            const mealTypeCheck = document.getElementById('ruleMealTypeCheck').checked;
            const mealType = mealTypeCheck ? [document.getElementById('ruleMealType').value] : [];
            const scope = document.getElementById('ruleScope').value || 'week';
            const weekRange = document.getElementById('ruleWeekRange').value.trim() || 'all';
            newRule = {
                ...newRule,
                nameCheck,
                name,
                tagsCheck,
                tags,
                categoryCheck,
                category,
                mealTypeCheck,
                mealType,
                scope,
                weekRange
            };
            if (['exclude', 'include', 'singleItem'].includes(ruleType)) {
                if (!nameCheck && !tagsCheck && !categoryCheck && !mealTypeCheck) {
                    showNotification("Hata: En az bir kriter (isim, etiket, kategori veya öğün) belirtilmeli!", "error");
                    return;
                }
            }
            if (['minCount', 'maxCount'].includes(ruleType)) {
                const count = parseInt(document.getElementById('ruleCount').value) || 1;
                newRule.count = count;
                if (count < 0) {
                    showNotification("Sayı 0 veya pozitif olmalı!", "warning");
                    return;
                }
            }
            if (ruleType === 'pairWith' || ruleType === 'avoidPair') {
                const pair = document.getElementById('rulePair').value.trim();
                if (!pair) {
                    showNotification("Eşleşecek yemek boş olamaz!", "warning");
                    return;
                }
                newRule.pair = pair;
            }
        }

        rules.push(newRule);
        loadRules();
        showNotification("Kural eklendi!", "success");

        // Formu gizle
        document.getElementById('defaultRuleForm').style.display = 'none';
        document.getElementById('frequencyRuleForm').style.display = 'none';
        document.getElementById('dependOnRuleForm').style.display = 'none';
        document.getElementById('categoryLockRuleForm').style.display = 'none';
        document.getElementById('pairRuleForm').style.display = 'none';
        document.getElementById('compatibilityRuleForm').style.display = 'none';
    }
}

// Diğer yardımcı fonksiyonlar
function cancelEditRule() {
    document.getElementById('editRuleForm').style.display = 'none';
    document.getElementById('frequencyRuleForm').style.display = 'none';

    const addRuleButton = document.getElementById('addRuleButton');
    if (addRuleButton) addRuleButton.textContent = "Kural Ekle";
    else console.warn("addRuleButton bulunamadı.");
}

function deleteRule(index) {
    rules.splice(index, 1);
    loadRules();
    showNotification("Kural silindi!", "success");
}

function populateCategoryDropdown() {
    const catSelect = document.getElementById('freqCat');
    if (!catSelect) return console.error("freqCat bulunamadı!");
    catSelect.innerHTML = '<option value="">Seç</option>';
    categories.forEach(category => {
        const option = document.createElement('option');
        option.value = category.name;
        option.textContent = category.name;
        catSelect.appendChild(option);
    });
}

function openFrequencyRuleForm() {
    const form = document.getElementById('frequencyRuleForm');
    form.style.display = 'block';

    document.getElementById('freqName').value = '';
    document.getElementById('freqTag').value = '';
    document.getElementById('freqCount').value = 1;
    document.getElementById('freqWeekRange').value = '';
    document.getElementById('freqScope').value = 'week';
    document.getElementById('freqMeal').value = 'lunch';
    document.getElementById('freqNameCheck').checked = false;
    document.getElementById('freqTagCheck').checked = false;
    document.getElementById('freqRoleCheck').checked = false;
    document.getElementById('freqCatCheck').checked = false;
    document.getElementById('freqName').disabled = true;
    document.getElementById('freqTag').disabled = true;
    document.getElementById('freqRole').disabled = true;
    document.getElementById('freqCat').disabled = true;

    populateCategoryDropdown();
    
    const addRuleButton = document.getElementById('addRuleButton');
    if (addRuleButton) addRuleButton.textContent = "Kural Ekle";
}

function toggleInput(checkboxId, inputId) {
    const checkbox = document.getElementById(checkboxId);
    const input = document.getElementById(inputId);
    if (checkbox && input) {
        checkbox.addEventListener('change', function() {
            input.disabled = !this.checked;
        });
    }
}

function toggleMealSelect(scopeId, mealId) {
    const scopeSelect = document.getElementById(scopeId);
    const mealSelect = document.getElementById(mealId);
    if (scopeSelect && mealSelect) {
        mealSelect.style.display = scopeSelect.value === 'meal' ? 'inline' : 'none';
        scopeSelect.addEventListener('change', function() {
            mealSelect.style.display = this.value === 'meal' ? 'inline' : 'none';
        });
    }
}

// Event Listener'lar ve Başlatma
document.getElementById('freqNameCheck').addEventListener('change', function() {
    document.getElementById('freqName').disabled = !this.checked;
});
document.getElementById('freqScope').addEventListener('change', function() {
    document.getElementById('freqMeal').style.display = this.value === 'meal' ? 'block' : 'none';
});

toggleInput('freqNameCheck', 'freqName');
toggleInput('freqTagCheck', 'freqTag');
toggleInput('freqRoleCheck', 'freqRole');
toggleInput('freqCatCheck', 'freqCat');
toggleInput('pair1NameCheck', 'pair1Name');
toggleInput('pair2NameCheck', 'pair2Name');

toggleMealSelect('freqScope', 'freqMeal');
toggleMealSelect('pairScope', 'pairMeal');

initializeWeeks();
loadCategories();
renderWeekTabs();
renderDayTabs();
renderMeals();
loadPatientSelect();
loadRules();
loadMealTemplates();
loadCompatibilityRules();
loadSettingsTemplates();
loadRuleTemplates();
calculateMacros();
searchEditFood('');
updateRuleForm();

// Eklenmesi gereken satırlar
toggleMealSelect('freqScope', 'freqMeal'); // Sıklık Kuralı için ilk durumu ayarla
toggleMealSelect('pairScope', 'pairMeal'); // Birliktelik Kuralı için ilk durumu ayarla

function updateRuleForm(isEdit = false) {
    const ruleType = isEdit ? document.getElementById('editRuleType').value : document.getElementById('ruleType').value;

    // Form referanslarını al (forms nesnesinden)
    const forms = {
        default: document.getElementById('defaultRuleForm'),
        frequency: document.getElementById('frequencyRuleForm'),
        pair: document.getElementById('pairRuleForm'),
        dependOn: document.getElementById('dependOnRuleForm'),
        categoryLock: document.getElementById('categoryLockRuleForm'),
        compatibility: document.getElementById('compatibilityRuleForm')
    };

    // Input alanlarını al
    const frequencyInput = document.getElementById('frequencyInput');
    const countInput = document.getElementById('countInput');
    const pairInput = document.getElementById('pairInput');

    // Tüm formları varsayılan olarak gizle
    Object.values(forms).forEach(form => {
        if (form) form.style.display = 'none';
    });

    // Input alanlarını varsayılan olarak gizle
    if (frequencyInput) frequencyInput.style.display = 'none';
    if (countInput) countInput.style.display = 'none';
    if (pairInput) pairInput.style.display = 'none';

    // Seçilen kural türüne göre uygun formu ve input alanlarını göster
    if (ruleType === 'frequency') {
        forms.frequency.style.display = 'block';
        if (frequencyInput) frequencyInput.style.display = 'block';
    } else if (ruleType === 'dependOn') {
        forms.dependOn.style.display = 'block';
    } else if (ruleType === 'categoryLock') {
        forms.categoryLock.style.display = 'block';
    } else if (ruleType === 'pairWith' || ruleType === 'avoidPair') {
        forms.pair.style.display = 'block';
        if (pairInput) pairInput.style.display = 'block';
    } else if (ruleType === 'compatibility') {
        forms.compatibility.style.display = 'block';
    } else if (ruleType === 'maxRoleCount') {
        forms.default.style.display = 'block';
        if (countInput) countInput.style.display = 'block'; // maxRoleCount için sayı alanı
    } else {
        forms.default.style.display = 'block';
        // Diğer kural türleri için input alanlarını kontrol et
        if (frequencyInput) frequencyInput.style.display = ruleType === 'frequency' ? 'block' : 'none';
        if (pairInput) pairInput.style.display = ['pairWith', 'avoidPair'].includes(ruleType) ? 'block' : 'none';
    }

    // Hata ayıklama için konsol mesajı
    console.log(`updateRuleForm: Kural tipi "${ruleType}" seçildi, form: ${forms[ruleType] ? ruleType : 'default'}`);
}

    // Tüm formları varsayılan olarak gizle
    defaultForm.style.display = 'none';
    frequencyForm.style.display = 'none';
    pairForm.style.display = 'none';
    dependOnForm.style.display = 'none'; // Yeni eklenen
    categoryLockForm.style.display = 'none'; // Yeni eklenen

    // Seçilen türe göre doğru formu göster
    if (type === 'frequency') {
        frequencyForm.style.display = 'block';
    } else if (type === 'pairWith' || type === 'avoidPair') {
        pairForm.style.display = 'block';
    } else if (type === 'dependOn') { // Yeni eklenen: Bağımlı Olsun kuralı
        dependOnForm.style.display = 'block';
    } else if (type === 'categoryLock') { // Yeni eklenen: Kategori Kilidi kuralı
        categoryLockForm.style.display = 'block';
    } else {
        defaultForm.style.display = 'block';
        frequencyInput.style.display = type === 'frequency' ? 'block' : 'none';
        countInput.style.display = 'none'; // Min ve Max kalktığı için hep gizli
        pairInput.style.display = ['pairWith', 'avoidPair'].includes(type) ? 'block' : 'none';
    }



function saveRuleTemplate() {
    const templateName = document.getElementById('templateName').value;
    if (!templateName) {
        showNotification("Şablon adı girin!", 'warning');
        return;
    }
    localStorage.setItem(`ruleTemplate_${templateName}`, JSON.stringify(rules));
    loadRuleTemplates();
    showNotification("Şablon kaydedildi!");
}























function loadRuleTemplates() {
    const templateSelect = document.getElementById('templateSelect');
    const templates = Object.keys(localStorage).filter(key => key.startsWith('ruleTemplate_')).map(key => key.replace('ruleTemplate_', ''));
    templateSelect.innerHTML = '<option value="">Şablon Yükle</option>' + templates.map(t => `<option value="${t}">${t}</option>`).join('');
}

function loadRuleTemplate() {
    const templateName = document.getElementById('templateSelect').value;
    if (!templateName) return;
    rules.length = 0;
    rules.push(...JSON.parse(localStorage.getItem(`ruleTemplate_${templateName}`) || '[]'));
    loadRules();
    showNotification("Şablon yüklendi!");
}

function deleteRuleTemplate() {
    const templateName = document.getElementById('templateSelect').value;
    if (!templateName) return;
    localStorage.removeItem(`ruleTemplate_${templateName}`);
    loadRuleTemplates();
    showNotification("Şablon silindi!");
}

function addCompatibilityRule() {
    const keyword1 = document.getElementById('compatKeyword1').value.trim();
    const keyword2Input = document.getElementById('compatKeyword2').value.trim();
    const degree = parseInt(document.getElementById('compatDegree').value);
    const conjunction = document.getElementById('compatConjunction').value;
    if (!keyword1) {
        showNotification("Lütfen birinci kelimeyi girin!", 'warning');
        return;
    }
    const keyword2 = keyword2Input ? keyword2Input.split(',').map(k => k.trim()).filter(k => k) : [];
    compatibilityTable.push({ keyword1, keyword2, degree, conjunction });
    loadCompatibilityRules();
    showNotification("Uyumluluk kuralı eklendi!");
}

function importFoodList() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
            try {
                const jsonData = JSON.parse(e.target.result);
                let newCount = 0; // Yeni eklenen yemek sayısını tutacak

                // JSON'dan gelen kategorileri işleyelim
                jsonData.categories.forEach(newCat => {
                    let existingCat = categories.find(cat => cat.name === newCat.name);
                    if (!existingCat) {
                        existingCat = { name: newCat.name, items: [] };
                        categories.push(existingCat);
                        console.log(`Yeni kategori oluşturuldu: ${newCat.name}`);
                    }
                    newCat.items.forEach(newItem => {
                        const existingItem = existingCat.items.find(item => item.name === newItem.name);
                        if (!existingItem) {
                            existingCat.items.push(newItem);
                            newCount++; // Her yeni yemek için sayacı artır
                            console.log(`Yeni yemek eklendi: ${newItem.name}`);
                        } else {
                            console.log(`${newItem.name} zaten mevcut, eklenmedi.`);
                        }
                    });
                });

                loadCategories(); // Arayüzü güncelle
                const message = `🍽 Yemek listesi eklendi! Çakışanlar korunarak ${newCount} yeni yemek eklendi.`;
                showNotification(message, "success");
                console.log("Eklenen yemek sayısı:", newCount);
            } catch (error) {
                showNotification("Hata: Geçersiz JSON dosyası!", "warning");
                console.error("JSON parse hatası:", error);
            }
        };
        reader.readAsText(file);
    };
    input.click();
}
function processJsonFoodList(jsonData) {
    console.log("processJsonFoodList çalışıyor...");
    const newMeals = jsonData.meals || jsonData;
    if (!Array.isArray(newMeals)) {
        showNotification("Hata: JSON 'meals' array formatında olmalı!", "warning");
        console.log("Hatalı JSON formatı:", jsonData);
        return;
    }

    let newCount = 0;
    const addedMeals = [];

    console.log("Mevcut kategoriler:", categories);
    newMeals.forEach(meal => {
        let exists = false;
        categories.forEach(category => {
            if (category.items.some(item => item.name.toLowerCase() === meal.name.toLowerCase())) {
                exists = true;
                console.log(`${meal.name} zaten mevcut, eklenmeyecek.`);
            }
        });

        if (!exists) {
            const newFood = {
                name: meal.name,
                calories: parseFloat(meal.calories) || 0,
                protein: parseFloat(meal.protein) || 0,
                carbs: parseFloat(meal.carbs) || 0,
                fat: parseFloat(meal.fat) || 0,
                category: meal.category || "Tanımsız",
                mealType: meal.mealType || ["lunch"],
                tags: meal.tags || ["keto"],
                role: meal.role || determineRole(meal.name),
                keto: meal.keto !== undefined ? meal.keto : true,
                lowcarb: meal.lowcarb !== undefined ? meal.lowcarb : true,
                fillerLunch: meal.fillerLunch || false,
                fillerDinner: meal.fillerDinner || false,
                step: parseFloat(meal.step) || 0.5,
                maxQuantity: parseFloat(meal.maxQuantity) || 1,
                minQuantity: parseFloat(meal.minQuantity) || 0.5
            };

            let category = categories.find(cat => cat.name === newFood.category);
            if (!category) {
                category = { name: newFood.category, items: [] };
                categories.push(category);
                console.log(`Yeni kategori oluşturuldu: ${newFood.category}`);
            }
            category.items.push(newFood);
            newCount++;
            addedMeals.push(newFood.name);
            console.log(`Yeni yemek eklendi: ${newFood.name}`);
        }
    });

    loadCategories(); // Arayüzü güncelle
    const message = `🍽 Yemek listesi eklendi! Çakışanlar korunarak ${newCount} yeni yemek eklendi.`;
    showNotification(message, "success");
    console.log("İşlem tamamlandı. Eklenen yemekler:", addedMeals);
    console.log("Gösterilen mesaj:", message);
}

function exportFoodList() {
    const jsonContent = JSON.stringify({ categories: categories }, null, 2);
    const blob = new Blob([jsonContent], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'food_list.json';
    a.click();
    URL.revokeObjectURL(url);
    showNotification("Son yemek listesi JSON olarak dışa aktarıldı!");
}



        function loadCompatibilityRules() {
            const compatList = document.getElementById('compatibilityList');
            compatList.innerHTML = compatibilityTable.map((rule, index) => `
                <div class="mb-1 d-flex justify-content-between">
                    <span>${rule.keyword1} ↔ ${rule.keyword2.join(', ')} (${rule.degree})</span>
                    <button class="btn btn-danger btn-sm" onclick="deleteCompatibilityRule(${index})" title="Sil"><i class="bi bi-trash"></i></button>
                </div>
            `).join('');
        }

        function deleteCompatibilityRule(index) {
            compatibilityTable.splice(index, 1);
            loadCompatibilityRules();
            showNotification("Uyumluluk kuralı silindi!");
        }
        
        function addMealTemplate() {
            const mealType = document.getElementById('templateMealType').value;
            const frequency = parseInt(document.getElementById('templateFrequency').value);
            const items = [];
            const templateItems = document.getElementById('templateItems');
            const rows = templateItems.getElementsByClassName('row');
            for (let i = 0; i < rows.length; i++) {
                const keyword = document.getElementById(`templateItem${i + 1}Keyword`).value;
                const role = document.getElementById(`templateItem${i + 1}Role`).value;
                const quantity = parseInt(document.getElementById(`templateItem${i + 1}Quantity`).value);
                if (keyword) items.push({ keyword, role, quantity });
            }
            mealTemplates.push({ mealType, frequency, items });
            loadMealTemplates();
            templateItems.innerHTML = `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="templateItem1Keyword" class="form-label">Etiket</label>
                        <input type="text" id="templateItem1Keyword" class="form-control" placeholder="örn: yumurta, omlet">
                    </div>
                    <div class="col-4">
                        <label for="templateItem1Role" class="form-label">Rol</label>
                        <select id="templateItem1Role" class="form-select">
                            <option value="mainDish">Ana Yemek</option>
                            <option value="sideDish">Yan Yemek</option>
                            <option value="drink">İçecek</option>
                            <option value="soup">Çorba</option>
                            <option value="dessert">Tatlı</option>
                            <option value="fruit">Meyve</option>
                            <option value="bread">Ekmek</option>
                            <option value="snack">Atıştırmalık</option>
                            <option value="supplement">Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="templateItem1Quantity" class="form-label">Sayı</label>
                        <input type="number" id="templateItem1Quantity" class="form-control" value="1" min="1">
                    </div>
                </div>
            `;
            showNotification("Öğün şablonu eklendi!");
        }

        function addTemplateItem() {
            const templateItems = document.getElementById('templateItems');
            const itemCount = templateItems.getElementsByClassName('row').length + 1;
            templateItems.innerHTML += `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="templateItem${itemCount}Keyword" class="form-label">Etiket</label>
                        <input type="text" id="templateItem${itemCount}Keyword" class="form-control" placeholder="örn: yumurta, omlet">
                    </div>
                    <div class="col-4">
                        <label for="templateItem${itemCount}Role" class="form-label">Rol</label>
                        <select id="templateItem${itemCount}Role" class="form-select">
                            <option value="mainDish">Ana Yemek</option>
                            <option value="sideDish">Yan Yemek</option>
                            <option value="drink">İçecek</option>
                            <option value="soup">Çorba</option>
                            <option value="dessert">Tatlı</option>
                            <option value="fruit">Meyve</option>
                            <option value="bread">Ekmek</option>
                            <option value="snack">Atıştırmalık</option>
                            <option value="supplement">Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="templateItem${itemCount}Quantity" class="form-label">Sayı</label>
                        <input type="number" id="templateItem${itemCount}Quantity" class="form-control" value="1" min="1">
                    </div>
                </div>
            `;
        }

        function loadMealTemplates() {
            console.log("mealTemplates içeriği:", mealTemplates);
    const templatesList = document.getElementById('mealTemplatesList');
    templatesList.innerHTML = mealTemplates.map((template, index) => `
        <div class="mb-1 d-flex justify-content-between">
            <span>${template.mealType} (${template.frequency}x): ${template.items.map(i => `${i.keyword} (${i.role})`).join(', ')}</span>
            <div>
                <button class="btn btn-success btn-sm" onclick="addTemplateToMeal(${index})" title="Öğüne Ekle">
                    <i class="bi bi-plus-circle"></i>
                </button>
                <button class="btn btn-warning btn-sm" onclick="editMealTemplate(${index})" title="Düzenle"><i class="bi bi-pencil"></i></button>
                <button class="btn btn-danger btn-sm" onclick="deleteMealTemplate(${index})" title="Sil"><i class="bi bi-trash"></i></button>
            </div>
        </div>
    `).join('');
}

function addTemplateToMeal(index) {
    const template = mealTemplates[index];
    if (!template) {
        alert("Şablon bulunamadı!");
        return;
    }

    // Şablondaki öğeleri uygun öğüne ekleme işlemi
    template.items.forEach(item => {
        const food = findFood(item.keyword); // Yemeği bul
        if (food) {
            // Yemeği öğüne ekle
            weeks[selectedWeek - 1].days[selectedDay].meals[template.mealType].push({
                name: food.name,
                quantity: item.quantity
            });
        } else {
            console.error(`Yemek bulunamadı: ${item.keyword}`);
        }
    });

    // Öğünleri yeniden çiz ve makroları hesapla
    renderMeals();
    calculateMacros();
    showNotification("Şablon öğüne eklendi!");
}
function addTemplateToMeal(index) {
    const template = mealTemplates[index];
    if (!template) {
        alert("Şablon bulunamadı!");
        return;
    }

    // Şablondaki öğeleri uygun öğüne ekleme işlemi
    template.items.forEach(item => {
        const food = findFood(item.keyword); // Yemeği bul
        if (food) {
            // Yemeği öğüne ekle
            weeks[selectedWeek - 1].days[selectedDay].meals[template.mealType].push({
                name: food.name,
                quantity: item.quantity
            });
        } else {
            console.error(`Yemek bulunamadı: ${item.keyword}`);
        }
    });

    // Veri modelini kontrol etmek için konsola yazdır
    console.log("Güncellenmiş weeks dizisi:", weeks);

    // Öğünleri yeniden çiz ve makroları hesapla
    renderMeals();
    calculateMacros();
    showNotification("Şablon öğüne eklendi!");
}

// Şablondaki bir öğeyi ilgili öğüne ekleyen fonksiyon
function addMealItem(mealType, keyword, role, quantity) {
    const mealSection = document.getElementById(`${mealType}Meal`);
    if (!mealSection) {
        alert(`Öğün bölümü bulunamadı: ${mealType}`);
        return;
    }

    // Yeni yemek öğesi oluştur
    const mealItem = document.createElement("div");
    mealItem.classList.add("meal-item");
    mealItem.innerHTML = `${keyword} (${role}) - Miktar: ${quantity}`;

    // Öğüne DOM'a ekle
    mealSection.appendChild(mealItem);

    // Veri modeline de ekle
    weeks[selectedWeek - 1].days[selectedDay].meals[mealType].push({
        name: keyword,
        quantity: quantity
    });
}



        function editMealTemplate(index) {
            const template = mealTemplates[index];
            document.getElementById('editTemplateIndex').value = index;
            document.getElementById('editTemplateName').value = `${template.mealType}_${index}`;
            document.getElementById('editTemplateMealType').value = template.mealType;
            document.getElementById('editTemplateFrequency').value = template.frequency;
            const itemsDiv = document.getElementById('editTemplateItems');
            itemsDiv.innerHTML = template.items.map((item, i) => `
                <div class="row mb-1">
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Keyword" class="form-label">Etiket</label>
                        <input type="text" id="editTemplateItem${i + 1}Keyword" class="form-control" value="${item.keyword}">
                    </div>
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Role" class="form-label">Rol</label>
                        <select id="editTemplateItem${i + 1}Role" class="form-select">
                            <option value="mainDish" ${item.role === 'mainDish' ? 'selected' : ''}>Ana Yemek</option>
                            <option value="sideDish" ${item.role === 'sideDish' ? 'selected' : ''}>Yan Yemek</option>
                            <option value="drink" ${item.role === 'drink' ? 'selected' : ''}>İçecek</option>
                            <option value="soup" ${item.role === 'soup' ? 'selected' : ''}>Çorba</option>
                            <option value="dessert" ${item.role === 'dessert' ? 'selected' : ''}>Tatlı</option>
                            <option value="fruit" ${item.role === 'fruit' ? 'selected' : ''}>Meyve</option>
                            <option value="bread" ${item.role === 'bread' ? 'selected' : ''}>Ekmek</option>
                            <option value="snack" ${item.role === 'snack' ? 'selected' : ''}>Atıştırmalık</option>
                            <option value="supplement" ${item.role === 'supplement' ? 'selected' : ''}>Ek</option>
                        </select>
                    </div>
                    <div class="col-4">
                        <label for="editTemplateItem${i + 1}Quantity" class="form-label">Sayı</label>
                        <input type="number" id="editTemplateItem${i + 1}Quantity" class="form-control" value="${item.quantity}" min="1">
                    </div>
                </div>
            `).join('');
            document.getElementById('editTemplateForm').style.display = 'block';
        }

        function saveEditedTemplate(event) {
            event.preventDefault();
            const index = parseInt(document.getElementById('editTemplateIndex').value);
            const mealType = document.getElementById('editTemplateMealType').value;
            const frequency = parseInt(document.getElementById('editTemplateFrequency').value);
            const items = [];
            const itemsDiv = document.getElementById('editTemplateItems');
            const rows = itemsDiv.getElementsByClassName('row');
            for (let i = 0; i < rows.length; i++) {
                const keyword = document.getElementById(`editTemplateItem${i + 1}Keyword`).value;
                const role = document.getElementById(`editTemplateItem${i + 1}Role`).value;
                const quantity = parseInt(document.getElementById(`editTemplateItem${i + 1}Quantity`).value);
                if (keyword) items.push({ keyword, role, quantity });
            }
            mealTemplates[index] = { mealType, frequency, items };
            loadMealTemplates();
            cancelEditTemplate();
            showNotification("Şablon güncellendi!");
        }

        function cancelEditTemplate() {
            document.getElementById('editTemplateForm').style.display = 'none';
        }
        function deleteMealTemplate(index) {
            mealTemplates.splice(index, 1);
            loadMealTemplates();
            showNotification("Şablon silindi!");
        }
        function generateRandomTemplate() {
            rules.forEach(rule => {
        if (rule.type === 'frequency' && rule.scope === 'weekly' && rule.name) {
            let weeklyCount = 0;
            weeks.forEach(week => {
                Object.values(week.days).forEach(day => {
                    ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                        weeklyCount += (day.meals[mt] || []).filter(item => 
                            item.name.toLowerCase().includes(rule.name.toLowerCase())
                        ).length;
                    });
                });
            });
            if (weeklyCount > rule.frequency) {
                weeks.forEach(week => {
                    Object.values(week.days).forEach(day => {
                        ['breakfast', 'lunch', 'dinner'].forEach(mt => {
                            day.meals[mt] = day.meals[mt].filter(item => {
                                if (item.name.toLowerCase().includes(rule.name.toLowerCase())) {
                                    if (weeklyCount <= rule.frequency) return true;
                                    weeklyCount--;
                                    return false;
                                }
                                return true;
                            });
                        });
                    });
                });
            }
        }
    });
            const mealType = document.getElementById('templateMealType').value;
            const frequency = parseInt(document.getElementById('templateFrequency').value);
            const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
            const likedFoods = patientData.likedFoods || [];
            const dislikedFoods = patientData.dislikedFoods || [];
            const items = [];
            const availableFoods = categories.flatMap(cat => cat.items)
                .filter(f => f.mealType.includes(mealType) && (dietMode === 'keto' ? f.keto : f.lowcarb))
                .filter(f => !dislikedFoods.some(df => f.name.toLowerCase().includes(df.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))));
            const rolesToInclude = ['mainDish', 'sideDish', 'drink', 'soup', 'dessert'];
            rolesToInclude.forEach(role => {
                const filtered = availableFoods.filter(f => f.role === role);
                if (filtered.length > 0) {
                    const preferred = filtered.filter(f => likedFoods.some(lf => f.name.toLowerCase().includes(lf.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(lf.toLowerCase()))));
                    const food = preferred.length > 0 ? preferred[Math.floor(Math.random() * preferred.length)] : filtered[Math.floor(Math.random() * filtered.length)];
                    items.push({ keyword: food.name, role, quantity: 1 });
                }
            });
            mealTemplates.push({ mealType, frequency, items });
            loadMealTemplates();
            showNotification("Rastgele şablon oluşturuldu!");
        }
        // Mevcut generateAutoPlan fonksiyonunu bulun (yaklaşık 2200. satır) ve komple şu kodla değiştirin:
        function generateAutoPlan() {
    const settings = getPlanningSettings();
    settings.targetCalories = globalTargetCalories || 1064;
    settings.targetProtein = globalTargetProtein || 56;
    settings.targetCarbs = globalTargetCarbs || 21;
    settings.targetFat = globalTargetFat || 83;
    settings.macroTolerance = parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1;
    settings.breakfastMin = parseInt(document.getElementById('breakfastMin')?.value) || 1;
    settings.breakfastMax = parseInt(document.getElementById('breakfastMax')?.value) || 1;
    settings.lunchMin = parseInt(document.getElementById('lunchMin')?.value) || 2;
    settings.lunchMax = parseInt(document.getElementById('lunchMax')?.value) || 4;
    settings.dinnerMin = parseInt(document.getElementById('dinnerMin')?.value) || 2;
    settings.dinnerMax = parseInt(document.getElementById('dinnerMax')?.value) || 4;

    console.log("generateAutoPlan: Planlama başlatılıyor, hedef kalori:", settings.targetCalories);
    generatePlan(settings);
}

function generateFastPlan() {
    console.log("generateFastPlan başladı...");
    saveState();

    // AvailableFoods’u tanımla
    const availableFoods = categories.flatMap(cat => cat.items)
        .filter(f => f.calories > 0 && (dietMode === 'keto' ? f.keto : f.lowcarb));

    // 5 farklı plan için iterasyon
    const plans = [];
    const sapmalar = [];
    for (let i = 0; i < 5; i++) {
        // Yeni haftayı sıfırs
        weeks = [{
            days: {
                monday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                tuesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                wednesday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                thursday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                friday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                saturday: { meals: { breakfast: [], lunch: [], dinner: [] } },
                sunday: { meals: { breakfast: [], lunch: [], dinner: [] } }
            }
        }];

        // Planı oluştur
        const settings = getPlanningSettings();
        generatePlan(settings);

        // Protein ve yağ sapmasını hesapla
        let totalProteinSapma = 0;
        let totalFatSapma = 0;
        let daysCounted = 0;

        Object.values(weeks[0].days).forEach(day => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                const meal = day.meals[mealType] || [];
                const mealProtein = meal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.protein * (item.quantity || 1) : 0);
                }, 0);
                const mealFat = meal.reduce((sum, item) => {
                    const food = availableFoods.find(f => f.name === item.name);
                    return sum + (food ? food.fat * (item.quantity || 1) : 0);
                }, 0);

                const mealRatio = mealType === 'breakfast' ?
                    (1 - (settings.lunchCalorieRatio || 40) / 100 - (settings.dinnerCalorieRatio || 30) / 100) :
                    mealType === 'lunch' ? (settings.lunchCalorieRatio || 40) / 100 :
                    (settings.dinnerCalorieRatio || 30) / 100;

                const targetProtein = (settings.targetProtein || 56) * mealRatio;
                const targetFat = (settings.targetFat || 84) * mealRatio;

                totalProteinSapma += Math.abs(mealProtein - targetProtein) / targetProtein;
                totalFatSapma += Math.abs(mealFat - targetFat) / targetFat;
                daysCounted++;
            });
        });

        // Ortalama sapma
        const avgProteinSapma = totalProteinSapma / daysCounted;
        const avgFatSapma = totalFatSapma / daysCounted;

        plans.push(JSON.parse(JSON.stringify(weeks)));
        sapmalar.push({ protein: avgProteinSapma, fat: avgFatSapma });
        console.log(`Plan ${i + 1}: Protein sapma ${avgProteinSapma.toFixed(2)}, Yağ sapma ${avgFatSapma.toFixed(2)}`);
    }

    // En iyi planı seç (protein öncelikli)
    let bestPlanIndex = 0;
    let minSapma = Infinity;
    sapmalar.forEach((sapma, index) => {
        const score = sapma.protein * 0.6 + sapma.fat * 0.4; // Protein %60, yağ %40 ağırlık
        if (score < minSapma) {
            minSapma = score;
            bestPlanIndex = index;
        }
    });

    // En iyi planı uygula
    weeks = plans[bestPlanIndex];
    selectedDay = "monday";
    selectedWeek = 1;
    renderMeals();
    calculateMacros();
    console.log("En iyi plan seçildi:", bestPlanIndex + 1);

    // Bildirim
    if (typeof showNotification === 'function') {
        showNotification("Hızlı planlama tamamlandı! En iyi plan seçildi.", "success");
    }
}

function getPlanningSettings() {
    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    return {
        likedFoods: patientData.likedFoods || [],
        dislikedFoods: patientData.dislikedFoods || [],
        minItems: parseInt(document.getElementById('minItemsPerMeal').value) || 1,
        maxItems: parseInt(document.getElementById('maxItemsPerMeal').value) || 5,
        flexibility: parseFloat(document.getElementById('calorieFlexibility').value) / 100 || 0.1,
        targetCalories: parseFloat(document.getElementById('targetCalories').value) || 2000,
        targetProtein: parseFloat(document.getElementById('targetProtein').value) || 100,
        targetFat: parseFloat(document.getElementById('targetFat').value) || 150,
        targetCarbs: parseFloat(document.getElementById('targetCarbs').value) || (dietMode === 'keto' ? 30 : 75),
        breakfastMin: parseInt(document.getElementById('breakfastMin').value) || 1,
        breakfastMax: parseInt(document.getElementById('breakfastMax').value) || 3,
        lunchMin: parseInt(document.getElementById('lunchMin').value) || 2,
        lunchMax: parseInt(document.getElementById('lunchMax').value) || 4,
        dinnerMin: parseInt(document.getElementById('dinnerMin').value) || 2,
        dinnerMax: parseInt(document.getElementById('dinnerMax').value) || 4,
        macroPriority: parseInt(document.getElementById('macroPriority').value) || 1,
        templatePriority: parseInt(document.getElementById('templatePriority').value) || 1,
        rulePriority: parseInt(document.getElementById('rulePriority').value) || 1,
        compatibilityPriority: parseInt(document.getElementById('compatibilityPriority').value) || 1,
        managementPriority: parseInt(document.getElementById('managementPriority').value) || 1,
        macroTolerance: parseInt(document.getElementById('macroTolerance').value) / 100 || 0.05,
        optimizeCoefficients: document.getElementById('optimizeCoefficients').checked || false,
        breakfastPriority: document.getElementById('breakfastPriority').value || 'medium',
        lunchPriority: document.getElementById('lunchPriority').value || 'medium',
        dinnerPriority: document.getElementById('dinnerPriority').value || 'medium',
        fixedBreakfastMeal: document.getElementById('fixedBreakfastMeal').value || '',
        fixedLunchMeal: document.getElementById('fixedLunchMeal').value || '',
        fixedDinnerMeal: document.getElementById('fixedDinnerMeal').value || ''
    };
}

// applyAllRules fonksiyonu
function applyAllRules() {
    try {
        if (typeof saveState === 'function') {
            saveState(); // İşlemden önce durumu kaydet
        }
        const settings = getPlanningSettings();
        if (!settings) {
            throw new Error("Planlama ayarları alınamadı!");
        }

        settings.rulePriority = 100; // Kurallara maksimum öncelik ver
        generatePlan(settings); // Planı oluştur
        if (typeof showNotification === 'function') {
            showNotification("Tüm kurallar başarıyla uygulandı!", "success");
        }
    } catch (error) {
        console.error("Kurallar uygulanırken hata oluştu:", error);
        if (typeof showNotification === 'function') {
            showNotification(`Kurallar uygulanamadı: ${error.message}`, "danger");
        }
    }
}

// Formları tanımla
const forms = {
    frequency: document.getElementById('frequencyRuleForm'),
    pair: document.getElementById('pairRuleForm'),
    dependOn: document.getElementById('dependOnRuleForm'),
    categoryLock: document.getElementById('categoryLockRuleForm'),
    default: document.getElementById('defaultForm')
};

// Tüm formları gizle
function hideAllForms() {
    Object.values(forms).forEach(form => {
        if (form) form.style.display = 'none';
    });
}

// Kural tipine göre formu göster
function showRuleForm(type) {
    if (!forms || typeof forms !== 'object') {
        console.error("forms nesnesi tanımlı değil veya geçersiz!");
        return;
    }

    hideAllForms(); // Önce tüm formları gizle

    const ruleFormMap = {
        'frequency': 'frequencyRuleForm',
        'pairWith': 'pairRuleForm',
        'avoidPair': 'pairRuleForm',
        'dependOn': 'dependOnRuleForm',
        'categoryLock': 'categoryLockRuleForm',
        'maxRoleCount': 'defaultForm' // Yeni kural tipi için varsayılan form
    };

    const formId = ruleFormMap[type] || 'defaultForm';
    const form = forms[formId.replace('RuleForm', '').toLowerCase()] || document.getElementById(formId);

    if (form) {
        form.style.display = 'block';

        // Ek input alanlarını kontrol et ve göster/gizle (yalnızca defaultForm için)
        if (formId === 'defaultForm') {
            const frequencyInput = document.getElementById('frequencyInput');
            const countInput = document.getElementById('countInput');
            const pairInput = document.getElementById('pairInput');

            if (frequencyInput) frequencyInput.style.display = type === 'frequency' ? 'block' : 'none';
            if (countInput) countInput.style.display = type === 'maxRoleCount' ? 'block' : 'none'; // maxRoleCount için countInput
            if (pairInput) pairInput.style.display = ['pairWith', 'avoidPair'].includes(type) ? 'block' : 'none';
        }
    } else {
        console.warn(`${formId} bulunamadı! Kural tipi: ${type}`);
    }

    if (!ruleFormMap[type]) {
        console.warn(`Desteklenmeyen kural tipi: ${type}`);
    }
}

const ruleFormMap = {
    frequency: 'frequencyRuleForm',
    pairWith: 'pairRuleForm',
    avoidPair: 'pairRuleForm',
    dependOn: 'dependOnRuleForm',
    categoryLock: 'categoryLockRuleForm'
};

function checkKeywordConflict(foodName, currentMeal) {
    const food = findFood(foodName);
    if (!food || !food.tags || !Array.isArray(food.tags)) {
        console.log(`checkKeywordConflict: ${foodName} için tags bulunamadı veya geçersiz.`);
        return false;
    }

    // Sadece "keto" ve "lowcarb" etiketlerini hariç tut
    const excludedTags = ["keto", "lowcarb"];
    const foodTags = food.tags
        .map(tag => tag.toLowerCase())
        .filter(tag => !excludedTags.includes(tag));

    if (foodTags.length === 0) {
        console.log(`checkKeywordConflict: ${foodName} için geçerli etiket yok (tags: ${food.tags.join(", ")}).`);
        return false;
    }

    for (const mealItem of currentMeal) {
        const existingFood = findFood(mealItem.name);
        if (!existingFood || !existingFood.tags || !Array.isArray(existingFood.tags)) {
            console.log(`checkKeywordConflict: ${mealItem.name} için tags bulunamadı veya geçersiz.`);
            continue;
        }

        const existingTags = existingFood.tags
            .map(tag => tag.toLowerCase())
            .filter(tag => !excludedTags.includes(tag));

        if (foodTags.some(tag => existingTags.includes(tag))) {
            const commonTags = foodTags.filter(tag => existingTags.includes(tag));
            console.log(`"${foodName}" eklenemedi: "${mealItem.name}" ile etiket çakışması (${commonTags.join(", ")}).`);
            return true;
        }
    }
    console.log(`checkKeywordConflict: ${foodName} için çakışma bulunmadı (tags: ${foodTags.join(", ")}).`);
    return false;
}


if (!forms.frequency) {
    console.warn("frequencyRuleForm bulunamadı!");
    if (typeof showNotification === 'function') {
        showNotification("Frequency kural formu bulunamadı!", "warning");
    }
}

// Global yardımcı fonksiyonlar
function checkDependOn(foodName, mealItems) {
    const dependentRule = rules.find(r => r.type === 'dependOn' && r.food?.toLowerCase().includes(foodName.toLowerCase()));
    if (!dependentRule) return true;
    const requiredFood = dependentRule.requiredFood?.toLowerCase();
    return mealItems.some(item => item.name.toLowerCase().includes(requiredFood));
}

function checkCompatibility(foodName, currentMeal) {
    const compatRules = rules.filter(rule => rule.type === 'compatibility' && rule.keyword1.toLowerCase() === foodName.toLowerCase());
    if (!compatRules.length) return true;

    let canAdd = true;
    compatRules.forEach(rule => {
        const pairedFoods = rule.keyword2;
        const pairedCount = pairedFoods.filter(kw => 
            currentMeal.some(item => item.name.toLowerCase().includes(kw.toLowerCase()))
        ).length;

        if (rule.degree > 0) {
            if (rule.conjunction === 'and' && pairedCount < pairedFoods.length) canAdd = false;
            if (rule.conjunction === 'or' && pairedCount === 0) canAdd = false;
        } else if (rule.degree < 0) {
            if (pairedCount > 0) canAdd = false;
            if (rule.degree === -5 && pairedFoods.length === 0 && currentMeal.length === 0) canAdd = false;
        }
    });
    return canAdd;
}

function findBestFood(foodList, targets, currentMeal, mealType, validRules) {
    return foodList
        .filter(f => checkCompatibility(f.name, currentMeal) && checkDependOn(f.name, currentMeal) && !currentMeal.some(item => item.name === f.name))
        .map(food => {
            const score = 
                (targets.protein > 0 ? Math.min(food.protein / targets.protein, 1) * 0.4 : 0) +
                (targets.fat > 0 ? Math.min(food.fat / targets.fat, 1) * 0.3 : 0) +
                (targets.carbs > 0 ? Math.min(food.carbs / targets.carbs, 1) * 0.15 : 0) +
                (targets.calories > 0 ? Math.min(food.calories / targets.calories, 1) * 0.15 : 0);
            return { food, score };
        })
        .sort((a, b) => b.score - a.score)[0]?.food;
}

function calculateOptimalQuantity(food, targets, currentMeal, mealType, availableFoods) {
    const minQty = food.minQuantity || 0.5;
    const maxQty = food.maxQuantity || 1;
    const step = food.step || 0.5;

    let bestQty = minQty;
    let minDiff = Infinity;

    for (let qty = minQty; qty <= maxQty; qty += step) {
        const diff = 
            Math.abs(targets.protein - food.protein * qty) * 0.4 +
            Math.abs(targets.fat - food.fat * qty) * 0.3 +
            Math.abs(targets.carbs - food.carbs * qty) * 0.15 +
            Math.abs(targets.calories - food.calories * qty) * 0.15;
        if (diff < minDiff) {
            minDiff = diff;
            bestQty = qty;
        }
    }
    return bestQty;
}
function getCurrentMacro(meal, macro, foodList) {
    return meal.reduce((sum, item) => {
        const food = foodList.find(f => f.name === item.name);
        return sum + (food ? food[macro] * item.quantity : 0);
    }, 0);
}

function isMealTypeCompatible(food, mealType) {
    const mealTypes = Array.isArray(food.mealType) ? food.mealType : [food.mealType];
    return mealTypes.includes(mealType);
}

// Ana generatePlan fonksiyonu
document.getElementById('fixedBreakfastMeal').value = 'Kurşun Geçirmez Kahve';

function generatePlan(settings) {
    if (!weeks || !Array.isArray(weeks)) {
        console.error("weeks yapısı tanımlı değil veya geçersiz!");
        return;
    }

    console.log("generatePlan: Planlama yapılıyor, hedefler:", {
        calories: settings.targetCalories,
        protein: settings.targetProtein,
        carbs: settings.targetCarbs,
        fat: settings.targetFat
    });

    const availableFoods = categories.flatMap(cat => cat.items)
        .filter(f => f.calories > 0 && 
                     (dietMode === 'keto' ? f.keto : f.lowcarb) &&
                     !settings.dislikedFoods.some(df => f.name.toLowerCase().includes(df.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))))
        .sort((a, b) => {
            const aLiked = settings.likedFoods.some(lf => a.name.toLowerCase().includes(lf.toLowerCase()) || a.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
            const bLiked = settings.likedFoods.some(lf => b.name.toLowerCase().includes(lf.toLowerCase()) || a.tags.some(t => t.toLowerCase().includes(lf.toLowerCase())));
            return bLiked - aLiked;
        });

    console.log("availableFoods filtrelendi, sevmediği yemekler hariç tutuldu:", availableFoods.map(f => f.name));

    const validRules = rules.filter(rule => rule && typeof rule === 'object' && (
        rule.type === 'frequency' || rule.type === 'dependOn' || rule.type === 'maxRoleCount'
    ));
    const prioritizedRules = validRules;

    const targetCalories = settings.targetCalories;
    const targetProtein = settings.targetProtein;
    const targetFat = settings.targetFat;
    const targetCarbs = settings.targetCarbs;
    const macroTolerance = settings.macroTolerance || 0.1;

    if (!targetCalories || !targetProtein || !targetCarbs || !targetFat) {
        console.error("Makro hedefleri tanımlı değil!", settings);
        showNotification("Makro hedefleri eksik, planlama yapılamadı!", "warning");
        return;
    }

    const ruleAppliedFoods = new Set();

    prioritizedRules.forEach(rule => {
        if (rule.type === 'frequency') {
            let matchingFoods = [];
            if (rule.nameCheck && rule.names?.length) {
                matchingFoods = availableFoods.filter(food =>
                    rule.names.some(name => food.name.toLowerCase().includes(name.toLowerCase()))
                );
            } else if (rule.nameCheck && rule.name) {
                matchingFoods = availableFoods.filter(food => food.name.toLowerCase().includes(rule.name.toLowerCase()));
            } else {
                matchingFoods = availableFoods;
            }

            if (rule.tagsCheck && rule.tags?.length) {
                matchingFoods = matchingFoods.filter(food => rule.tags.some(tag => food.tags?.some(t => t.toLowerCase().includes(tag.toLowerCase()))));
            }

            if (rule.roleCheck && rule.role) matchingFoods = matchingFoods.filter(food => food.role === rule.role);
            if (rule.catCheck && rule.category) matchingFoods = matchingFoods.filter(food => categories.find(cat => cat.name === rule.category)?.items.some(item => item.name === food.name && item.calories > 0));

            if (matchingFoods.length === 0) {
                console.warn(`Kural (${rule.id}) için uygun yemek bulunamadı: ${JSON.stringify(rule)}`);
                return;
            }

            weeks.forEach((week, weekIndex) => {
                Object.values(week.days).forEach(day => {
                    if (rule.scope === 'meal' && rule.mealType) {
                        const mealItems = day.meals[rule.mealType] = day.meals[rule.mealType] || [];
                        const count = mealItems.filter(item => matchingFoods.some(f => f.name === item.name)).length;

                        if (rule.frequencyType === 'min' && count < rule.frequency) {
                            let remaining = rule.frequency - count;
                            while (remaining > 0 && matchingFoods.length > 0) {
                                const food = matchingFoods[Math.floor(Math.random() * matchingFoods.length)];
                                if (!mealItems.some(item => item.name === food.name) && isMealTypeCompatible(food, rule.mealType)) {
                                    const quantity = calculateOptimalQuantity(food, {
                                        calories: targetCalories,
                                        protein: targetProtein,
                                        fat: targetFat,
                                        carbs: targetCarbs
                                    }, mealItems, rule.mealType, availableFoods);
                                    mealItems.push({ name: food.name, quantity });
                                    ruleAppliedFoods.add(food.name);
                                    remaining -= quantity;
                                } else {
                                    matchingFoods = matchingFoods.filter(f => f.name !== food.name);
                                }
                            }
                        } else if (rule.frequencyType === 'max' && count > rule.frequency) {
                            let excess = count - rule.frequency;
                            while (excess > 0) {
                                const index = mealItems.findIndex(item => matchingFoods.some(f => f.name === item.name));
                                if (index !== -1) {
                                    mealItems.splice(index, 1);
                                    excess--;
                                } else break;
                            }
                        } else if (rule.frequencyType === 'exact' && count !== rule.frequency) {
                            if (count < rule.frequency) {
                                let remaining = rule.frequency - count;
                                while (remaining > 0 && matchingFoods.length > 0) {
                                    const food = matchingFoods[Math.floor(Math.random() * matchingFoods.length)];
                                    if (!mealItems.some(item => item.name === food.name) && isMealTypeCompatible(food, rule.mealType)) {
                                        const quantity = calculateOptimalQuantity(food, {
                                            calories: targetCalories,
                                            protein: targetProtein,
                                            fat: targetFat,
                                            carbs: targetCarbs
                                        }, mealItems, rule.mealType, availableFoods);
                                        mealItems.push({ name: food.name, quantity });
                                        ruleAppliedFoods.add(food.name);
                                        remaining -= quantity;
                                    } else {
                                        matchingFoods = matchingFoods.filter(f => f.name !== food.name);
                                    }
                                }
                            } else if (count > rule.frequency) {
                                let excess = count - rule.frequency;
                                while (excess > 0) {
                                    const index = mealItems.findIndex(item => matchingFoods.some(f => f.name === item.name));
                                    if (index !== -1) {
                                        mealItems.splice(index, 1);
                                        excess--;
                                    } else break;
                                }
                            }
                        }
                    }
                });
            });
        } else if (rule.type === 'dependOn' && rule.food && rule.requiredFood) {
            weeks.forEach((week, weekIndex) => {
                Object.values(week.days).forEach(day => {
                    ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                        let mealItems = day.meals[mealType] || [];
                        const hasRequired = mealItems.some(item => item.name.toLowerCase().includes(rule.requiredFood.toLowerCase()));
                        const hasFood = mealItems.some(item => item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        const dependentFood = availableFoods.find(f => f.name.toLowerCase().includes(rule.food.toLowerCase()));
                        if (hasFood && !hasRequired) {
                            day.meals[mealType] = mealItems.filter(item => !item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        } else if (!hasFood && hasRequired && dependentFood && Math.random() < 0.5 && isMealTypeCompatible(dependentFood, mealType)) {
                            const quantity = calculateOptimalQuantity(dependentFood, {
                                calories: targetCalories,
                                protein: targetProtein,
                                fat: targetFat,
                                carbs: targetCarbs
                            }, mealItems, mealType, availableFoods);
                            day.meals[mealType].push({ name: dependentFood.name, quantity });
                            ruleAppliedFoods.add(dependentFood.name);
                        }
                    });
                });
            });
        } else if (rule.type === 'maxRoleCount' && rule.mealType && rule.role && rule.count !== undefined) {
            weeks.forEach((week) => {
                Object.values(week.days).forEach(day => {
                    const mealItems = day.meals[rule.mealType] || [];
                    const roleCount = mealItems.filter(item => {
                        const food = availableFoods.find(f => f.name === item.name);
                        return food && food.role === rule.role;
                    }).length;
                    if (roleCount > rule.count) {
                        let excess = roleCount - rule.count;
                        while (excess > 0) {
                            const index = mealItems.findIndex(item => {
                                const food = availableFoods.find(f => f.name === item.name);
                                return food && food.role === rule.role;
                            });
                            if (index !== -1) {
                                const removedItem = mealItems.splice(index, 1)[0];
                                excess--;
                                console.log(`maxRoleCount kuralı: ${rule.role} rolünden ${removedItem.name} kaldırıldı (${rule.mealType})`);
                            } else break;
                        }
                        day.meals[rule.mealType] = mealItems;
                    }
                });
            });
        }
    });

    weeks.forEach((week, weekIndex) => {
        Object.entries(week.days).forEach(([day, dayData]) => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                const mealRatio = mealType === 'breakfast' ?
                    (1 - parseFloat(document.getElementById('lunchCalorieRatio')?.value || 40) / 100 - parseFloat(document.getElementById('dinnerCalorieRatio')?.value || 30) / 100) :
                    mealType === 'lunch' ? parseFloat(document.getElementById('lunchCalorieRatio')?.value || 40) / 100 :
                    parseFloat(document.getElementById('dinnerCalorieRatio')?.value || 30) / 100;

                const mealTargets = {
                    calories: targetCalories * mealRatio,
                    protein: targetProtein * mealRatio,
                    fat: targetFat * mealRatio,
                    carbs: targetCarbs * mealRatio
                };

                let currentMeal = dayData.meals[mealType] || [];
                const mealFoods = availableFoods.filter(f => isMealTypeCompatible(f, mealType) &&
                    !settings.dislikedFoods.some(df => f.name.toLowerCase().includes(df.toLowerCase()) || f.tags.some(t => t.toLowerCase().includes(df.toLowerCase()))));
                const fillers = availableFoods.filter(f => (mealType === 'lunch' ? f.fillerLunch : f.fillerDinner) &&
                    isMealTypeCompatible(f, mealType) && !currentMeal.some(item => item.name === f.name));

                if (mealType === 'breakfast') {
                    currentMeal = [];
                    const bulletproofCoffee = availableFoods.find(f => f.name === "Kurşun Geçirmez Kahve");
                    if (bulletproofCoffee && isMealTypeCompatible(bulletproofCoffee, mealType)) {
                        currentMeal.push({
                            name: "Kurşun Geçirmez Kahve",
                            quantity: 1,
                            unit: "fincan",
                            role: bulletproofCoffee.role || "drink",
                            calories: bulletproofCoffee.calories || 90,
                            protein: bulletproofCoffee.protein || 0,
                            fat: bulletproofCoffee.fat || 10,
                            carbs: bulletproofCoffee.carbs || 0
                        });
                        console.log(`Kahvaltı: Kurşun Geçirmez Kahve eklendi.`);
                    }
                } else {
                    const min = mealType === 'lunch' ? settings.lunchMin : settings.dinnerMin;
                    const max = mealType === 'lunch' ? settings.lunchMax : settings.dinnerMax;

                    let currentCalories = currentMeal.reduce((sum, item) => {
                        const food = availableFoods.find(f => f.name === item.name);
                        return sum + (food ? food.calories * item.quantity : 0);
                    }, 0);
                    let currentProtein = currentMeal.reduce((sum, item) => {
                        const food = availableFoods.find(f => f.name === item.name);
                        return sum + (food ? food.protein * item.quantity : 0);
                    }, 0);
                    let currentFat = currentMeal.reduce((sum, item) => {
                        const food = availableFoods.find(f => f.name === item.name);
                        return sum + (food ? food.fat * item.quantity : 0);
                    }, 0);
                    let currentCarbs = currentMeal.reduce((sum, item) => {
                        const food = availableFoods.find(f => f.name === item.name);
                        return sum + (food ? food.carbs * item.quantity : 0);
                    }, 0);

                    // Ana yemek ekleme
                    while (currentMeal.length < max && mealFoods.length > 0) {
                        const bestFood = findBestFood(mealFoods, {
                            calories: mealTargets.calories - currentCalories,
                            protein: mealTargets.protein - currentProtein,
                            fat: mealTargets.fat - currentFat,
                            carbs: mealTargets.carbs - currentCarbs
                        }, currentMeal, mealType, prioritizedRules);

                        if (!bestFood) {
                            console.log(`Ana yemek ekleme (${mealType}): Uygun yemek bulunamadı.`);
                            break;
                        }

                        if ((mealType === 'lunch' || mealType === 'dinner') && bestFood.role === 'mainDish') {
                            const mainDishCount = currentMeal.filter(item => {
                                const food = availableFoods.find(f => f.name === item.name);
                                return food && food.role === 'mainDish';
                            }).length;
                            if (mainDishCount >= 1) {
                                console.log(`Engellendi (${mealType}): ${bestFood.name} (mainDish, zaten bir mainDish var)`);
                                mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                                continue;
                            }
                        }

                        if ((mealType === 'lunch' || mealType === 'dinner') && checkKeywordConflict(bestFood.name, currentMeal)) {
                            console.log(`Engellendi (${mealType}): ${bestFood.name} (etiket çakışması)`);
                            mealFoods.splice(mealFoods.indexOf(bestFood), 1);
                            continue;
                        }

                        const quantity = calculateOptimalQuantity(bestFood, {
                            calories: mealTargets.calories - currentCalories,
                            protein: mealTargets.protein - currentProtein,
                            fat: mealTargets.fat - currentFat,
                            carbs: mealTargets.carbs - currentCarbs
                        }, currentMeal, mealType, availableFoods);

                        const foodCalories = bestFood.calories * quantity;
                        const foodProtein = bestFood.protein * quantity;
                        const foodFat = bestFood.fat * quantity;
                        const foodCarbs = bestFood.carbs * quantity;

                        if (currentCalories + foodCalories <= mealTargets.calories * (1 + macroTolerance)) {
                            currentMeal.push({ name: bestFood.name, quantity });
                            currentCalories += foodCalories;
                            currentProtein += foodProtein;
                            currentFat += foodFat;
                            currentCarbs += foodCarbs;
                            console.log(`Eklendi (${mealType}): ${bestFood.name} (${quantity}x), Kalori: ${currentCalories}/${mealTargets.calories}, Protein: ${currentProtein}/${mealTargets.protein}, Yağ: ${currentFat}/${mealTargets.fat}`);
                        } else {
                            console.log(`Engellendi (${mealType}): ${bestFood.name} (kalori sınırı aşıldı)`);
                            break;
                        }
                    }

                    // Dolgu yemek ekleme
                    while ((currentProtein < mealTargets.protein * 0.95 || currentFat < mealTargets.fat * 0.95) && fillers.length > 0 && currentMeal.length < max) {
                        const bestFiller = findBestFood(fillers, {
                            calories: mealTargets.calories - currentCalories,
                            protein: mealTargets.protein - currentProtein,
                            fat: mealTargets.fat - currentFat,
                            carbs: mealTargets.carbs - currentCarbs
                        }, currentMeal, mealType, prioritizedRules);

                        if (!bestFiller) {
                            console.log(`Dolgu yemek ekleme (${mealType}): Uygun dolgu yemeği bulunamadı.`);
                            break;
                        }

                        if ((mealType === 'lunch' || mealType === 'dinner') && bestFiller.role === 'mainDish') {
                            const mainDishCount = currentMeal.filter(item => {
                                const food = availableFoods.find(f => f.name === item.name);
                                return food && food.role === 'mainDish';
                            }).length;
                            if (mainDishCount >= 1) {
                                console.log(`Engellendi (${mealType}): ${bestFiller.name} (mainDish, zaten bir mainDish var)`);
                                fillers.splice(fillers.indexOf(bestFiller), 1);
                                continue;
                            }
                        }

                        if ((mealType === 'lunch' || mealType === 'dinner') && checkKeywordConflict(bestFiller.name, currentMeal)) {
                            console.log(`Engellendi (${mealType}): ${bestFiller.name} (etiket çakışması)`);
                            fillers.splice(fillers.indexOf(bestFiller), 1);
                            continue;
                        }

                        const quantity = calculateOptimalQuantity(bestFiller, {
                            calories: mealTargets.calories - currentCalories,
                            protein: mealTargets.protein - currentProtein,
                            fat: mealTargets.fat - currentFat,
                            carbs: mealTargets.carbs - currentCarbs
                        }, currentMeal, mealType, availableFoods);

                        const foodCalories = bestFiller.calories * quantity;
                        const foodProtein = bestFiller.protein * quantity;
                        const foodFat = bestFiller.fat * quantity;
                        const foodCarbs = bestFiller.carbs * quantity;

                        if (currentCalories + foodCalories <= mealTargets.calories * (1 + macroTolerance)) {
                            currentMeal.push({ name: bestFiller.name, quantity });
                            currentCalories += foodCalories;
                            currentProtein += foodProtein;
                            currentFat += foodFat;
                            currentCarbs += foodCarbs;
                            console.log(`Filler eklendi (${mealType}): ${bestFiller.name} (${quantity}x), Kalori: ${currentCalories}/${mealTargets.calories}, Protein: ${currentProtein}/${mealTargets.protein}, Yağ: ${currentFat}/${mealTargets.fat}`);
                            fillers.splice(fillers.indexOf(bestFiller), 1);
                        } else {
                            console.log(`Engellendi (${mealType}): ${bestFiller.name} (kalori sınırı aşıldı)`);
                            break;
                        }
                    }
                }

                dayData.meals[mealType] = currentMeal;
                console.log(`${mealType}: Protein: ${getCurrentMacro(currentMeal, 'protein', availableFoods)}/${mealTargets.protein}, Yağ: ${getCurrentMacro(currentMeal, 'fat', availableFoods)}/${mealTargets.fat}, Kalori: ${getCurrentMacro(currentMeal, 'calories', availableFoods)}/${mealTargets.calories}`);
            });
        });
    });

    weeks.forEach((week, weekIndex) => {
        Object.values(week.days).forEach(day => {
            ['breakfast', 'lunch', 'dinner'].forEach(mealType => {
                let mealItems = day.meals[mealType] || [];
                prioritizedRules.filter(rule => rule.type === 'dependOn').forEach(rule => {
                    const hasRequired = mealItems.some(item => item.name.toLowerCase().includes(rule.requiredFood.toLowerCase()));
                    const hasFood = mealItems.some(item => item.name.toLowerCase().includes(rule.food.toLowerCase()));
                    if (hasFood && !hasRequired) {
                        day.meals[mealType] = mealItems.filter(item => !item.name.toLowerCase().includes(rule.food.toLowerCase()));
                        console.log(`Son kontrol: (${rule.id}) ${rule.food} kaldırıldı çünkü ${rule.requiredFood} yok, öğün: ${mealType}`);
                    }
                });
            });
        });
    });

    renderMeals();
    calculateMacros();

    if (typeof showNotification === 'function') {
        showNotification("Planlama tamamlandı!", "success", 3000);
    }
}

function saveSettingsTemplate(isDefault = false) {
            const templateName = isDefault ? 'default' : (document.getElementById('settingsTemplate').value || currentPatient);
            if (!templateName) {
                showNotification("Şablon adı girin!", 'warning');
                return;
            }
            const settings = {
                minItemsPerMeal: document.getElementById('minItemsPerMeal').value,
                maxItemsPerMeal: document.getElementById('maxItemsPerMeal').value,
                lunchCalorieRatio: document.getElementById('lunchCalorieRatio').value,
                dinnerCalorieRatio: document.getElementById('dinnerCalorieRatio').value,
                calorieFlexibility: document.getElementById('calorieFlexibility').value,
                varietyScore: document.getElementById('varietyScore').value,
                carbMultiplier: document.getElementById('carbMultiplier').value,
                proteinMultiplier: document.getElementById('proteinMultiplier').value,
                fatMultiplier: document.getElementById('fatMultiplier').value,
                useName: document.getElementById('useName').checked,
                useTags: document.getElementById('useTags').checked,
                prefBreakfastDrink: document.getElementById('prefBreakfastDrink').checked,
                prefLunchEgg: document.getElementById('prefLunchEgg').checked,
                prefLunchSoup: document.getElementById('prefLunchSoup').checked,
                prefDinnerNuts: document.getElementById('prefDinnerNuts').value,
                prefDinnerSoup: document.getElementById('prefDinnerSoup').value,
                prefDinnerDessert: document.getElementById('prefDinnerDessert').value,
                prefDinnerFruit: document.getElementById('prefDinnerFruit').value,
                breakfastMin: document.getElementById('breakfastMin').value,
                breakfastMax: document.getElementById('breakfastMax').value,
                lunchMin: document.getElementById('lunchMin').value,
                lunchMax: document.getElementById('lunchMax').value,
                dinnerMin: document.getElementById('dinnerMin').value,
                dinnerMax: document.getElementById('dinnerMax').value
            };
            localStorage.setItem(`settingsTemplate_${templateName}`, JSON.stringify(settings));
            loadSettingsTemplates();
            showNotification(`Ayarlar ${isDefault ? 'varsayılan olarak' : 'hasta için'} kaydedildi!`);
        }

        function loadSettingsTemplates() {
            const templateSelect = document.getElementById('settingsTemplateSelect');
            const templates = Object.keys(localStorage).filter(key => key.startsWith('settingsTemplate_')).map(key => key.replace('settingsTemplate_', ''));
            templateSelect.innerHTML = '<option value="">Ayar Yükle</option>' + templates.map(t => `<option value="${t}">${t}</option>`).join('');
        }

        function loadSettingsTemplate() {
            const templateName = document.getElementById('settingsTemplateSelect').value;
            if (!templateName) return;
            const settings = JSON.parse(localStorage.getItem(`settingsTemplate_${templateName}`) || '{}');
            document.getElementById('minItemsPerMeal').value = settings.minItemsPerMeal || 2;
            document.getElementById('maxItemsPerMeal').value = settings.maxItemsPerMeal || 4;
            document.getElementById('lunchCalorieRatio').value = settings.lunchCalorieRatio || 40;
            document.getElementById('dinnerCalorieRatio').value = settings.dinnerCalorieRatio || 50;
            document.getElementById('calorieFlexibility').value = settings.calorieFlexibility || 10;
            document.getElementById('varietyScore').value = settings.varietyScore || 0.7;
            document.getElementById('carbMultiplier').value = settings.carbMultiplier || (dietMode === 'keto' ? 0.3 : 0.6);
            document.getElementById('proteinMultiplier').value = settings.proteinMultiplier || 0.8;
            document.getElementById('fatMultiplier').value = settings.fatMultiplier || (dietMode === 'keto' ? 1.2 : 1.0);
            document.getElementById('useName').checked = settings.useName !== false;
            document.getElementById('useTags').checked = settings.useTags !== false;
            document.getElementById('prefBreakfastDrink').checked = settings.prefBreakfastDrink !== false;
            document.getElementById('prefLunchEgg').checked = settings.prefLunchEgg !== false;
            document.getElementById('prefLunchSoup').checked = settings.prefLunchSoup !== false;
            document.getElementById('prefDinnerNuts').value = settings.prefDinnerNuts || 50;
            document.getElementById('prefDinnerSoup').value = settings.prefDinnerSoup || 50;
            document.getElementById('prefDinnerDessert').value = settings.prefDinnerDessert || 50;
            document.getElementById('prefDinnerFruit').value = settings.prefDinnerFruit || 50;
            document.getElementById('breakfastMin').value = settings.breakfastMin || 1;
            document.getElementById('breakfastMax').value = settings.breakfastMax || 1;
            document.getElementById('lunchMin').value = settings.lunchMin || 2;
            document.getElementById('lunchMax').value = settings.lunchMax || 4;
            document.getElementById('dinnerMin').value = settings.dinnerMin || 2;
            document.getElementById('dinnerMax').value = settings.dinnerMax || 4;
            calculateMacros();
            showNotification("Ayarlar yüklendi!");
        }

        function applySettings() {
            calculateMacros();
            generateAutoPlan();
            showNotification("Ayarlar uygulandı ve plan güncellendi!");
        }

        function searchEditFood(query) {
        console.log(`Yemek aranıyor: ${query}`);
    console.log("searchEditFood çalışıyor, query:", query);
    const filterType = document.getElementById('editSearchFilterType').value;
    const editCategoriesDiv = document.getElementById('editCategories');
    editCategoriesDiv.innerHTML = `
    <div class="accordion" id="mainCategoriesAccordion">
        <div class="accordion-item">
            <h2 class="accordion-header" id="mainCategoriesHeading" style="display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 1rem;">
                <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#mainCategoriesCollapse" aria-expanded="false" aria-controls="mainCategoriesCollapse" style="margin: 0; padding: 0.25rem 0.5rem;">
                    Kategoriler
                </button>
                <div class="d-flex align-items-center">
                    <select id="editMoveToCategory" class="form-select d-inline w-auto" style="font-size: 0.85rem; margin-right: 0.5rem;">
                        <option value="">Kategori Seç</option>
                        ${categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('')}
                    </select>
                    <button class="btn btn-primary d-inline" onclick="moveSelectedFoods()" style="font-size: 0.85rem; padding: 0.3rem 0.6rem;">Taşı</button>
                </div>
            </h2>
            <div id="mainCategoriesCollapse" class="accordion-collapse collapse" aria-labelledby="mainCategoriesHeading" data-bs-parent="#mainCategoriesAccordion">
                <div class="accordion-body" style="max-height: 400px; overflow-y: auto;">
                    ${categories.map((category, catIndex) => {
                        const filteredItems = category.items.filter(item => {
                            if (filterType === 'name') return item.name.toLowerCase().includes(query.toLowerCase());
                            if (filterType === 'tags') return item.tags && item.tags.some(tag => tag.toLowerCase().includes(query.toLowerCase()));
                            if (filterType === 'role') return item.role && item.role.toLowerCase().includes(query.toLowerCase());
                            return true;
                        });
                        return `
                            <div class="accordion-item">
                                <h2 class="accordion-header" id="editHeading${catIndex}">
                                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#editCollapse${catIndex}" aria-expanded="false" aria-controls="editCollapse${catIndex}">
                                        <input type="checkbox" class="category-checkbox" data-category-index="${catIndex}"> ${category.name} (${filteredItems.length})
                                    </button>
                                </h2>
                                <div id="editCollapse${catIndex}" class="accordion-collapse collapse" aria-labelledby="editHeading${catIndex}">
                                    <div class="accordion-body">
                                        ${filteredItems.map((item, itemIndex) => `
                                            <div class="category-item d-flex justify-content-between">
                                                <div>
                                                    <input type="checkbox" class="food-checkbox" data-category="${category.name}" data-food="${item.name}">
                                                    <span>${item.name} (${item.calories || 0} kcal)</span>
                                                </div>
                                                <div>
                                                    <button class="btn btn-danger btn-sm me-1" onclick="deleteFood('${item.name}', '${category.name}')" title="Sil"><i class="bi bi-trash"></i></button>
                                                    <button class="btn btn-warning btn-sm" onclick="editFood('${item.name}')" title="Düzenle"><i class="bi bi-pencil"></i></button>
                                                </div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            </div>
        </div>
    </div>
    `;
    console.log("editCategories güncellendi, editMoveToCategory mevcut mu?:", document.getElementById('editMoveToCategory'));
}
function deleteFood(foodName, categoryName) {
    if (confirm(`${foodName} yemeğini silmek istediğinize emin misiniz?`)) {
        saveState(); // Silmeden önce durumu kaydet
        const normalizedCategoryName = categoryName.trim().toLowerCase();
        const category = categories.find(cat => cat.name.trim().toLowerCase() === normalizedCategoryName);
        if (category) {
            // Yemek adını normalleştir ve esnek bir eşleştirme yap
            const normalizedFoodName = foodName.trim().toLowerCase().replace(/[()]/g, ''); // Parantezleri kaldır
            const foodIndex = category.items.findIndex(item => {
                const itemName = item.name.trim().toLowerCase().replace(/[()]/g, '');
                return itemName.includes(normalizedFoodName) || normalizedFoodName.includes(itemName);
            });
            if (foodIndex !== -1) {
                category.items.splice(foodIndex, 1);
                showNotification(`${foodName} yemeği silindi!`);
                loadCategories();
                searchEditFood(''); // Sağ paneli yenile
            } else {
                console.error(`Yemek bulunamadı: ${foodName} in ${categoryName}`);
            }
        } else {
            console.error(`Kategori bulunamadı: ${categoryName}`);
        }
    }
}

function moveSelectedFoods(attempts = 5) {
    let categoryElement = document.getElementById("editMoveToCategory");
    if (!categoryElement) {
        if (attempts > 0) {
            console.log("editMoveToCategory elementi henüz yüklenmedi! 1 saniye bekleniyor... Kalan deneme: " + attempts);
            setTimeout(() => moveSelectedFoods(attempts - 1), 1000); // 1 saniye sonra tekrar dene
        } else {
            console.error("editMoveToCategory bulunamadı, işlem iptal edildi!");
            showNotification("Kategori seçme öğesi yüklenemedi!", "danger");
        }
        return;
    }
    let targetCategory = categoryElement.value;
    if (!targetCategory) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }

    const selectedFoods = document.querySelectorAll(".food-checkbox:checked");
    if (selectedFoods.length === 0) {
        showNotification("Taşınacak yemek seçilmedi!", "warning");
        return;
    }

    selectedFoods.forEach(checkbox => {
        const foodName = checkbox.dataset.food;
        const oldCategoryName = checkbox.dataset.category;
        const oldCategory = categories.find(cat => cat.name === oldCategoryName);
        const foodIndex = oldCategory.items.findIndex(item => item.name === foodName);
        const food = oldCategory.items.splice(foodIndex, 1)[0];
        const newCategory = categories.find(cat => cat.name === targetCategory);
        newCategory.items.push(food);
    });

    showNotification(`${selectedFoods.length} yemek "${targetCategory}" kategorisine taşındı!`);
    loadCategories();
    searchEditFood('');
}

function deleteSelectedCategory() {
    const selectedCheckbox = document.querySelector('#editCategories .category-checkbox:checked');
    if (!selectedCheckbox) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const index = parseInt(selectedCheckbox.getAttribute('data-category-index'));
    if (confirm(`${categories[index].name} kategorisini silmek istediğinize emin misiniz?`)) {
        categories.splice(index, 1);
        searchEditFood(''); // Sağ paneli yenile
        loadCategories(); // Sol paneli de yenile
        showNotification("Kategori silindi!");
    }
}
function editFood(foodName) {
    // Yemek adını kalori bilgisinden ayır (örneğin, "Kurşun Geçirmez Kahve (90 kcal)" -> "Kurşun Geçirmez Kahve")
    const normalizedName = foodName.replace(/\s*\(\d+\s*kcal\)/i, '').trim();
    console.log(`editFood çağrıldı, orijinal isim: ${foodName}, normalleştirilmiş isim: ${normalizedName}`);

    const food = findFood(normalizedName);
    if (!food) {
        console.error(`Yemek bulunamadı: ${normalizedName}`);
        console.log(`categories dizisi:`, JSON.stringify(categories, null, 2)); // categories dizisini logla
        showNotification(`Yemek bulunamadı: ${normalizedName}`, "warning");
        return;
    }

    const panel = document.getElementById('editFoodPanel');
    if (!panel) {
        console.error("editFoodPanel elemanı bulunamadı!");
        showNotification("Düzenleme paneli bulunamadı!", "warning");
        return;
    }

    // Form alanlarını doldur
    document.getElementById('editFoodIndex').value = '';
    document.getElementById('editFoodOriginalName').value = normalizedName; // Normalleştirilmiş adı kullan
    document.getElementById('editFoodName').value = food.name || '';
    document.getElementById('editFoodCalories').value = food.calories || 0;
    document.getElementById('editFoodProtein').value = food.protein || 0;
    document.getElementById('editFoodCarbs').value = food.carbs || 0;
    document.getElementById('editFoodFat').value = food.fat || 0;
    document.getElementById('editFoodMaxQuantity').value = food.maxQuantity || 1;
    document.getElementById('editFoodMinQuantity').value = food.minQuantity || 0.5;
    document.getElementById('editFoodStep').value = food.step || 0.5;
    document.getElementById('editFoodRole').value = food.role || '';
    document.getElementById('editFoodTags').value = food.tags && Array.isArray(food.tags) ? food.tags.join(', ') : '';
    document.getElementById('editFoodMealType').value = food.mealType && Array.isArray(food.mealType) ? food.mealType.join(',') : '';
    document.getElementById('editFoodKeto').checked = !!food.keto;
    document.getElementById('editFoodLowCarb').checked = !!food.lowcarb;
    document.getElementById('editFoodFillerLunch').checked = !!food.fillerLunch;
    document.getElementById('editFoodFillerDinner').checked = !!food.fillerDinner;
    document.getElementById('editFoodSeason').value = food.season || '4 mevsim';
    document.getElementById('editFoodPortionFixed').checked = !!food.portionFixed;
    document.getElementById('editFoodMultiplier').value = food.multiplier || 1;

    const categorySelect = document.getElementById('editFoodMoveToCategory');
    if (!categorySelect) {
        console.error("editFoodMoveToCategory elemanı bulunamadı!");
        showNotification("Kategori seçimi elemanı bulunamadı!", "warning");
        return;
    }
    
    // Kategori açılır menüsünü doldur
    categorySelect.innerHTML = '<option value="">Kategori Seç</option>' + 
        categories.map(cat => `<option value="${cat.name}">${cat.name}</option>`).join('');
    
    // Mevcut kategoriyi varsayılan olarak seç
    if (food.category) {
        categorySelect.value = food.category;
        console.log(`Yemek: ${normalizedName}, Mevcut Kategori: ${food.category}, Seçilen Değer: ${categorySelect.value}`);
        if (categorySelect.value !== food.category) {
            console.warn(`Kategori eşleşmedi! Mevcut: ${food.category}, Seçilen: ${categorySelect.value}`);
        }
    } else {
        categorySelect.value = '';
        console.warn(`Yemek için kategori tanımlı değil: ${normalizedName}`);
    }

    panel.style.display = 'block';
}
document.addEventListener('DOMContentLoaded', () => {
  const resizer = document.getElementById('resizer');
  const sidebar = document.getElementById('sidebar');
  let isResizing = false;

  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'ew-resize'; // Sürüklerken imleç değişir
  });

  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    const newWidth = e.clientX;
    const minWidth = 100; // Daha esnek minimum
    const maxWidth = window.innerWidth * 0.5; // Ekranın yarısına kadar

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      sidebar.style.width = `${newWidth}px`;
    }
  });

  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = 'default'; // İmleci normale döndür
    }
  });
});
        



document.addEventListener('DOMContentLoaded', () => {
  const resizer = document.getElementById('resizer');
  const sidebar = document.getElementById('sidebar');
  let isResizing = false;

  resizer.addEventListener('mousedown', (e) => {
    isResizing = true;
    document.body.style.cursor = 'ew-resize';
  });

  document.addEventListener('mousemove', (e) => {
    if (!isResizing) return;
    const newWidth = e.clientX;
    const minWidth = 100;
    const maxWidth = window.innerWidth * 0.5;

    if (newWidth >= minWidth && newWidth <= maxWidth) {
      sidebar.style.width = `${newWidth}px`;
    }
  });

  document.addEventListener('mouseup', () => {
    if (isResizing) {
      isResizing = false;
      document.body.style.cursor = 'default';
    }
  });
});



        function loadCategoryOptions() {
    let categorySelect = document.getElementById("editMoveToCategory");
    if (!categorySelect) {
        console.log("editMoveToCategory bulunamadı!");
        return;
    }
    console.log("Kategoriler:", categories); // categories dizisini kontrol et
    categorySelect.innerHTML = '<option value="">Kategori Seç</option>';
    categories.forEach(category => {
        let option = document.createElement("option");
        option.value = category.name;
        option.textContent = category.name;
        categorySelect.appendChild(option);
    });
    categorySelect.onchange = function() {
        console.log("Seçilen kategori: " + categorySelect.value);
    };
}

// Yemek düzenleme paneli açıldığında kategori listesini güncelle
document.getElementById("editFoodPanel").addEventListener("click", loadCategoryOptions);



// Popup kapatma fonksiyonu
function closeEditFoodPanel() {
    const panel = document.getElementById('editFoodPanel');
    if (panel) {
        panel.style.display = 'none';
    }
    // Sol ve sağ panelleri güncelle
    loadCategories();
    searchEditFood('');
}


// Kategori taşıma fonksiyonu
function moveFoodCategory() {
    const categoryElement = document.getElementById("editFoodMoveToCategory");
    if (!categoryElement) {
        showNotification("Kategori seçme öğesi bulunamadı!", "warning");
        return;
    }
    const selectedValue = categoryElement.value.trim();
    if (!selectedValue) {
        showNotification("Lütfen bir kategori seçin!", "warning");
        return;
    }
    const foodName = document.getElementById("editFoodOriginalName").value;
    const oldCategory = categories.find(cat => cat.items.some(item => item.name === foodName));
    if (!oldCategory) {
        showNotification("Eski kategori bulunamadı!", "warning");
        return;
    }
    const foodIndex = oldCategory.items.findIndex(item => item.name === foodName);
    if (foodIndex === -1) {
        showNotification("Yemek bulunamadı!", "warning");
        return;
    }
    const food = oldCategory.items.splice(foodIndex, 1)[0];
    const newCategory = categories.find(cat => cat.name === selectedValue);
    if (!newCategory) {
        showNotification("Yeni kategori bulunamadı!", "warning");
        return;
    }
    newCategory.items.push(food);
    showNotification(`"${foodName}" yemeği "${selectedValue}" kategorisine taşındı!`);
    loadCategories();
    searchEditFood('');
    categoryElement.value = selectedValue; // Yeni kategori seçili kalır
}


document.addEventListener('DOMContentLoaded', async () => {
    saveState(); // İlk durumu kaydet
    initializeWeeks();
    
    // GitHub'dan veri yüklenmesini bekle
    await updateGitHubData();
    
    // Veriler yüklendikten sonra kategorileri ve diğer bileşenleri yükle
    loadCategories();
    renderWeekTabs();
    renderDayTabs();
    renderMeals();
    loadPatientSelect();
    loadRules();
    loadMealTemplates();
    loadCompatibilityRules();
    loadSettingsTemplates();
    loadRuleTemplates();
    calculateMacros();
    searchEditFood('');
    document.getElementById("editFoodPanel").addEventListener("click", function(event) {
        if (event.target.tagName !== "SELECT") {
            loadCategoryOptions();
        }
    });
});
    </script>
<script>
        // Mevcut öğünü şablonlara ekleyen fonksiyon
function addCurrentMealToTemplates(mealType) {
    console.log(`${mealType} öğünü şablonlara eklendi.`);
    const selectedMeals = weeks[selectedWeek - 1].days[selectedDay].meals[mealType];
    if (!selectedMeals || selectedMeals.length === 0) {
        showNotification("Bu öğünde yemek bulunmuyor!", "warning");
        return;
    }

    const templateName = prompt("Şablon için bir ad girin:", `${mealType} şablonu`);
    if (!templateName) return;

    const items = selectedMeals.map(meal => ({
        keyword: meal.name,
        role: meal.role || "mainDish",
        quantity: meal.quantity || 1
    }));

    mealTemplates.push({
        mealType,
        frequency: 1,
        items,
        name: templateName
    });

    loadMealTemplates();
    showNotification("Öğün şablonlara eklendi!", "success");
    console.log(`Mevcut öğün (${mealType}) şablonlara eklendi:`, items);
}

// Sayfa yüklendiğinde "Şablona Ekle" butonlarını dinamik olarak ekler
document.addEventListener("DOMContentLoaded", function() {
    setTimeout(() => {
        document.querySelectorAll(".meal-card .card-header").forEach(header => {
            const title = header.childNodes[0].textContent.trim().toLowerCase();
            const mealType = title.includes("öğle") ? "lunch" : title.includes("akşam") ? "dinner" : null;

            // Sadece öğle ve akşam için buton ekle
            if (mealType) {
                // Eğer buton zaten varsa tekrar ekleme
                if (header.querySelector(".template-add-btn")) return;

                const addButton = document.createElement("button");
                addButton.className = "btn btn-sm btn-success template-add-btn mt-1";
                addButton.innerHTML = "Şablona Ekle";
                addButton.onclick = () => addCurrentMealToTemplates(mealType);
                header.appendChild(addButton);
            }
        });
    }, 1000); // Sayfa yüklendikten 1 saniye sonra butonları ekler
});
        </script>
<script>
    function formatQuantityWithText(text) {
    // Sayısal kısmı ayıkla ve yuvarla
    const match = text.match(/^(\d*\.?\d*)\s*(.*)$/);
    if (match) {
        let quantity = parseFloat(match[1]);
        const unit = match[2].trim().toLowerCase();

        // Yuvarlama uygula
        quantity = roundQuantity(quantity);

        // Tanımlı ölçü birimleri için formatlama
        if (['dilim', 'kase', 'bardak', 'yemek', 'porsiyon', 'adet', 'tatlı kaşığı', 'çorba kaşığı', 'tabak', 'fincan', 'yaprak', 'yemek kaşığı', 'gram', 'kare'].includes(unit)) {
            if (quantity === 0.5) return `yarım ${unit}`;
            if (quantity === 0.25) return `çeyrek ${unit}`;
            return `${quantity} ${unit}`;
        }
    }

    return text; // Eğer format uygun değilse orijinali dön
}

    function updateQuantities() {
        const quantityCells = document.querySelectorAll('.quantity-cell'); // Miktar hücrelerinin sınıfı
        quantityCells.forEach(cell => {
            const text = cell.innerText.trim();
            const formattedText = formatQuantityWithText(text);
            if (formattedText !== text) {
                cell.innerText = formattedText;
            }
        });
    }

    document.addEventListener('DOMContentLoaded', updateQuantities);

    document.getElementById('freqCatCheck').addEventListener('change', function() {
    const freqCat = document.getElementById('freqCat');
    freqCat.disabled = !this.checked;
    if (this.checked && freqCat.options.length <= 1) { // Eğer boşsa
        populateCategoryDropdown(); // Tekrar doldur
    }
    console.log("freqCatCheck değişti, freqCat içeriği:", freqCat.innerHTML);
});
</script>
<script>
    function convertMeasurements(text) {
        // "0.5 yemek kaşığı" veya "yarım yemek kaşığı" -> "1 tatlı kaşığı"
        text = text.replace(/\b0\.5\s*yemek kaşığı\b/gi, "1 tatlı kaşığı");
        text = text.replace(/\byarım yemek kaşığı\b/gi, "1 tatlı kaşığı");
        
        // "2 tatlı kaşığı" -> "1 yemek kaşığı"
        text = text.replace(/\b2\s*tatlı kaşığı\b/gi, "1 yemek kaşığı");
        
        // "0.25 yemek kaşığı" -> "çeyrek yemek kaşığı"
        text = text.replace(/\b0\.25\s*yemek kaşığı\b/gi, "çeyrek yemek kaşığı");
        
        return text;
    }

    function applyConversions() {
        const rows = document.querySelectorAll('#mealTable td');
        rows.forEach(cell => {
            const originalText = cell.innerText.trim();
            const convertedText = convertMeasurements(originalText);

            if (originalText !== convertedText) {
                cell.innerText = convertedText;
            }
        });
    }
    // Güncellenmiş updateSidebar fonksiyonu (hasta tercihlerini dikkate alır)
function updateSidebar() {
    const sidebarContent = document.getElementById('categories');
    if (!sidebarContent) {
        console.error("categories elementi bulunamadı!");
        return;
    }

    const patientData = currentPatient ? JSON.parse(localStorage.getItem(`patient_${currentPatient}`) || '{}') : {};
    const dislikedFoods = patientData.dislikedFoods || [];
    const likedFoods = patientData.likedFoods || [];

    sidebarContent.innerHTML = '';

    categories.forEach((category, index) => {
        let validItems = category.items.filter(food => {
            return hasValidCalories(food) &&
                   !dislikedFoods.some(df => food.name.toLowerCase().includes(df.toLowerCase()) ||
                                              (food.tags || []).some(t => t.toLowerCase().includes(df.toLowerCase())));
        });

        // Sevilen yemekleri üste al
        validItems.sort((a, b) => {
            const aLiked = likedFoods.some(lf => a.name.toLowerCase().includes(lf.toLowerCase()) ||
                                                (a.tags || []).some(t => t.toLowerCase().includes(lf.toLowerCase())));
            const bLiked = likedFoods.some(lf => b.name.toLowerCase().includes(lf.toLowerCase()) ||
                                                (b.tags || []).some(t => t.toLowerCase().includes(lf.toLowerCase())));
            return bLiked - aLiked;
        });

        const itemCount = validItems.length;

        const accordionItem = `
            <div class="accordion-item">
                <h2 class="accordion-header" id="heading${index}">
                    <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapse${index}" aria-expanded="false" aria-controls="collapse${index}">
                        ${category.name} (${itemCount})
                    </button>
                </h2>
                <div id="collapse${index}" class="accordion-collapse collapse" aria-labelledby="heading${index}">
                    <div class="accordion-body">
                        ${validItems.map(food => `
                            <div class="category-item">
                                <span>${food.name} (${food.calories} kcal)</span>
                                <div class="food-checkboxes">
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="breakfast" title="Sabah"> S
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="lunch" title="Öğle"> Ö
                                    <input type="checkbox" class="meal-checkbox" data-name="${food.name}" data-meal="dinner" title="Akşam"> A
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            </div>
        `;

        sidebarContent.innerHTML += accordionItem;
    });

    console.log("Sidebar güncellendi, sevmediği yemekler gizlendi, sevilenler üste taşındı.");
}

    document.addEventListener('DOMContentLoaded', applyConversions);

    async function handleUserFormSubmit(event) {
    event.preventDefault(); // Sayfanın yenilenmesini engeller
    const name = document.getElementById('userName').value;
    const weight = document.getElementById('userWeight').value;
    const activity = document.getElementById('userActivity').value;
    const likedFoods = document.getElementById('likedFoodsInput').value.split(',').map(f => f.trim()).filter(f => f);
    const dislikedFoods = document.getElementById('dislikedFoodsInput').value.split(',').map(f => f.trim()).filter(f => f);

    const patientData = {
        name,
        weight: parseFloat(weight) || 70,
        activity: parseInt(activity) || 3,
        likedFoods,
        dislikedFoods
    };

    // localStorage'a kaydet
    localStorage.setItem(`patient_${name}`, JSON.stringify(patientData));
    currentPatient = name;

    // Hasta seçimini güncelle
    loadPatientSelect();
    document.getElementById('patientSelect').value = name;
    handlePatientChange();

    // GitHub'a güncelle
    await updateGitHubData();

    showNotification("Kullanıcı profili kaydedildi!", "success");
}
async function updateGitHubData() {
    console.log("updateGitHubData başladı!");
    const token = document.getElementById('githubToken').value;
    if (!token) {
        showNotification("Lütfen geçerli bir GitHub token girin!", "warning");
        console.log("Token yok!");
        return;
    }

    if (!(await testGitHubToken(token))) {
        showNotification("Geçersiz GitHub token!", "warning");
        console.log("Token geçersiz!");
        return;
    }

    const repoOwner = "mustafasacar35";
    const repoName = "beslenme";
    const filePath = "sistem_JSON.json";
    const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/${filePath}`;

    const data = {
        categories: categories || [],
        weeks: weeks || [],
        rules: rules || [],
        mealTemplates: mealTemplates || [],
        compatibilityTable: compatibilityTable || [],
        patients: Object.keys(localStorage)
            .filter(key => key.startsWith('patient_'))
            .reduce((obj, key) => {
                obj[key] = JSON.parse(localStorage.getItem(key));
                return obj;
            }, {})
    };

    console.log("GitHub'a gönderilen categories (detaylı):", JSON.stringify(categories, null, 2)); // DETAYLI LOG

    const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));

    try {
        console.log("Dosya alınmaya çalışılıyor...");
        const response = await fetch(apiUrl, {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json"
            }
        });

        if (!response.ok) {
            const errorData = await response.json();
            showNotification("Dosya alınamadı: " + errorData.message, "warning");
            console.log("Dosya alınamadı:", errorData.message);
            return;
        }

        const fileData = await response.json();
        const sha = fileData.sha;
        console.log("SHA alındı:", sha);

        console.log("Dosya güncellenmeye çalışılıyor...");
        const updateResponse = await fetch(apiUrl, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${token}`,
                "Accept": "application/vnd.github+json",
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
                message: "Hasta verileri ve diğer veriler güncellendi",
                content: content,
                sha: sha,
                branch: "main"
            })
        });

        if (updateResponse.ok) {
            showNotification("Veriler GitHub'a başarıyla yüklendi!", "success");
            console.log("Yükleme başarılı!");
        } else {
            const errorData = await updateResponse.json();
            showNotification("GitHub'a yükleme başarısız: " + errorData.message, "warning");
            console.log("Yükleme başarısız:", errorData.message);
        }
    } catch (error) {
        showNotification("Bir hata oluştu: " + error.message, "warning");
        console.error("Hata:", error);
    }
}



document.addEventListener('DOMContentLoaded', () => {
    const savedToken = localStorage.getItem('githubToken');
    if (savedToken) {
        document.getElementById('githubToken').value = savedToken;
    }
});

document.getElementById('githubToken').addEventListener('blur', () => {
    const token = document.getElementById('githubToken').value;
    if (token) {
        localStorage.setItem('githubToken', token);
    }
});


// Global değişkenler
let history = [];
let historyIndex = -1; // Başlangıçta -1, hiçbir durum yok
const maxHistorySize = 10;

// Durumu kaydetme fonksiyonu
function saveState() {
    console.log("Durum kaydediliyor...");
    const currentState = {
        weeks: JSON.parse(JSON.stringify(weeks)),
        categories: JSON.parse(JSON.stringify(categories)),
        rules: JSON.parse(JSON.stringify(rules)),
        mealTemplates: JSON.parse(JSON.stringify(mealTemplates)),
        compatibilityTable: JSON.parse(JSON.stringify(compatibilityTable)),
        food_list: JSON.parse(localStorage.getItem("food_list")) || {},
        selectedDay: selectedDay
    };

    // Eğer mevcut indeksten sonra yeni bir işlem yapılıyorsa, eski ileri işlemleri sil
    if (historyIndex < history.length - 1) {
        history = history.slice(0, historyIndex + 1);
    }

    history.push(currentState);
    historyIndex++;

    // Geçmiş boyutunu sınırlama
    if (history.length > maxHistorySize) {
        history.shift();
        historyIndex--;
    }

    console.log("Durum kaydedildi, historyIndex:", historyIndex, "history.length:", history.length);
    updateUndoRedoButtons();
}

// Durumu geri alma
function undo() {
    if (historyIndex > 0) { // İlk durumdan önceki bir duruma gidilebilir
        historyIndex--;
        applyState(history[historyIndex]);
        updateUndoRedoButtons();
        if (typeof showNotification === 'function') {
            showNotification("İşlem geri alındı!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("Geri alınacak işlem yok!", "warning");
        }
    }
}

// Durumu ileri alma
function redo() {
    if (historyIndex < history.length - 1) {
        historyIndex++;
        applyState(history[historyIndex]);
        updateUndoRedoButtons();
        if (typeof showNotification === 'function') {
            showNotification("İşlem ileri alındı!", "success");
        }
    } else {
        if (typeof showNotification === 'function') {
            showNotification("İleri alınacak işlem yok!", "warning");
        }
    }
}

// Durumu uygulama
function applyState(state) {
    weeks = JSON.parse(JSON.stringify(state.weeks));
    categories = JSON.parse(JSON.stringify(state.categories));
    rules = JSON.parse(JSON.stringify(state.rules));
    mealTemplates = JSON.parse(JSON.stringify(state.mealTemplates));
    compatibilityTable = JSON.parse(JSON.stringify(state.compatibilityTable));
    selectedDay = state.selectedDay;
    localStorage.setItem("food_list", JSON.stringify(state.food_list));
    loadCategories();
    renderMeals();
    searchEditFood('');
    calculateMacros();
    console.log("Durum uygulandı, historyIndex:", historyIndex);
}

// Butonların durumunu güncelleme
function updateUndoRedoButtons() {
    const undoButton = document.getElementById("undoButton");
    const redoButton = document.getElementById("redoButton");
    
    if (undoButton) {
        undoButton.disabled = historyIndex < 0; // historyIndex -1 olduğunda pasif
        console.log("Undo butonu durumu:", undoButton.disabled ? "pasif" : "aktif");
    } else {
        console.error("undoButton bulunamadı!");
    }
    
    if (redoButton) {
        redoButton.disabled = historyIndex >= history.length - 1; // İleri durum yoksa pasif
        console.log("Redo butonu durumu:", redoButton.disabled ? "pasif" : "aktif");
    } else {
        console.error("redoButton bulunamadı!");
    }
}


</script>
<!-- Günlük ve Haftalık için Popup -->
<div class="macro-modal" id="macroModal">
<div class="macro-modal-content">
<span class="macro-modal-close">×</span>
<div class="macro-modal-body">
<div class="macro-modal-chart">
<h3 id="macroModalTitle"></h3>
<canvas height="300" id="macroModalChart" width="300"></canvas>
</div>
<div class="macro-modal-analysis" id="macroModalAnalysis"></div>
</div>
</div>
</div>
<script>
// Genel dosya yükleme fonksiyonu (Excel ve TXT desteği)
function importFromFile(event) {
    const file = event.target.files[0];
    if (!file) return;

    const fileExtension = file.name.split('.').pop().toLowerCase();
    console.log("Yüklenen dosya:", file.name, "Uzantı:", fileExtension);

    const reader = new FileReader();
    reader.onload = function(e) {
        const data = fileExtension === 'txt' ? e.target.result : new Uint8Array(e.target.result);
        processFileData(data, fileExtension);
    };

    if (fileExtension === 'xlsx' || fileExtension === 'xls') {
        reader.readAsArrayBuffer(file);
    } else if (fileExtension === 'txt') {
        reader.readAsText(file);
    } else {
        showNotification("Desteklenmeyen dosya formatı! Lütfen .xlsx, .xls veya .txt dosyası yükleyin.", "error");
    }
}

// Dosya verisini işleyen ana fonksiyon
function processFileData(data, fileExtension) {
    let currentMealType = null;
    let currentItems = [];
    let mealIndex = { lunch: 1, dinner: 1 };
    const existingTemplates = new Set(); // Tam şablon içeriğiyle tekrar kontrolü
    const newFoods = [];

    const filterPatterns = [
        /^\*/i,
        /^-/,
        /^\d+\.\s*hafta/i,
        /gün/i,
        /^\s*$/,
        /pazartesi|salı|çarşamba|perşembe|cuma|cumartesi|pazar/i,
        /önerilir/i,
        /^\d+$/ // Yalnızca sayı içeren satırları filtrele (örneğin "1048")
    ];

    if (fileExtension === 'txt') {
        const lines = data.split('\n');
        lines.forEach((line) => {
            const trimmedLine = line.trim();
            if (!trimmedLine || filterPatterns.some(p => p.test(trimmedLine.toLowerCase()))) return;

            // Kesin öğün başlıkları ile eşleştirme
            if (trimmedLine.match(/^lunch\s*\(1x\):/i) || trimmedLine.match(/^öğle\s*\(tercihen/i)) {
                if (currentItems.length > 0 && currentMealType) {
                    saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
                }
                currentMealType = "lunch";
                currentItems = [];
                const mealContent = trimmedLine.replace(/^lunch\s*\(1x\):/i, "").replace(/^öğle\s*\(tercihen[^\)]+\):?/i, "").trim();
                if (mealContent) {
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)$/);
                        const name = nameMatch ? nameMatch[1].trim() : item.trim();
                        const roleMatch = item.match(/\(([^)]+)\)$/);
                        const role = roleMatch ? roleMatch[1] : determineRole(name);
                        if (name && !filterPatterns.some(p => p.test(name))) {
                            currentItems.push({ name, role, calories: 0, carbs: 0, protein: 0, fat: 0 });
                        }
                    });
                }
                console.log("TXT: Öğle öğünü tespit edildi:", currentItems);
                return;
            }

            if (trimmedLine.match(/^dinner\s*\(1x\):/i) || trimmedLine.match(/^akşam\s*\(tercihen/i)) {
                if (currentItems.length > 0 && currentMealType) {
                    saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
                }
                currentMealType = "dinner";
                currentItems = [];
                const mealContent = trimmedLine.replace(/^dinner\s*\(1x\):/i, "").replace(/^akşam\s*\(tercihen[^\)]+\):?/i, "").trim();
                if (mealContent) {
                    const items = mealContent.split(/,\s*(?![^\(]*\))/);
                    items.forEach(item => {
                        const nameMatch = item.match(/(.+?)\s*\((.*?)\)$/);
                        const name = nameMatch ? nameMatch[1].trim() : item.trim();
                        const roleMatch = item.match(/\(([^)]+)\)$/);
                        const role = roleMatch ? roleMatch[1] : determineRole(name);
                        if (name && !filterPatterns.some(p => p.test(name))) {
                            currentItems.push({ name, role, calories: 0, carbs: 0, protein: 0, fat: 0 });
                        }
                    });
                }
                console.log("TXT: Akşam öğünü tespit edildi:", currentItems);
                return;
            }

            // Eğer bir öğün içindeysek ve satır bir öğün başlığı değilse, öğeyi ekle
            if (currentMealType) {
                const parts = trimmedLine.split('\t');
                const name = parts[0].trim();
                const calories = parseFloat(parts[1]) || 0;
                const carbs = parseFloat(parts[2]) || 0;
                const protein = parseFloat(parts[3]) || 0;
                const fat = parseFloat(parts[4]) || 0;
                // Yalnızca geçerli bir isim ve en az bir makro besin değeri varsa ekle
                if (name && !filterPatterns.some(p => p.test(name)) && (calories > 0 || carbs > 0 || protein > 0 || fat > 0)) {
                    currentItems.push({ name, role: determineRole(name), calories, carbs, protein, fat });
                    console.log("TXT: Öğe eklendi:", { name, calories, carbs, protein, fat });
                }
            }
        });

        // Son öğünü kaydet
        if (currentItems.length > 0 && currentMealType) {
            saveImportedTemplate(currentMealType, currentItems, existingTemplates, mealIndex, newFoods);
        }
    }

    integrateNewFoods(newFoods);
    loadMealTemplates();
    loadCategories();
    showNotification(`Dosyadan ${mealIndex.lunch + mealIndex.dinner - 2} şablon ve ${newFoods.length} yeni yemek eklendi!`, "success");
}

// Şablon kaydetme fonksiyonu
function saveImportedTemplate(mealType, items, existingTemplates, mealIndex, newFoods) {
    // Şablonun tam içeriğini sıralı bir şekilde birleştirerek eşsiz bir anahtar oluştur
    const templateKey = `${mealType}|${items.map(i => `${i.name}|${i.role}`).sort().join('|')}`;
    if (existingTemplates.has(templateKey)) {
        console.log("Bu öğün zaten eklendi, tekrar eklenmedi:", templateKey);
        return;
    }
    existingTemplates.add(templateKey);

    const templateItems = items.map(item => {
        const matched = findFoodInCategories(item.name);
        if (!matched) {
            const newFood = {
                name: item.name,
                calories: item.calories || 0,
                protein: item.protein || 0,
                carbs: item.carbs || 0,
                fat: item.fat || 0,
                category: "Yeni Eklenenler",
                mealType: [mealType],
                tags: determineTags(item.name),
                role: item.role || determineRole(item.name),
                keto: true,
                lowcarb: true,
                fillerLunch: mealType === "lunch",
                fillerDinner: mealType === "dinner",
                step: 0.5,
                maxQuantity: 1,
                minQuantity: 0.5
            };
            newFoods.push(newFood);
            return {
                keyword: item.name,
                quantity: 1,
                role: newFood.role,
                macros: {
                    calories: newFood.calories,
                    protein: newFood.protein,
                    carbs: newFood.carbs,
                    fat: newFood.fat
                }
            };
        }
        return {
            keyword: item.name,
            quantity: 1,
            role: matched.role || item.role || "mainDish",
            macros: {
                calories: item.calories || 0,
                protein: item.protein || 0,
                carbs: item.carbs || 0,
                fat: item.fat || 0
            }
        };
    });

    const newTemplate = {
        mealType,
        frequency: 1,
        items: templateItems,
        name: (mealType === "lunch" ? "ÖĞLEN " : "AKŞAM ") + mealIndex[mealType]++
    };
    mealTemplates.push(newTemplate);
    console.log("Yeni şablon eklendi:", newTemplate);
}

// Yeni yemekleri entegre etme
function integrateNewFoods(foods) {
    foods.forEach(food => {
        let category = categories.find(cat => cat.name === food.category);
        if (!category) {
            category = { name: food.category, items: [] };
            categories.push(category);
            console.log(`Yeni kategori oluşturuldu: ${food.category}`);
        }
        if (!category.items.some(item => item.name.toLowerCase() === food.name.toLowerCase())) {
            category.items.push(food);
            console.log(`Yeni yemek eklendi: ${food.name}`);
        }
    });
}

// Yardımcı fonksiyonlar
function findFoodInCategories(name) {
    for (const category of categories) {
        for (const item of category.items) {
            if (item.name === name) {
                item.category = category.name;
                return item;
            }
        }
    }

    const simplified = name.toLowerCase()
        .replace(/\(.*?\)/g, "")
        .replace(/\d+/g, "")
        .replace(/gram|gr|adet|dilim|kase|yk|çk/gi, "")
        .replace(/\s+/g, " ")
        .trim();

    for (const category of categories) {
        for (const item of category.items) {
            const baseName = item.name.toLowerCase().trim();
            if (simplified && baseName.includes(simplified)) {
                item.category = category.name;
                return item;
            }
        }
    }
    return null;
}

function determineRole(foodName) {
    const mainKeywords = ['yumurta', 'köfte', 'tavuk', 'balık', 'kıyma', 'kavurma', 'menemen', 'omlet', 'pirzola', 'et', 'sote'];
    const sideKeywords = ['salata', 'zeytin', 'peynir', 'karnabahar', 'kabak', 'patlıcan', 'mantarlı', 'sebzeli', 'mevsim', 'roka', 'marul'];
    const snackKeywords = ['badem', 'fındık', 'ceviz', 'çekirdeği', 'avokado', 'çikolata'];
    const supplementKeywords = ['kollajen', 'zeytinyağı', 'tereyağı', 'tahin'];
    const drinkKeywords = ['kahve', 'smoothie'];

    const nameLower = foodName.toLowerCase();
    if (mainKeywords.some(k => nameLower.includes(k))) return 'mainDish';
    if (sideKeywords.some(k => nameLower.includes(k))) return 'sideDish';
    if (snackKeywords.some(k => nameLower.includes(k))) return 'snack';
    if (drinkKeywords.some(k => nameLower.includes(k))) return 'drink';
    if (supplementKeywords.some(k => nameLower.includes(k))) return 'supplement';
    return 'sideDish';
}

function determineTags(foodName) {
    const keywords = {
        "yumurta": "yumurta", "köfte": "et", "tavuk": "tavuk", "balık": "balık", "zeytin": "zeytin",
        "peynir": "peynir", "karnabahar": "karnabahar", "kabak": "kabak", "patlıcan": "patlıcan",
        "mantarlı": "mantar", "sebzeli": "sebze", "roka": "roka", "marul": "marul", "badem": "badem",
        "fındık": "fındık", "ceviz": "ceviz", "çekirdeği": "çekirdek", "avokado": "avokado",
        "kahve": "kahve", "smoothie": "smoothie", "kollajen": "kollajen", "zeytinyağı": "zeytinyağı",
        "tereyağı": "tereyağı", "tahin": "tahin", "çikolata": "çikolata"
    };
    let tags = ["keto"];
    for (const [key, tag] of Object.entries(keywords)) {
        if (foodName.toLowerCase().includes(key)) {
            tags.push(tag);
        }
    }
    return tags;
}

// HTML için dosya girişi
document.querySelector('input[type="file"]').addEventListener('change', importFromFile);
</script>
<script>
function deleteFoodFromCategory(foodName, category) {
    if (confirm(`"${foodName}" yemeğini kategoriden silmek istiyor musunuz?`)) {
        let storedFoodList = JSON.parse(localStorage.getItem("food_list")) || {};
        if (storedFoodList[category]) {
            storedFoodList[category] = storedFoodList[category].filter(f => f.name !== foodName);
            localStorage.setItem("food_list", JSON.stringify(storedFoodList));
            alert(`"${foodName}" silindi.`);
            renderCategories(); // kategorileri yeniden çiz
        }
    }
}
document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('undoButton').addEventListener('click', undo);
    document.getElementById('redoButton').addEventListener('click', redo);
});
</script>
<script>
// Sayfa yüklendiğinde bağlan
document.addEventListener("DOMContentLoaded", () => {
    const ids = ["editCarbs", "editProtein", "editFat"];
    ids.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesInPopup);
        }
    });
});

function updateCaloriesInPopup() {
    const carbs = parseFloat(document.getElementById("editCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}
</script>
<script>
function initializeEditFoodPanel() {
    ["editFoodCarbs", "editFoodProtein", "editFoodFat"].forEach(id => {
        const input = document.getElementById(id);
        if (input) {
            input.addEventListener("input", updateCaloriesLive);
        }
    });
    updateCaloriesLive();
}

function updateCaloriesLive() {
    const carbs = parseFloat(document.getElementById("editFoodCarbs")?.value) || 0;
    const protein = parseFloat(document.getElementById("editFoodProtein")?.value) || 0;
    const fat = parseFloat(document.getElementById("editFoodFat")?.value) || 0;
    const kcal = carbs * 4 + protein * 4 + fat * 9;
    const calInput = document.getElementById("editFoodCalories");
    if (calInput) calInput.value = kcal.toFixed(1);
}

document.addEventListener("DOMContentLoaded", () => {
    const panel = document.getElementById("editFoodPanel");
    if (panel) {
        panel.addEventListener("click", () => {
            setTimeout(() => {
                initializeEditFoodPanel();
            }, 50);
        });
    }
});
</script>
<script>
document.addEventListener("DOMContentLoaded", function () {
    const resizer = document.getElementById("resizer");
    const sidebar = document.getElementById("sidebar");
    const mainContent = document.getElementById("mainContent");

    let isResizing = false;

    resizer.addEventListener("mousedown", function (e) {
        isResizing = true;
        document.body.style.cursor = "ew-resize";
    });

    document.addEventListener("mousemove", function (e) {
        if (!isResizing) return;

        const newWidth = e.clientX;
        if (newWidth > 150 && newWidth < window.innerWidth - 150) {
            sidebar.style.width = newWidth + "px";
            mainContent.style.flex = "1";
        }
    });

    document.addEventListener("mouseup", function () {
        isResizing = false;
        document.body.style.cursor = "default";
    });
});
</script></body>
</html>
